{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":0},{"_id":"themes/hexo-theme-next/source/js/affix.js","path":"js/affix.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/exturl.js","path":"js/exturl.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/js.cookie.js","path":"js/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/next-boot.js","path":"js/next-boot.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/motion.js","path":"js/motion.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/scroll-cookie.js","path":"js/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/post-details.js","path":"js/post-details.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/scrollspy.js","path":"js/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"source/images/jus/JMM1.png","path":"images/jus/JMM1.png","modified":1,"renderable":0},{"_id":"themes/hexo-theme-next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"source/images/jus/FutureTask1.png","path":"images/jus/FutureTask1.png","modified":1,"renderable":0},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1}],"Cache":[{"_id":"themes/hexo-theme-next/.all-contributorsrc","hash":"43eb0149c78e464c695f0dd758bb8c59353182b3","modified":1562066492754},{"_id":"themes/hexo-theme-next/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1562066492760},{"_id":"themes/hexo-theme-next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1562066492763},{"_id":"themes/hexo-theme-next/.eslintrc.json","hash":"d3c11de434171d55d70daadd3914bc33544b74b8","modified":1562066492766},{"_id":"themes/hexo-theme-next/.gitattributes","hash":"8454b9313cb1a97b63fb87e2d29daee497ce6249","modified":1562066492769},{"_id":"themes/hexo-theme-next/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1562066492849},{"_id":"themes/hexo-theme-next/README.md","hash":"3f72e5a5051ca2bdaccdda684c46dc4fdb4413a6","modified":1562066492860},{"_id":"themes/hexo-theme-next/LICENSE.md","hash":"0a9c7399f102b4eb0a6950dd31264be421557c7d","modified":1562066492857},{"_id":"themes/hexo-theme-next/_config.yml","hash":"775e0a29c4c7627b6bbfdc79b6c4a73e99915822","modified":1563332854541},{"_id":"themes/hexo-theme-next/bower.json","hash":"8076a6e58a99d1188d335a6456a0de0fda163338","modified":1562066492874},{"_id":"themes/hexo-theme-next/gulpfile.coffee","hash":"6407d9063bd88ede299ff7c2a59cf2c82e079476","modified":1562066492962},{"_id":"themes/hexo-theme-next/crowdin.yml","hash":"4a53f5985e545c635cb56b2a57ed290cb8cf8942","modified":1562066492878},{"_id":"themes/hexo-theme-next/.travis.yml","hash":"fb9ac54e875f6ea16d5c83db497f6bd70ae83198","modified":1562066492854},{"_id":"themes/hexo-theme-next/package.json","hash":"037ed50fbce1520918bf8c3a1c14b6e07676783e","modified":1562066493448},{"_id":"themes/hexo-theme-next/.github/CONTRIBUTING.md","hash":"046262c4b2f54b5ed8ac19b0c99aad04968e01e5","modified":1562066492781},{"_id":"themes/hexo-theme-next/.github/CODE_OF_CONDUCT.md","hash":"f7ddb7faed8031a9f40eae4ee7bb48c1bc50fd14","modified":1562066492774},{"_id":"themes/hexo-theme-next/.github/ISSUE_TEMPLATE.md","hash":"1e212fe229bd659726b4a3bcf4b5b14e0310ba3a","modified":1562066492788},{"_id":"themes/hexo-theme-next/.github/PULL_REQUEST_TEMPLATE.md","hash":"f1631b9bef922e7bc2db1e33badfad70fd88d459","modified":1562066492806},{"_id":"themes/hexo-theme-next/.github/auto_assign.yml","hash":"9fe0dbe3f6edc59bf10ea25b14eba0e92e2c8f42","modified":1562066492811},{"_id":"themes/hexo-theme-next/.github/config.yml","hash":"cbd06d0c40afa9fdf056765120e9085826b00d20","modified":1562066492816},{"_id":"themes/hexo-theme-next/.github/eslint-disable-bot.yml","hash":"e06053d417579ed967a94166deb6bda5ce41d805","modified":1562066492822},{"_id":"themes/hexo-theme-next/.github/lock.yml","hash":"4f1070097b614b24050f238694127e3573ce8472","modified":1562066492825},{"_id":"themes/hexo-theme-next/.github/stale.yml","hash":"85975c43d606c39b91c0ad32197154be9d482a09","modified":1562066492835},{"_id":"themes/hexo-theme-next/.github/release-drafter.yml","hash":"d01b1e8f462af114e3934fef2ee654634d86b406","modified":1562066492832},{"_id":"themes/hexo-theme-next/.github/topissuebot.yml","hash":"5091c3bc6f3df303d16d853ce65a302601c1e875","modified":1562066492843},{"_id":"themes/hexo-theme-next/.github/mergeable.yml","hash":"1c1cb77a62df1e3654b151c2da34b4a10d351170","modified":1562066492828},{"_id":"themes/hexo-theme-next/.github/support.yml","hash":"7ce2722d6904c31a086444c422dc49b6aa310651","modified":1562066492839},{"_id":"themes/hexo-theme-next/.github/weekly-digest.yml","hash":"6db3bcad65c3156de298f6a3ffd3ba887af4aa4f","modified":1562066492846},{"_id":"themes/hexo-theme-next/docs/AGPL3.md","hash":"f463f95b169d64983f59fa6f3e4b6760290a0e6b","modified":1562066492882},{"_id":"themes/hexo-theme-next/docs/ALGOLIA-SEARCH.md","hash":"1e49c08b446678336b2eacc8bf581faca969f34b","modified":1562066492886},{"_id":"themes/hexo-theme-next/docs/DATA-FILES.md","hash":"9a1895c0a0db705c4c48f512e86917f9af1ec3fb","modified":1562066492892},{"_id":"themes/hexo-theme-next/docs/INSTALLATION.md","hash":"b74ef6fedf76cdb156e2265759ee0a789ddd49cc","modified":1562066492897},{"_id":"themes/hexo-theme-next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"721a1aa9feed1b580ab99af8e69ed22699121e88","modified":1562066492903},{"_id":"themes/hexo-theme-next/docs/AUTHORS.md","hash":"51a0a13da55ff3d596970b2f9ab4531c6b2211f2","modified":1562066492889},{"_id":"themes/hexo-theme-next/docs/LICENSE.txt","hash":"ae5ad07e4f4106bad55535dba042221539e6c7f9","modified":1562066492908},{"_id":"themes/hexo-theme-next/docs/MATH.md","hash":"7d0330c250082a86897d1c96fbb4ef5df59538af","modified":1562066492911},{"_id":"themes/hexo-theme-next/docs/UPDATE-FROM-5.1.X.md","hash":"c9f2ed8e15c137b1885d9ca8b7197d9f457971e9","modified":1562066492917},{"_id":"themes/hexo-theme-next/languages/de.yml","hash":"79b3221344da335743b5ef5a82efa9338d64feb0","modified":1562066492967},{"_id":"themes/hexo-theme-next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1562066492971},{"_id":"themes/hexo-theme-next/languages/en.yml","hash":"d66b8b48840443a4f9c72c7696a21e292f685a47","modified":1562066492974},{"_id":"themes/hexo-theme-next/languages/es.yml","hash":"db1a9f2af477212544c830c2dd986400e26ddd6a","modified":1562066492978},{"_id":"themes/hexo-theme-next/languages/fa.yml","hash":"3227072c7e1bfb16ec0517394b60632f4be921dd","modified":1562066492981},{"_id":"themes/hexo-theme-next/languages/id.yml","hash":"f3302a4dfdc9be38a52d6e081411574b1ea01671","modified":1562066492989},{"_id":"themes/hexo-theme-next/languages/it.yml","hash":"31eb878b53d60ff47e3e534cdd7a839c8801ac6e","modified":1562066492993},{"_id":"themes/hexo-theme-next/languages/fr.yml","hash":"2429c90dad5bb865e3a969be2b373f19b3a77b3b","modified":1562066492985},{"_id":"themes/hexo-theme-next/languages/ja.yml","hash":"3f25eca504ee5a519987b4402731f1bb7f5191c9","modified":1562066492997},{"_id":"themes/hexo-theme-next/languages/nl.yml","hash":"08f16ce395dacc88847fc30dc6b985ce22fb8948","modified":1562066493003},{"_id":"themes/hexo-theme-next/languages/ko.yml","hash":"75f2fe142f76bf623e34ed3570598226f55f2b8b","modified":1562066493000},{"_id":"themes/hexo-theme-next/languages/pt-BR.yml","hash":"c7de8b77f44e75be4f04423088a1c891537aa601","modified":1562066493007},{"_id":"themes/hexo-theme-next/languages/pt.yml","hash":"ca5072c967e5eb1178ffed91827459eda6e4e6e2","modified":1562066493011},{"_id":"themes/hexo-theme-next/languages/ru.yml","hash":"720b92a9ec075b68737d296b1f29ad8e01151c85","modified":1562066493014},{"_id":"themes/hexo-theme-next/languages/uk.yml","hash":"6320439c6e9ff81e5b8f8129ca16e9a744b37032","modified":1562066493020},{"_id":"themes/hexo-theme-next/languages/vi.yml","hash":"e2f0dd7f020a36aa6b73ed4d00dcc4259a7e5e9d","modified":1562066493024},{"_id":"themes/hexo-theme-next/languages/zh-HK.yml","hash":"c22113c4a6c748c18093dae56da5a9e8c5b963cd","modified":1562066493028},{"_id":"themes/hexo-theme-next/languages/zh-TW.yml","hash":"dbf4dd87716babb2db4f5332fae9ec190a6f636a","modified":1562066493037},{"_id":"themes/hexo-theme-next/languages/tr.yml","hash":"6d2f53d3687a7a46c67c78ab47908accd8812add","modified":1562066493016},{"_id":"themes/hexo-theme-next/languages/zh-Hans.yml","hash":"069f15da910d6f9756be448167c07ea5aa5dc346","modified":1562066493031},{"_id":"themes/hexo-theme-next/layout/_layout.swig","hash":"ba786b1baba49021928e2e508da53f2fd1369b3f","modified":1562066493061},{"_id":"themes/hexo-theme-next/layout/category.swig","hash":"ad0ac6a1ff341f8eab9570e7fb443962948c5f9d","modified":1562066493421},{"_id":"themes/hexo-theme-next/layout/archive.swig","hash":"61bc56e77e653684fc834f63dcbdadf18687c748","modified":1562066493417},{"_id":"themes/hexo-theme-next/layout/index.swig","hash":"bdcc9f57adef49706b16b107791cacecbc23c1dc","modified":1562066493425},{"_id":"themes/hexo-theme-next/layout/page.swig","hash":"5d06ee8f477ffc39932d0251aa792ffcaf8faf14","modified":1562066493428},{"_id":"themes/hexo-theme-next/layout/schedule.swig","hash":"e79f43df0e9a6cf48bbf00882de48c5a58080247","modified":1562066493441},{"_id":"themes/hexo-theme-next/layout/post.swig","hash":"af74e97d57cf00cde6f8dbd4364f27910915454e","modified":1562066493433},{"_id":"themes/hexo-theme-next/layout/tag.swig","hash":"283519d4d5b67814412863a3e0212bac18bcc5a0","modified":1562066493445},{"_id":"themes/hexo-theme-next/scripts/merge-configs.js","hash":"5f96f63e86825fd7028c2522e4111103e261a758","modified":1562066493628},{"_id":"themes/hexo-theme-next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1562066495672},{"_id":"themes/hexo-theme-next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1562066495626},{"_id":"themes/hexo-theme-next/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1562066493676},{"_id":"source/_posts/Iterator循环删除list中元素.md","hash":"c631a8200f46bc66637db54935f29fd6cdad98b8","modified":1562066492657},{"_id":"source/_posts/JSON使用经验之java对象与json字符串的互转问题.md","hash":"dada224d2db16911ae97879c4a316ae0bf2ec1af","modified":1562667926522},{"_id":"themes/hexo-theme-next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1562066495719},{"_id":"source/_posts/Mysql学习笔记之事务.md","hash":"d1d1f6946d7f3eb6a5a0a2dbc4b068c8eef4e8cf","modified":1564993558434},{"_id":"source/_posts/Mysql学习笔记之查询优化篇.md","hash":"6a3fb7b6561a1c24d7a27e683937cc57f2e21884","modified":1564993598345},{"_id":"source/_posts/Mysql学习笔记之索引篇.md","hash":"d932b79cfe7b36d9ddf60d04483de3fc5a9be52f","modified":1564993534711},{"_id":"source/_posts/Mysql学习笔记之锁.md","hash":"b64ab3b9a70303606407a26eab7c8090065c6ccf","modified":1564993547820},{"_id":"source/_posts/Mysql学习笔记之explain用法详解.md","hash":"51677d5644e6d78ffb7477a85b362d64fa9b04bb","modified":1563332854532},{"_id":"source/_posts/java8之Stream-Api.md","hash":"b4b89c8e78670975ad57bef2f82d95a23db8e69d","modified":1562066492668},{"_id":"source/_posts/interceptor-配合Threadlocal全局处理请求基本信息.md","hash":"7442360675bd1aaca4513c0f54d79adc0c79ae55","modified":1562066492664},{"_id":"source/_posts/java8之lamda表达式.md","hash":"ebdd2ac2b48648dac5c5a940b8232d7876c3ee1a","modified":1562066492672},{"_id":"source/_posts/java多线程之FutureTask-Future和Callable.md","hash":"de60b669f668f409834d347f07a77ce12a45fe85","modified":1562066492674},{"_id":"source/_posts/java多线程之ThreadPoolExcutor.md","hash":"bc6e3faed1fb060e020741802b53fc7b9cb04f6d","modified":1562066492678},{"_id":"source/_posts/java多线程之synchronized-volatle和final关键字.md","hash":"eec36a8418dcbb9c5f1782a3f1cd1ba9cb39d64c","modified":1562066492681},{"_id":"source/_posts/java多线程之常见面试问题.md","hash":"3da8fef881775760b2ab16bc004a777af85e34f0","modified":1562660657411},{"_id":"source/_posts/java多线程之内存模型.md","hash":"6265435282c2f5b5a8a8d033934a0c1d386e5aa5","modified":1562066492684},{"_id":"source/_posts/markdown简单语法.md","hash":"88af76783b0cfab76dad3fe45a1bee8a392dd253","modified":1562066492690},{"_id":"source/_posts/java多线程之并发工具类.md","hash":"aa4081c5ad51006a3258a0b85a4dffbe5d18c899","modified":1562066492687},{"_id":"source/_posts/markdown高阶语法.md","hash":"ed622f430083e70e5f76b4ee4f9990cd4361524d","modified":1562066492693},{"_id":"source/_posts/spring常用接口之InitializingBean.md","hash":"f2da1c64e7ab3b186703528972b593fc2e291785","modified":1562066492699},{"_id":"source/_posts/记一次线上事故总结.md","hash":"c93d04322ceedcfd10d5206142e6d20d8f31672c","modified":1562066492709},{"_id":"source/_posts/关于提升工作效率的一点思考.md","hash":"89943fcdf615ad53a9c3426437b33399f3fd434a","modified":1562066492702},{"_id":"source/_posts/spring常用接口之BeanpostProccesser.md","hash":"8fbfea73ef5e6cbe80f4d748c0f424f3ccd743ec","modified":1562066492696},{"_id":"source/_posts/设计模式之策略模式.md","hash":"a4b1fba6cfc3a851fc1f6cafa6f4aa1c52c42434","modified":1562066492712},{"_id":"source/categories/index.md","hash":"6d8cea75ca1997b21880acd3ea48cd9e988c2c08","modified":1562066492725},{"_id":"source/about/index.md","hash":"cdc79293c048a2699aa3ca0bacda15cbce4c6b1b","modified":1562066492716},{"_id":"source/tags/index.md","hash":"503f18a44c0334bf9447646e7656604bf36ece90","modified":1562066492747},{"_id":"source/_posts/git常用命令.md","hash":"0ba29e93bb99f778837cb97bdd5be2593a214a4c","modified":1562066492660},{"_id":"themes/hexo-theme-next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1562066494689},{"_id":"source/todolist/index.md","hash":"c24be03a6c8e33e08c9234fd4932f61a2b1afefb","modified":1562660228814},{"_id":"source/images/avatar.jpg","hash":"07a368a88e43961fa2bec480de425d88db74538e","modified":1562066492730},{"_id":"source/books/index.md","hash":"6e4f01e9832caf860f7097d0da893883c1eda5ff","modified":1565079473383},{"_id":"themes/hexo-theme-next/.github/ISSUE_TEMPLATE/custom-issue-template.md","hash":"245917ffaa296bc2d9a85444acf639077ca25944","modified":1562066492796},{"_id":"themes/hexo-theme-next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"795b8ddb251da8e2327299d5f7dbf446fb9867c6","modified":1562066492793},{"_id":"themes/hexo-theme-next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"59b2b45e151972bbe08582cde22f398e58832765","modified":1562066492800},{"_id":"themes/hexo-theme-next/.github/ISSUE_TEMPLATE/non-english.md","hash":"ae22e700b7c63c60746321719a20d34022ad78d9","modified":1562066492803},{"_id":"themes/hexo-theme-next/docs/ru/DATA-FILES.md","hash":"a51de08657f5946f4028b11373280ddc04639525","modified":1562066492922},{"_id":"themes/hexo-theme-next/docs/ru/README.md","hash":"aeb95129ab1da9ec41786bfa86dc32c739ee6358","modified":1562066492928},{"_id":"themes/hexo-theme-next/docs/ru/INSTALLATION.md","hash":"7b2963daac19b0c14f98ebef375d5fbce8fc3f44","modified":1562066492925},{"_id":"themes/hexo-theme-next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"1a4e41adcf5831057f3f7b3025ed4a5ef7c442b4","modified":1562066492932},{"_id":"themes/hexo-theme-next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"aaf25d304793344e2d026062768c93005723f5c6","modified":1562066492935},{"_id":"themes/hexo-theme-next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"018a259694f4a8c7c384e1f323531442cba5fbf3","modified":1562066492938},{"_id":"themes/hexo-theme-next/docs/zh-CN/CONTRIBUTING.md","hash":"16d98708de86efe40ebcb02c02a01af0f160b80a","modified":1562066492941},{"_id":"themes/hexo-theme-next/docs/zh-CN/DATA-FILES.md","hash":"67f4a987e7db0ab1ce1ea4c311f2961df07b6681","modified":1562066492944},{"_id":"themes/hexo-theme-next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"b17fc344ff61603f83387c0f9b2b2189aae81d50","modified":1562066492950},{"_id":"themes/hexo-theme-next/docs/zh-CN/INSTALLATION.md","hash":"baca12cc24be082f1db28c7f283493569666321c","modified":1562066492947},{"_id":"themes/hexo-theme-next/docs/zh-CN/MATH.md","hash":"db2797f161e1e7a4987cbfa3d1be682266dfbba6","modified":1562066492953},{"_id":"themes/hexo-theme-next/docs/zh-CN/README.md","hash":"4016948fdb971e4f905efb7a5bb3add3dd58e7a8","modified":1562066492956},{"_id":"themes/hexo-theme-next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"2095d1214a4e519a1d31b67b41c89080fa3285d3","modified":1562066492959},{"_id":"themes/hexo-theme-next/source/js/affix.js","hash":"ad343aa406fd8181b5f310434817ce98fc2219e3","modified":1562066494814},{"_id":"themes/hexo-theme-next/source/js/algolia-search.js","hash":"84906eeae57bd06744dd20160b93eacf658f97e2","modified":1562066494858},{"_id":"themes/hexo-theme-next/source/js/exturl.js","hash":"c48aa4b3c0e578a807fd3661e6cd4f3890777437","modified":1562066494903},{"_id":"themes/hexo-theme-next/source/js/js.cookie.js","hash":"f11e84def0352b7dd6393f1b83e55a40ab468686","modified":1562066494947},{"_id":"themes/hexo-theme-next/source/js/next-boot.js","hash":"696a0c2cf158001576d56b48195ec8e39e835b47","modified":1562066495040},{"_id":"themes/hexo-theme-next/source/js/motion.js","hash":"d0a6d9dbcc57159e54bbb1f683b86632ae0b78f0","modified":1562066494993},{"_id":"themes/hexo-theme-next/source/js/scroll-cookie.js","hash":"c4867626afab749404daf321367f9b6b8e223f69","modified":1562066495222},{"_id":"themes/hexo-theme-next/source/js/post-details.js","hash":"7d309b771e86c7e22ce11cc25625481ef7d5985c","modified":1562066495084},{"_id":"themes/hexo-theme-next/source/js/scrollspy.js","hash":"68d3690152c89e7adb08bb35ec28dbda2bd93686","modified":1562066495267},{"_id":"themes/hexo-theme-next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1562066494692},{"_id":"themes/hexo-theme-next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1562066494697},{"_id":"themes/hexo-theme-next/source/js/utils.js","hash":"fed16cd4fa5fac8cb4a63633d1840792a056f2be","modified":1562066495313},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1562066494708},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1562066494702},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1562066494714},{"_id":"themes/hexo-theme-next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1562066494699},{"_id":"themes/hexo-theme-next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1562066494726},{"_id":"themes/hexo-theme-next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1562066494733},{"_id":"themes/hexo-theme-next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1562066494739},{"_id":"themes/hexo-theme-next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1562066494746},{"_id":"themes/hexo-theme-next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1562066494752},{"_id":"themes/hexo-theme-next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1562066494749},{"_id":"themes/hexo-theme-next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1562066494755},{"_id":"themes/hexo-theme-next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1562066494720},{"_id":"themes/hexo-theme-next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1562066494759},{"_id":"themes/hexo-theme-next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1562066494761},{"_id":"themes/hexo-theme-next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1562066494765},{"_id":"themes/hexo-theme-next/source/images/searchicon.png","hash":"025d64ba0160a3a2257dd2b3032b5f7c9dd9b82b","modified":1562066494769},{"_id":"themes/hexo-theme-next/source/css/main.styl","hash":"5e7d28bc539e84f8b03e68df82292f7fc0f2d023","modified":1562066494683},{"_id":"themes/hexo-theme-next/layout/_custom/head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1562066493050},{"_id":"themes/hexo-theme-next/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1562066493053},{"_id":"themes/hexo-theme-next/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1562066493056},{"_id":"themes/hexo-theme-next/layout/_partials/comments.swig","hash":"d0b9e841d55c974d02f43823a06a2627f8e46431","modified":1562066493092},{"_id":"themes/hexo-theme-next/layout/_partials/footer.swig","hash":"9a79dde1412b1b1473380e8b6cacfe1930ed321b","modified":1562066493097},{"_id":"themes/hexo-theme-next/layout/_partials/github-banner.swig","hash":"1ad13269b43b900356f3bdab7947d6a86f035a2c","modified":1562066493099},{"_id":"themes/hexo-theme-next/layout/_partials/post-edit.swig","hash":"dee345054d564dd56f74bb143942d3edd1cb8150","modified":1562066493146},{"_id":"themes/hexo-theme-next/layout/_partials/pagination.swig","hash":"914155d5d758306cff405beefd4a07973fd8fc77","modified":1562066493143},{"_id":"themes/hexo-theme-next/layout/_scripts/exturl.swig","hash":"c2e8f4b3a2bf991320ecc827dcdc227399ad5b51","modified":1562066493198},{"_id":"themes/hexo-theme-next/layout/_scripts/commons.swig","hash":"cccd93d30787675010b1a74ef02eb5b813ec1d96","modified":1562066493195},{"_id":"themes/hexo-theme-next/layout/_scripts/scroll-cookie.swig","hash":"8a992b7fe42b9c1a5eb9d937b0827aed91586d94","modified":1562066493228},{"_id":"themes/hexo-theme-next/layout/_scripts/next-boot.swig","hash":"50c3ae6b50f173ae70f8c3312f7c6da1097eb9b6","modified":1562066493202},{"_id":"themes/hexo-theme-next/layout/_scripts/noscript.swig","hash":"efb3404a3303622f3be60944d9d1926972c5c248","modified":1562066493205},{"_id":"themes/hexo-theme-next/layout/_scripts/vendors.swig","hash":"b9b57e1735035319e200c22cf46a38b52b4e0d9c","modified":1562066493232},{"_id":"themes/hexo-theme-next/layout/_third-party/bookmark.swig","hash":"4b93dc7ac0573c402aabcb5c933bbcb893b07c51","modified":1562066493300},{"_id":"themes/hexo-theme-next/layout/_third-party/baidu-push.swig","hash":"87bcb495f7ddd81cc3fe2c2a886e51c08053019b","modified":1562066493296},{"_id":"themes/hexo-theme-next/layout/_third-party/chatra.swig","hash":"87182367d7954457cb2498bbfa9445c03c2d619e","modified":1562066493304},{"_id":"themes/hexo-theme-next/layout/_third-party/mermaid.swig","hash":"80dfc0879866e6512cb67590a3b2d8741a66f980","modified":1562066493363},{"_id":"themes/hexo-theme-next/layout/_third-party/copy-code.swig","hash":"12bf51c55449d0e838f93a4aae9f6d25c0a27ba2","modified":1562066493344},{"_id":"themes/hexo-theme-next/layout/_third-party/pangu.swig","hash":"76f5933925670044ec65b454295ba7e0a8439986","modified":1562066493372},{"_id":"themes/hexo-theme-next/layout/_third-party/pdf.swig","hash":"4ae61c7efb16e962385bfe522a38c4d29cdcccbe","modified":1562066493375},{"_id":"themes/hexo-theme-next/layout/_third-party/needsharebutton.swig","hash":"7db4ad4a8dd5420dad2f6890f5299945df0af970","modified":1562066493367},{"_id":"themes/hexo-theme-next/layout/_third-party/rating.swig","hash":"c476dc3693a9dd0be2d136a45b0d7fdef55d4d92","modified":1562066493384},{"_id":"themes/hexo-theme-next/layout/_third-party/quicklink.swig","hash":"8b1322a091355853db62a5aafb8886fdbd8ab56a","modified":1562066493379},{"_id":"themes/hexo-theme-next/layout/_third-party/schedule.swig","hash":"882cd0b68c493af1b6d945660f9c21085e006ffc","modified":1562066493388},{"_id":"themes/hexo-theme-next/layout/_third-party/tidio.swig","hash":"b44010cd577e4d063c3406772938c4b117ec7b7b","modified":1562066493413},{"_id":"themes/hexo-theme-next/scripts/filters/exturl.js","hash":"b19c7c1021e57367b3b3bbf5678381017ed5667d","modified":1562066493495},{"_id":"themes/hexo-theme-next/scripts/helpers/engine.js","hash":"cdb6152582313268d970ffeef99b4a8a7850f034","modified":1562066493539},{"_id":"themes/hexo-theme-next/scripts/helpers/next-url.js","hash":"a40ce6bc852bb4bff8b9f984fa064741dd151e96","modified":1562066493582},{"_id":"themes/hexo-theme-next/scripts/tags/button.js","hash":"95a520f6529424a03c7ead6dbfd5e626d672febb","modified":1562066493742},{"_id":"themes/hexo-theme-next/scripts/tags/exturl.js","hash":"f9f25905adecfb8be49def4ff3b0b8bbc6955d84","modified":1562066493833},{"_id":"themes/hexo-theme-next/scripts/tags/full-image.js","hash":"a6b2264215c555c553b2c5db85fa90678798d0d5","modified":1562066493877},{"_id":"themes/hexo-theme-next/scripts/tags/include-raw.js","hash":"ab4a82a7246265717556c7a42f897430340b88cf","modified":1562066493965},{"_id":"themes/hexo-theme-next/scripts/tags/label.js","hash":"fc83f4e1be2c34e81cb79938f4f99973eba1ea60","modified":1562066494009},{"_id":"themes/hexo-theme-next/scripts/tags/group-pictures.js","hash":"23d839333422375e85d44e476f554faf49973a3c","modified":1562066493921},{"_id":"themes/hexo-theme-next/scripts/tags/mermaid.js","hash":"81134494ff0134c0dae1b3815caf6606fccd4e46","modified":1562066494053},{"_id":"themes/hexo-theme-next/scripts/tags/pdf.js","hash":"ab995f0fc60d60f637220e2651111b775b8a06de","modified":1562066494141},{"_id":"themes/hexo-theme-next/scripts/tags/tabs.js","hash":"72a5adbd8f300bee1d0c289367598ca06b2bed17","modified":1562066494186},{"_id":"themes/hexo-theme-next/scripts/tags/note.js","hash":"1fdf4f95810fdb983bfd5ad4c4f13fedd4ea2f8d","modified":1562066494096},{"_id":"themes/hexo-theme-next/scripts/tags/video.js","hash":"944293fec96e568d9b09bc1280d5dbc9ee1bbd17","modified":1562066494231},{"_id":"themes/hexo-theme-next/scripts/tags/center-quote.js","hash":"4519ab8e6898f2ee90d05cde060375462b937a7d","modified":1562066493789},{"_id":"themes/hexo-theme-next/layout/_macro/post.swig","hash":"c77a7928d65bfe0fb712a2931b4cd7045666508c","modified":1562066493079},{"_id":"themes/hexo-theme-next/layout/_macro/sidebar.swig","hash":"91017f58f83d9505ce99109fffdc51c032bf017e","modified":1562066493085},{"_id":"themes/hexo-theme-next/layout/_macro/post-collapse.swig","hash":"891ab67815969dd8736cb22fbbb3f791b8fff4e4","modified":1562066493075},{"_id":"themes/hexo-theme-next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1562066494549},{"_id":"themes/hexo-theme-next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1562066494550},{"_id":"themes/hexo-theme-next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1562066494667},{"_id":"themes/hexo-theme-next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1562066494560},{"_id":"themes/hexo-theme-next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1562066494681},{"_id":"source/images/jus/JMM1.png","hash":"0c00e29ed049dd09d5499e91c4b34cd3f3498c82","modified":1562066492742},{"_id":"themes/hexo-theme-next/source/js/schemes/muse.js","hash":"ccc0c5cd4ec6f8159c98990ad83f11a5c0b0234c","modified":1562066495132},{"_id":"themes/hexo-theme-next/source/js/schemes/pisces.js","hash":"3eea56cc9ce47bb4760930c4c69cebf847a7fbb2","modified":1562066495175},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1562066495322},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1562066495326},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1562066495333},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1562066495330},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1562066495337},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1562066495520},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1562066495616},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1562066495568},{"_id":"themes/hexo-theme-next/source/css/_custom/custom.styl","hash":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1562066494542},{"_id":"themes/hexo-theme-next/source/css/_mixins/Gemini.styl","hash":"07f7da320689f828f6e36a6123807964a45157a0","modified":1562066494546},{"_id":"themes/hexo-theme-next/source/css/_mixins/Pisces.styl","hash":"1aabac9e37a8f4451c86d09037b3a1f8b30eaf5e","modified":1562066494552},{"_id":"themes/hexo-theme-next/source/css/_mixins/base.styl","hash":"21a14a19149f1cb8e011c477f29dd1352675605b","modified":1562066494555},{"_id":"themes/hexo-theme-next/source/css/_variables/Pisces.styl","hash":"da7049f3d9a157abe0ecc62611edcf43605ba84d","modified":1562066494668},{"_id":"themes/hexo-theme-next/source/css/_variables/Mist.styl","hash":"a25408534f8fe6e321db4bbf9dd03335d648fe17","modified":1562066494663},{"_id":"themes/hexo-theme-next/source/css/_variables/base.styl","hash":"ebc95eeb8966d17cdc7dd0de009deaef1fe65064","modified":1562066494673},{"_id":"themes/hexo-theme-next/layout/_partials/header/index.swig","hash":"c909f6e96373c151dea325bcddfdd8c9522421b6","modified":1562066493124},{"_id":"themes/hexo-theme-next/layout/_partials/header/brand.swig","hash":"03f669356bbaa70144b743f3312178e1981ac3a8","modified":1562066493120},{"_id":"themes/hexo-theme-next/layout/_partials/header/sub-menu.swig","hash":"e015c7d9b84062b60b15b36be3ef11929dd10943","modified":1562066493131},{"_id":"themes/hexo-theme-next/layout/_partials/head/head-unique.swig","hash":"fd079a414ca0f42f4cddd00247a9d5a5f58c4d8e","modified":1562066493108},{"_id":"themes/hexo-theme-next/layout/_partials/head/head.swig","hash":"39fa6780b9515bc343898ff615c858206728cc3c","modified":1562066493111},{"_id":"themes/hexo-theme-next/layout/_partials/head/external-fonts.swig","hash":"b57bf9c865bed0f22157176a8085de168a1aef77","modified":1562066493104},{"_id":"themes/hexo-theme-next/layout/_partials/page/breadcrumb.swig","hash":"2b905ddd5dea8558c3fd95aacad241da6b6800f4","modified":1562066493136},{"_id":"themes/hexo-theme-next/layout/_partials/page/page-header.swig","hash":"f46699a9daa5fef599733cbab35cb75cf7a05444","modified":1562066493140},{"_id":"themes/hexo-theme-next/source/css/_variables/Gemini.styl","hash":"e9b0752f08398709e787546a246baca12b4c557f","modified":1562066494659},{"_id":"themes/hexo-theme-next/layout/_partials/post/post-copyright.swig","hash":"be6683db6a269d83bb0441d7cf74db63a240fa8a","modified":1562066493150},{"_id":"themes/hexo-theme-next/layout/_partials/post/post-related.swig","hash":"f331ad02beea8990066d32ad6ec9f859672c3615","modified":1562066493154},{"_id":"themes/hexo-theme-next/layout/_partials/post/reward.swig","hash":"f62b801c7999da67b4bdca9c5e373b9b5ed039dc","modified":1562066493158},{"_id":"themes/hexo-theme-next/layout/_partials/post/wechat-subscriber.swig","hash":"fb7727e8ec63a58238a7206bf70eb273c8879993","modified":1562066493162},{"_id":"themes/hexo-theme-next/layout/_partials/share/add-this.swig","hash":"c609097b95eb6127c2784f47f2230e6e6efc0be2","modified":1562066493181},{"_id":"themes/hexo-theme-next/layout/_partials/share/baidushare.swig","hash":"54b43d406cf37932e7b60f46814e864d31b1842c","modified":1562066493184},{"_id":"themes/hexo-theme-next/layout/_partials/share/likely.swig","hash":"647e8677d1ccfb3f7918dd3ea2ff7078504a845d","modified":1562066493190},{"_id":"themes/hexo-theme-next/layout/_partials/search/algolia-search.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1562066493166},{"_id":"themes/hexo-theme-next/layout/_partials/search/index.swig","hash":"f14e9e8c27af82f1bfe794e252dec0d7e521f503","modified":1562066493169},{"_id":"themes/hexo-theme-next/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1562066493172},{"_id":"themes/hexo-theme-next/layout/_partials/search/swiftype.swig","hash":"31245e09ce0465b994cebd94223a531585c4eab4","modified":1562066493176},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/mist.swig","hash":"3c548934b97cc426544947f7a2ae35c270b5e33f","modified":1562066493218},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/gemini.swig","hash":"a62c93f19429f159bcf0c2e533ffc619aa399755","modified":1562066493215},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/muse.swig","hash":"7ef07edd2a97a3774229990d2f0a6eefa31bd015","modified":1562066493221},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/pisces.swig","hash":"828eb9c47f34090c841a2e9a0b3f31b0e4ccf40a","modified":1562066493224},{"_id":"themes/hexo-theme-next/layout/_scripts/pages/post-details.swig","hash":"cf87ab778618a32119ec1c4ac2079a51385b1913","modified":1562066493210},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"66d562b3778dbc839f7c00103bd0099c5d61602a","modified":1562066493238},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/application-insights.swig","hash":"83dd7df11b100bae38c9faab9a478f92149a0315","modified":1562066493241},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/baidu-analytics.swig","hash":"73576c9683d9ad9b124916dc6c660607fe7cc1fa","modified":1562066493246},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"2e1de38f44af00209129d4051b7ae307cb11ad68","modified":1562066493250},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"335005a9f8b36349f0ad0a7beeba6969c55fc7f7","modified":1562066493254},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/facebook-sdk.swig","hash":"f648e5bf8c5dfc74143233976ed4ff5978deda43","modified":1562066493258},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/firestore.swig","hash":"8ab040fccba41675bc835973515530af8a51f8bd","modified":1562066493262},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/google-analytics.swig","hash":"d68da660cd1cc8fb3ff0a81178decadb620afc11","modified":1562066493267},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/index.swig","hash":"39928f358dd13d9fc1a4641800e57be157ecd815","modified":1562066493275},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/growingio.swig","hash":"623e73bedef067ac24a398ef27c8197295da872d","modified":1562066493271},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/lean-analytics.swig","hash":"807aec0e3eae6dae4b972e301259f63dd4c64490","modified":1562066493278},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/tencent-analytics.swig","hash":"d18c87d7839e7407e39acd2998bcc9e0b34611b0","modified":1562066493285},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/tencent-mta.swig","hash":"a22d1ea29a5ffe46199ab7d108a291a05af8d5b6","modified":1562066493289},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/vkontakte-api.swig","hash":"4cff8bf5c42c62f7f0ac1f0d70f839dae39ba77a","modified":1562066493293},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/changyan.swig","hash":"bc3fc9d053b3d1fc0cd3918bf9a629a6f38f6414","modified":1562066493309},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/disqusjs.swig","hash":"280ff4282396beb53fb3913f58c6b5890bd1c9ef","modified":1562066493318},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/disqus.swig","hash":"3da014b25f9ac804eda1614591706e3733c0d2c5","modified":1562066493313},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/gitalk.swig","hash":"4e86e1ace90a70bb8862f5e6de9dbe7bfc046bee","modified":1562066493322},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/gitment.swig","hash":"9a4923d2aa5182531ea7a7fb9abe824450026208","modified":1562066493327},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/index.swig","hash":"b3818fd0b3028dadf341b6d0b180e1243683de6a","modified":1562066493331},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/livere.swig","hash":"1a5d94f5779a2ce13abc886dd78e0617f89c34b9","modified":1562066493334},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/valine.swig","hash":"1b72c755101c9dfb85da13df9a0abccf37cd1dd2","modified":1562066493338},{"_id":"themes/hexo-theme-next/layout/_partials/header/menu.swig","hash":"39c4ad0e36b7c1260da98ba345f7bd72a2ac0f2e","modified":1562066493127},{"_id":"themes/hexo-theme-next/layout/_third-party/math/katex.swig","hash":"ea1c136f960667a0a13b334db497b9b19c41f629","modified":1562066493354},{"_id":"themes/hexo-theme-next/layout/_third-party/math/index.swig","hash":"43a20fa0e9ae2f4254f04813f9c619dd36b49ae5","modified":1562066493349},{"_id":"themes/hexo-theme-next/layout/_third-party/math/mathjax.swig","hash":"767ba29f258db5d2e5baf875a6f36ac1d44df6a3","modified":1562066493358},{"_id":"themes/hexo-theme-next/layout/_third-party/search/algolia-search.swig","hash":"143ef265c96a8ea2fb93c36c5ffb9c5e940f7693","modified":1562066493397},{"_id":"themes/hexo-theme-next/layout/_third-party/search/index.swig","hash":"078bd2d5815eb23e8c5f74467dc0042babea00ae","modified":1562066493401},{"_id":"themes/hexo-theme-next/layout/_third-party/search/localsearch.swig","hash":"d45ca53af17d1d83fd27f8ed0917a72f0060e1a9","modified":1562066493405},{"_id":"themes/hexo-theme-next/layout/_macro/menu/menu-badge.swig","hash":"4eb8e222dc337211efb0d3bbdb5e29af3e6ecdb8","modified":1562066493069},{"_id":"themes/hexo-theme-next/layout/_macro/menu/menu-item.swig","hash":"25aea3d764b952f3f6d28ab86d7212d138e892df","modified":1562066493072},{"_id":"themes/hexo-theme-next/source/lib/jquery/index.js","hash":"b15f7cfa79519756dff1ad22553fd0ed09024343","modified":1562066495417},{"_id":"source/images/jus/FutureTask1.png","hash":"5a151945e105d36ffc991ee32beed61bf882807b","modified":1562066492737},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1562066495349},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1562066495342},{"_id":"themes/hexo-theme-next/source/css/_common/outline/outline.styl","hash":"1a4ac0d119f2126ef8951897338706edce112235","modified":1562066494510},{"_id":"themes/hexo-theme-next/source/css/_common/components/back-to-top-sidebar.styl","hash":"5c0ca7f801859cff254d2f5b7d1a70d66ff61a8d","modified":1562066494239},{"_id":"themes/hexo-theme-next/source/css/_common/components/back-to-top.styl","hash":"463817cbbd804ce134cb3e7e721431cb0e1616f2","modified":1562066494244},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1562066495356},{"_id":"themes/hexo-theme-next/source/css/_common/components/buttons.styl","hash":"9fd526db0527c71243f05e18086f937dc67b1c3e","modified":1562066494248},{"_id":"themes/hexo-theme-next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1562066494251},{"_id":"themes/hexo-theme-next/source/css/_common/components/components.styl","hash":"997058180065d986e05df72992cc2cbfd7febd7e","modified":1562066494254},{"_id":"themes/hexo-theme-next/source/css/_common/components/rainbow.styl","hash":"cfa64bd8ee2ff9f943673e339d69341e76fbf031","modified":1562066494387},{"_id":"themes/hexo-theme-next/source/css/_common/components/scrollbar.styl","hash":"afdd21533db18d846e1a2663b1199761b1bd2c1e","modified":1562066494390},{"_id":"themes/hexo-theme-next/source/css/_common/components/pagination.styl","hash":"a4c6ee546a94fd69e5b7a1e4c054ab8cacb73d2a","modified":1562066494323},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/base.styl","hash":"40144394fdfe05d400f39f6763f66f75479a2e34","modified":1562066494514},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/mobile.styl","hash":"9c6194177533619a6f6685dc7e890dcbec456241","modified":1562066494523},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/normalize.styl","hash":"fec36a14080104b5862e9f021eab117d87c5f7c5","modified":1562066494529},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/scaffolding.styl","hash":"a17e2b871a335f290afb392a08f94fd35f59c715","modified":1562066494535},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/tables.styl","hash":"107f42aa590ec4ba0765a0bc5d735f0f09edc0ff","modified":1562066494538},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_base.styl","hash":"d0e9065b0dbbc01811259f0597d1790268b4881b","modified":1562066494571},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1562066494577},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_header.styl","hash":"8da8416213127595dfc4d2b358639194647e7bd3","modified":1562066494574},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_search.styl","hash":"6aee54cd5a20181e18596565356bd54c66e33823","modified":1562066494590},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"06d9d00257abd28414ec0b746f866bf9911cf5ec","modified":1562066494584},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/index.styl","hash":"25f05ed8da68d034dce7f06e0f20f6cd55841070","modified":1562066494594},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_menu.styl","hash":"40f266e24af4dedc9497056ab18ebcfda38dd47d","modified":1562066494580},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_brand.styl","hash":"b9619c9827f969ca2e2f5878552362a7b858918f","modified":1562066494633},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_layout.styl","hash":"e73d6da74c5755442e831d8fd7d922c5b32bd892","modified":1562066494637},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_menu.styl","hash":"0b3001909f3446843b226030524ea8498d4d8997","modified":1562066494641},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"0d6f0df798449b710e1e5dbd43d470089b2a3c95","modified":1562066494650},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_sidebar.styl","hash":"5b5e0a02a7bf63de9efcd33a4e482939cce5822d","modified":1562066494645},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/index.styl","hash":"adb7379f3b9001840eb38b260434e89365771a81","modified":1562066494654},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_logo.styl","hash":"157e6915dcf5990566e463acffa71043b2651c07","modified":1562066494613},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_layout.styl","hash":"04706657af638f2746ae59520e6fc78577c7682c","modified":1562066494608},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_menu.styl","hash":"234b44cfd03f9c9e3e179ff5fd698ac876341913","modified":1562066494617},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/index.styl","hash":"5dbc0d0c897e46760e5dbee416530d485c747bba","modified":1562066494624},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/helpers.styl","hash":"35c6fd7eab3779bd9e38b7ba8825ab0c67a1be7a","modified":1562066494518},{"_id":"themes/hexo-theme-next/source/css/_schemes/Gemini/index.styl","hash":"a609ff811f2b2764f5470236fe2fb1f3aa6ccba5","modified":1562066494565},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_search.styl","hash":"6aee54cd5a20181e18596565356bd54c66e33823","modified":1562066494621},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1562066495374},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1562066495370},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/github-banner.styl","hash":"a8f4d4b86acaa34c99111b2dde5d0779cc7e0de6","modified":1562066494262},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1562066494269},{"_id":"themes/hexo-theme-next/source/css/_common/components/footer/footer.styl","hash":"2df409df04fdb52d7234876a9f6e502edd4e3929","modified":1562066494258},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/header.styl","hash":"c9cfb4b99e1ec8ec9cf075cb761b8f7fa5fe63fd","modified":1562066494265},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/site-meta.styl","hash":"b8647d6140141b0a160607f6353e4d4594cca92e","modified":1562066494277},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/archive.styl","hash":"e5a5f8747fdf2ca960e4e73c081b8952afd62224","modified":1562066494297},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1562066494305},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/site-nav.styl","hash":"3a0efe849587b34f20d4e260028dc799215b0bb3","modified":1562066494280},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/menu.styl","hash":"33200f60bd6a8bbfc66dd49a239bcc75c2f564c1","modified":1562066494274},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/breadcrumb.styl","hash":"fa1cea6fcc3f552d57cc7d28380a304859139bf6","modified":1562066494302},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/pages.styl","hash":"9a8fb61bd2d184de9d206e62ba8961d1845c5669","modified":1562066494309},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/schedule.styl","hash":"c27527cdeb9e3a9f447f7238f442a5dc33fde4e6","modified":1562066494316},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/diff.styl","hash":"024e8ff40ca881c6fbf45712897e22f58a3811ab","modified":1562066494284},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/highlight.styl","hash":"9c1a082e6c1f96187a099c3f4cb5424c0c9fd06e","modified":1562066494288},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/tag-cloud.styl","hash":"c97c819a65f6967485184399397601e5133deda6","modified":1562066494320},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-collapse.styl","hash":"f3b0d259e991ac86454ae5eac6bc94dc8691d8c9","modified":1562066494330},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-copyright.styl","hash":"fc94dd09b4245143b452d6cf2fc4c12134d99d6d","modified":1562066494334},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-eof.styl","hash":"a73346f999b31355075cd58637946a8950cf6f7e","modified":1562066494338},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-expand.styl","hash":"f14cefc99309934d4103a3aa785e1258d858813f","modified":1562066494341},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-gallery.styl","hash":"b6a241626783d2ac115d683fd59ec283af68e5bb","modified":1562066494345},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-nav.styl","hash":"13d365ee626c01f17ec664b3f54f51d8b9ee7cf4","modified":1562066494352},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-meta.styl","hash":"d77f85d3af2d7090d84b28ab01c6a49f92eec647","modified":1562066494349},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1562066494312},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-reading_progress.styl","hash":"4aad8e36178faaa71a767af0084d578df4c09f73","modified":1562066494356},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-rtl.styl","hash":"b2495ae5e04dcca610aacadc47881d9e716cd440","modified":1562066494364},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1562066494368},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-button.styl","hash":"62fbbd32cf5a99ae550c45c763a2c4813a138d01","modified":1562066494327},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-reward.styl","hash":"ccd0b1309acff0c676fdcc848a8ae2d05f0369ab","modified":1562066494360},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-type.styl","hash":"c8009fd9598a661b7d23158b5121b6ac266939e9","modified":1562066494376},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/copy-code.styl","hash":"d9c244b1c3a09a7fccd3c3f732e6fb112a8cd565","modified":1562066494476},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-widgets.styl","hash":"981795aad232c8bd3f52a0ed8720db696d18a234","modified":1562066494379},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/algolia-search.styl","hash":"4305813408a1cd6aba764a7769b94b081d383d4f","modified":1562066494471},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/gitalk.styl","hash":"a01484e350ad5fc9b1fdfbfafb2ddd9687ad4d20","modified":1562066494479},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/gitment.styl","hash":"2fbe52f955da41c7a14eb09918bf86a252e4504f","modified":1562066494482},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/han.styl","hash":"2a1008f1044b450b806adc166754ba9513e68375","modified":1562066494485},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/localsearch.styl","hash":"ed8a12982c0497eeb9d7642781abeb801428f83d","modified":1562066494489},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/math.styl","hash":"6880467b4f6d7b057fb8291aa10966429a0a3bff","modified":1562066494495},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post.styl","hash":"615fca7dff197a2ca3df674cf963ce70b8525985","modified":1562066494382},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-title.styl","hash":"539fc0880b2e035e8316d5d4b423703195c1b7ba","modified":1562066494373},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/related-posts.styl","hash":"9801977a23268e36c5deefd270423f6f1a0c3bb2","modified":1562066494502},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/third-party.styl","hash":"7cf42f96ba6b249c75e00dad251ebacf7de61e6c","modified":1562066494505},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/needsharebutton.styl","hash":"35dc9f3990fadff3ea038d4e8ac75923219886ed","modified":1562066494498},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/full-image.styl","hash":"2d58ad90f148e845bc7023751a7a13260600f8d6","modified":1562066494441},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/blockquote-center.styl","hash":"fde59300ec38868676ff5ed495b9dc9b02d07ffc","modified":1562066494436},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1562066494444},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/pdf.styl","hash":"3baeeb51cfe123e99235ee1816d0e1f6a97c7852","modified":1562066494458},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/label.styl","hash":"b43421291bf85b589e8d0ec853e238d36ab80631","modified":1562066494448},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/note.styl","hash":"020fac447d7a17c03e2802f0f724ae0738088354","modified":1562066494451},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"a5484d8436b2b7862faf6e7309a9e7b88cdd0027","modified":1562066494395},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/tags.styl","hash":"da7a21f5a2f7dcf4c5a4788d7670159ca4132b65","modified":1562066494467},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/tabs.styl","hash":"1df9d36e2b0e9c94e0a959acc136026405ae0d73","modified":1562066494462},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-button.styl","hash":"b36eea093bd4b32056b5de6f370ff57e50b25a49","modified":1562066494408},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"e58bb8b7127aa21e8260493a425ec00fcb25d338","modified":1562066494412},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"03a4e75e963e3e7cc393d588b1495a88d52e0e40","modified":1562066494404},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"0eadef0381f696de7f88d7dc5f0ddc3cd5d309b3","modified":1562066494422},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"7e2ba73073daaea0a18c3d67ff137dd683af7011","modified":1562066494415},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"9204c79c05d620ecd5d411cdf11e27441b6281dc","modified":1562066494418},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar.styl","hash":"3cb387fa70017f3c24a1a1884461d29deda54585","modified":1562066494426},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/site-state.styl","hash":"ed3a2960ebce7396d1893bb8e08c99c7d9259140","modified":1562066494430},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"ab1776c5dc537beabb0ab81a0f04e08bebad070b","modified":1562066494400},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1562066494292},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1562066494599},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1562066494629},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1562066494604},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1562066495471},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1562066495366},{"_id":"public/CNAME","hash":"8a59d66093d768cd260ee27bca40149cca21e573","modified":1565079483325},{"_id":"public/about/index.html","hash":"ab83d2c7dee522e17d0bca83f5d6374540a54a03","modified":1565079487198},{"_id":"public/tags/index.html","hash":"2471a24bd12990c8c81bfdbff66bdb58c7581775","modified":1565079487199},{"_id":"public/todolist/index.html","hash":"ce1c9af20e821c66c6d2729677a5ae28243823be","modified":1565079487199},{"_id":"public/categories/index.html","hash":"4340be80f9e97f16004257c0e74d75f2a8be194e","modified":1565079487213},{"_id":"public/books/index.html","hash":"9aa5e4130557e52646da6d3ec35c11e6e4ad4b02","modified":1565079487213},{"_id":"public/2019/08/05/Mysql学习笔记之查询优化篇/index.html","hash":"5a22d5683bb8267d538efa1b987b38fd6c449382","modified":1565079487213},{"_id":"public/2019/08/05/Mysql学习笔记之事务/index.html","hash":"0528bc852c7a133451d567cbbf5e3c4583a9eefe","modified":1565079487213},{"_id":"public/2019/08/05/Mysql学习笔记之锁/index.html","hash":"d579633dec03c7f6020838f7fb4ba27a64bb3b97","modified":1565079487213},{"_id":"public/2019/08/05/Mysql学习笔记之索引篇/index.html","hash":"0148ec8d1b5499bef22bddc2ccb548999706926e","modified":1565079487213},{"_id":"public/2019/07/09/Mysql学习笔记之explain用法详解/index.html","hash":"3dd2f28f03b43bf51a7e185f83c33ad790f2e3eb","modified":1565079487214},{"_id":"public/2019/07/01/java多线程之FutureTask-Future和Callable/index.html","hash":"04aeb5bdfd8999b6b8c0a922f836fbdf65d45c04","modified":1565079487214},{"_id":"public/2019/07/09/JSON使用经验之java对象与json字符串的互转问题/index.html","hash":"21492241a0540c00bf137c64949d5808157f7d98","modified":1565079487214},{"_id":"public/2019/06/26/java多线程之synchronized-volatle和final关键字/index.html","hash":"99480a388e81b23485625d1f7159dbdb9a34d9ac","modified":1565079487214},{"_id":"public/2019/06/22/java多线程之并发工具类/index.html","hash":"7c131656b9cbf5e412bfe803e7e6ffc45dfed18c","modified":1565079487214},{"_id":"public/categories/json/index.html","hash":"dd1b166a7e6e3c9c753a2333c5355cdd3c7a482d","modified":1565079487220},{"_id":"public/categories/mysql/index.html","hash":"6d282a5462361081ccccebb8f57806f4c2df0fe2","modified":1565079487220},{"_id":"public/categories/markdown/index.html","hash":"29562241d53687d7398fc987863315b34fac8d5b","modified":1565079487221},{"_id":"public/categories/spring框架/index.html","hash":"096bf83e201ecf3f1a4c19baba13bab513138578","modified":1565079487221},{"_id":"public/categories/代码之外/index.html","hash":"7bb6e2a840f44e2d2655e182a3c74312dbf1440e","modified":1565079487221},{"_id":"public/categories/设计模式/index.html","hash":"a1d96af47e43097770cc1c050d9846fa920fe2d3","modified":1565079487221},{"_id":"public/categories/git/index.html","hash":"f3ca52e9fd9fef15c9026423b7490aa0fb73a26f","modified":1565079487221},{"_id":"public/tags/json/index.html","hash":"20d5f776c9eebed6c56001044c38ae0e000bfcc8","modified":1565079487221},{"_id":"public/tags/数据库/index.html","hash":"0ca804209bfd3ce53f9c07e41b1aa059360021ad","modified":1565079487221},{"_id":"public/tags/工具/index.html","hash":"e3989da8d0dc9039cb218f0aae4d08162969588b","modified":1565079487221},{"_id":"public/tags/spring/index.html","hash":"116ee25210ecb8e90a12e3dab8d4124a8e64a481","modified":1565079487221},{"_id":"public/tags/随笔/index.html","hash":"01dafad6e858bba1c80f83c74faec01321895d26","modified":1565079487221},{"_id":"public/2019/06/19/记一次线上事故总结/index.html","hash":"343fcf404853f36f02fc6de2c9ce64fc32270936","modified":1565079487221},{"_id":"public/2019/06/18/markdown高阶语法/index.html","hash":"1cf769a1443a47bc446789d7d134002bf704f999","modified":1565079487221},{"_id":"public/2019/06/18/markdown简单语法/index.html","hash":"0ac5fd786fa8403f1e922ea5c9a40335fe05bf45","modified":1565079487221},{"_id":"public/2019/06/18/git常用命令/index.html","hash":"ec40ee15f4fe78f00e8f00a4f4339e259d32e95c","modified":1565079487221},{"_id":"public/2019/06/18/java多线程之常见面试问题/index.html","hash":"c544fb78d3abf490e0b3d146733e3cff6963a16a","modified":1565079487221},{"_id":"public/2019/06/18/spring常用接口之InitializingBean/index.html","hash":"8d0b1b83de4ac2dbf6350106edd018305bb650d0","modified":1565079487221},{"_id":"public/2019/06/18/spring常用接口之BeanpostProccesser/index.html","hash":"c2e16cff43e8e7efbdac93cfc565223fe28d81b5","modified":1565079487222},{"_id":"public/2019/06/18/java多线程之ThreadPoolExcutor/index.html","hash":"f14c00bd691fcdc8385397065baae6844d065f55","modified":1565079487222},{"_id":"public/2019/06/18/关于提升工作效率的一点思考/index.html","hash":"4b8bbbb3944f5f6edad503eccd4dadab6693aa8e","modified":1565079487222},{"_id":"public/2019/06/18/java8之Stream-Api/index.html","hash":"60919bdb1c80566bdb44fc470b7284579b3cd399","modified":1565079487222},{"_id":"public/2019/06/18/Iterator循环删除list中元素/index.html","hash":"112b3f3d805bf5ab8b592494a03e8e91b0131e20","modified":1565079487222},{"_id":"public/2019/06/18/设计模式之策略模式/index.html","hash":"4c209be3bd1362bbaff51a240e057bf1b4cdf96b","modified":1565079487222},{"_id":"public/2019/06/18/java8之lamda表达式/index.html","hash":"4c35beec0cd698de9b8649976e971d56f6564704","modified":1565079487222},{"_id":"public/2019/06/18/interceptor-配合Threadlocal全局处理请求基本信息/index.html","hash":"593dd4dd69be02cfffd5746a6deb304618ba1727","modified":1565079487222},{"_id":"public/archives/index.html","hash":"abc7bff3ed318382e10ccf97396c7bcb074ddbbc","modified":1565079487222},{"_id":"public/archives/page/3/index.html","hash":"d9fa42aee017ddc999ecd278a027de391dcfbcaa","modified":1565079487222},{"_id":"public/archives/2019/index.html","hash":"1594f7776caa0339e99c72b50d6de33b39e36596","modified":1565079487222},{"_id":"public/archives/2019/page/2/index.html","hash":"17976acfa6c810f7641bcb632ea47c675a83ab37","modified":1565079487222},{"_id":"public/archives/2019/page/3/index.html","hash":"90cd615ced675b94efb45e656e34a31107db84bc","modified":1565079487222},{"_id":"public/archives/2019/06/index.html","hash":"3ebbe0fddc07d802c720ee465c852d36a0a95cb0","modified":1565079487222},{"_id":"public/archives/2019/06/page/2/index.html","hash":"cd654483c9aa1061a92614e83f53f1929fa0ba35","modified":1565079487222},{"_id":"public/archives/2019/08/index.html","hash":"4f90295714f3c903048b43051824fc0d30b73928","modified":1565079487223},{"_id":"public/archives/2019/07/index.html","hash":"422f677e6773cf61760e352e4feccfde10b2a0a6","modified":1565079487223},{"_id":"public/categories/java基础/index.html","hash":"b07dc961e448bd5b1b3a1fde4b53ccb32edf6e8d","modified":1565079487223},{"_id":"public/categories/java多线程/index.html","hash":"e305b457df1932a5ffd8043e6ae89148d27a7911","modified":1565079487223},{"_id":"public/index.html","hash":"a33fdecfa540cd26da987f112fe90ae4589658c3","modified":1565079487223},{"_id":"public/page/2/index.html","hash":"2214cc3d1ea0b942dc41b31d978a807adb19489e","modified":1565079487223},{"_id":"public/page/3/index.html","hash":"9693da1e2ed14cc987e3f42356093ca6a9dfb6a3","modified":1565079487223},{"_id":"public/tags/java/index.html","hash":"92de193bf48c63b3a91fddd87d7cdeb378ceb6c4","modified":1565079487223},{"_id":"public/archives/page/2/index.html","hash":"fbbf135249a8cc6f91ffff591318c87d5f62b430","modified":1565079487223},{"_id":"public/2019/06/26/java多线程之内存模型/index.html","hash":"a7bb989fded66ed4860e2c474508b6854c80843a","modified":1565079487223},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1565079487227},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1565079487227},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1565079487227},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1565079487228},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1565079487228},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1565079487228},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1565079487228},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1565079487228},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1565079487228},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1565079487228},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1565079487228},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1565079487228},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1565079487228},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1565079487228},{"_id":"public/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1565079487228},{"_id":"public/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1565079487228},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1565079487228},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1565079487229},{"_id":"public/images/searchicon.png","hash":"025d64ba0160a3a2257dd2b3032b5f7c9dd9b82b","modified":1565079487229},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1565079487229},{"_id":"public/js/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1565079488009},{"_id":"public/js/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1565079488009},{"_id":"public/js/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1565079488010},{"_id":"public/js/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1565079488010},{"_id":"public/js/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1565079488010},{"_id":"public/js/next-boot.js","hash":"e0615efab5f81ba0fd39c0527eac31144deac7ce","modified":1565079488010},{"_id":"public/images/jus/JMM1.png","hash":"0c00e29ed049dd09d5499e91c4b34cd3f3498c82","modified":1565079488011},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1565079488011},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1565079488011},{"_id":"public/js/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1565079488011},{"_id":"public/js/schemes/muse.js","hash":"e9bfa6b343b67625f58757efce46ccdaac8f308c","modified":1565079488011},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1565079488012},{"_id":"public/js/schemes/pisces.js","hash":"9eb63cba0327d3d11b6cbfcbe40b88e97a8378a3","modified":1565079488012},{"_id":"public/js/js.cookie.js","hash":"e0afce539f1fb81d59e3c6f0a68d736e2fb45d93","modified":1565079488012},{"_id":"public/css/main.css","hash":"2a3147d6264af5888b154350fa10f812159bfacc","modified":1565079488012},{"_id":"public/js/motion.js","hash":"a16bc0b701646bf6653484675f4d5dc0f892d184","modified":1565079488023},{"_id":"public/js/utils.js","hash":"81913c5f75d0949443833cf4269ad63bd7f9be6f","modified":1565079488023},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1565079488023},{"_id":"public/images/avatar.jpg","hash":"07a368a88e43961fa2bec480de425d88db74538e","modified":1565079488023},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1565079488369},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1565079488383},{"_id":"public/images/jus/FutureTask1.png","hash":"5a151945e105d36ffc991ee32beed61bf882807b","modified":1565079488383},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1565079488439},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1565079488439},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1565079488540},{"_id":"public/lib/jquery/index.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1565079488562},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1565079488598}],"Category":[{"name":"java基础","_id":"cjyzjwwlk0004w4j9qw9m5r0x"},{"name":"json","_id":"cjyzjwwlu000aw4j9sd5s6fnr"},{"name":"mysql","_id":"cjyzjwwm0000gw4j91x483urt"},{"name":"java多线程","_id":"cjyzjwwm7000rw4j9p9gf8rme"},{"name":"markdown","_id":"cjyzjwwmp001dw4j97iazxmia"},{"name":"spring框架","_id":"cjyzjwwmx001ow4j9lwo8di13"},{"name":"代码之外","_id":"cjyzjwwmz001tw4j9hrrk1b5f"},{"name":"设计模式","_id":"cjyzjwwn50022w4j92gun5sxx"},{"name":"git","_id":"cjyzjwwnm002aw4j9jbqk6gl8"}],"Data":[],"Page":[{"title":"分类","date":"2019-06-18T09:17:25.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2019-06-18 17:17:25\ntype: \"categories\"\n---\n","updated":"2019-07-02T11:21:32.725Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjyzjwwle0001w4j9f555r1vs","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"about","date":"2019-06-18T09:20:44.000Z","type":"about","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2019-06-18 17:20:44\ntype: about\n---\n","updated":"2019-07-02T11:21:32.716Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjyzjwwlj0003w4j9n17q2xl8","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2019-06-18T09:16:59.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2019-06-18 17:16:59\ntype: \"tags\"\n---\n","updated":"2019-07-02T11:21:32.747Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjyzjwwln0006w4j9bvy1gwf3","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"计划待办","date":"2019-06-18T14:20:23.000Z","_content":"\n- [ ] **java多线程学习**\n    - [ ] ThreadPoolExcutor原理及实例代码 (第一周6月17-6月23)\n    - [X] java工具类CountDownLatch,CyclicBarrier,Semaphore,Exchanger（第二周6月24-6月30）\n    - [ ] HashMap与concurrentHashmap实现原理比较\n    - [ ] FutureTask简介\n    \n","source":"todolist/index.md","raw":"---\ntitle: 计划待办\ndate: 2019-06-18 22:20:23\n---\n\n- [ ] **java多线程学习**\n    - [ ] ThreadPoolExcutor原理及实例代码 (第一周6月17-6月23)\n    - [X] java工具类CountDownLatch,CyclicBarrier,Semaphore,Exchanger（第二周6月24-6月30）\n    - [ ] HashMap与concurrentHashmap实现原理比较\n    - [ ] FutureTask简介\n    \n","updated":"2019-07-09T08:17:08.814Z","path":"todolist/index.html","comments":1,"layout":"page","_id":"cjyzjwwnj0027w4j9cyisifyl","content":"<ul>\n<li><input disabled type=\"checkbox\"> <strong>java多线程学习</strong><ul>\n<li><input disabled type=\"checkbox\"> ThreadPoolExcutor原理及实例代码 (第一周6月17-6月23)</li>\n<li><input checked disabled type=\"checkbox\"> java工具类CountDownLatch,CyclicBarrier,Semaphore,Exchanger（第二周6月24-6月30）</li>\n<li><input disabled type=\"checkbox\"> HashMap与concurrentHashmap实现原理比较</li>\n<li><input disabled type=\"checkbox\"> FutureTask简介</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><input disabled type=\"checkbox\"> <strong>java多线程学习</strong><ul>\n<li><input disabled type=\"checkbox\"> ThreadPoolExcutor原理及实例代码 (第一周6月17-6月23)</li>\n<li><input checked disabled type=\"checkbox\"> java工具类CountDownLatch,CyclicBarrier,Semaphore,Exchanger（第二周6月24-6月30）</li>\n<li><input disabled type=\"checkbox\"> HashMap与concurrentHashmap实现原理比较</li>\n<li><input disabled type=\"checkbox\"> FutureTask简介</li>\n</ul>\n</li>\n</ul>\n"},{"title":"备忘录","date":"2019-06-18T14:22:20.000Z","_content":"\n### mysql\n- [mysql官方文档](https://dev.mysql.com/doc/refman/5.7/en/explain-output.html)\n\n\n### springboot\n- [springboot官方中文文档](https://docshome.gitbooks.io/springboot/content/)\n- [springboot官方英文文档](https://spring.io/projects/spring-boot)\n- [spring事务](https://www.ibm.com/developerworks/cn/java/j-master-spring-transactional-use/index.html)\n\n\n### hexo\n- [hexo官方文档](https://hexo.io/zh-cn/docs/writing)\n- [hexo-next主题官方文档](http://theme-next.iissnan.com/getting-started.html)\n\n\n### idea \n- [idea破解](https://blog.csdn.net/qq_40914991/article/details/85543575)\n\n### mockito\n- [Mockito](https://static.javadoc.io/org.mockito/mockito-core/3.0.0/org/mockito/Mockito.html)\n\n\n### 日常采坑\n- [spring aop](https://www.cnblogs.com/hongmoshui/p/10938559.html)\n","source":"books/index.md","raw":"---\ntitle: 备忘录\ndate: 2019-06-18 22:22:20\n---\n\n### mysql\n- [mysql官方文档](https://dev.mysql.com/doc/refman/5.7/en/explain-output.html)\n\n\n### springboot\n- [springboot官方中文文档](https://docshome.gitbooks.io/springboot/content/)\n- [springboot官方英文文档](https://spring.io/projects/spring-boot)\n- [spring事务](https://www.ibm.com/developerworks/cn/java/j-master-spring-transactional-use/index.html)\n\n\n### hexo\n- [hexo官方文档](https://hexo.io/zh-cn/docs/writing)\n- [hexo-next主题官方文档](http://theme-next.iissnan.com/getting-started.html)\n\n\n### idea \n- [idea破解](https://blog.csdn.net/qq_40914991/article/details/85543575)\n\n### mockito\n- [Mockito](https://static.javadoc.io/org.mockito/mockito-core/3.0.0/org/mockito/Mockito.html)\n\n\n### 日常采坑\n- [spring aop](https://www.cnblogs.com/hongmoshui/p/10938559.html)\n","updated":"2019-08-06T08:17:53.383Z","path":"books/index.html","comments":1,"layout":"page","_id":"cjyzjwwoh002ew4j9bcd5o0ms","content":"<h3 id=\"mysql\"><a href=\"#mysql\" class=\"headerlink\" title=\"mysql\"></a>mysql</h3><ul>\n<li><a href=\"https://dev.mysql.com/doc/refman/5.7/en/explain-output.html\" target=\"_blank\" rel=\"noopener\">mysql官方文档</a></li>\n</ul>\n<h3 id=\"springboot\"><a href=\"#springboot\" class=\"headerlink\" title=\"springboot\"></a>springboot</h3><ul>\n<li><a href=\"https://docshome.gitbooks.io/springboot/content/\" target=\"_blank\" rel=\"noopener\">springboot官方中文文档</a></li>\n<li><a href=\"https://spring.io/projects/spring-boot\" target=\"_blank\" rel=\"noopener\">springboot官方英文文档</a></li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/java/j-master-spring-transactional-use/index.html\" target=\"_blank\" rel=\"noopener\">spring事务</a></li>\n</ul>\n<h3 id=\"hexo\"><a href=\"#hexo\" class=\"headerlink\" title=\"hexo\"></a>hexo</h3><ul>\n<li><a href=\"https://hexo.io/zh-cn/docs/writing\" target=\"_blank\" rel=\"noopener\">hexo官方文档</a></li>\n<li><a href=\"http://theme-next.iissnan.com/getting-started.html\" target=\"_blank\" rel=\"noopener\">hexo-next主题官方文档</a></li>\n</ul>\n<h3 id=\"idea\"><a href=\"#idea\" class=\"headerlink\" title=\"idea\"></a>idea</h3><ul>\n<li><a href=\"https://blog.csdn.net/qq_40914991/article/details/85543575\" target=\"_blank\" rel=\"noopener\">idea破解</a></li>\n</ul>\n<h3 id=\"mockito\"><a href=\"#mockito\" class=\"headerlink\" title=\"mockito\"></a>mockito</h3><ul>\n<li><a href=\"https://static.javadoc.io/org.mockito/mockito-core/3.0.0/org/mockito/Mockito.html\" target=\"_blank\" rel=\"noopener\">Mockito</a></li>\n</ul>\n<h3 id=\"日常采坑\"><a href=\"#日常采坑\" class=\"headerlink\" title=\"日常采坑\"></a>日常采坑</h3><ul>\n<li><a href=\"https://www.cnblogs.com/hongmoshui/p/10938559.html\" target=\"_blank\" rel=\"noopener\">spring aop</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"mysql\"><a href=\"#mysql\" class=\"headerlink\" title=\"mysql\"></a>mysql</h3><ul>\n<li><a href=\"https://dev.mysql.com/doc/refman/5.7/en/explain-output.html\" target=\"_blank\" rel=\"noopener\">mysql官方文档</a></li>\n</ul>\n<h3 id=\"springboot\"><a href=\"#springboot\" class=\"headerlink\" title=\"springboot\"></a>springboot</h3><ul>\n<li><a href=\"https://docshome.gitbooks.io/springboot/content/\" target=\"_blank\" rel=\"noopener\">springboot官方中文文档</a></li>\n<li><a href=\"https://spring.io/projects/spring-boot\" target=\"_blank\" rel=\"noopener\">springboot官方英文文档</a></li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/java/j-master-spring-transactional-use/index.html\" target=\"_blank\" rel=\"noopener\">spring事务</a></li>\n</ul>\n<h3 id=\"hexo\"><a href=\"#hexo\" class=\"headerlink\" title=\"hexo\"></a>hexo</h3><ul>\n<li><a href=\"https://hexo.io/zh-cn/docs/writing\" target=\"_blank\" rel=\"noopener\">hexo官方文档</a></li>\n<li><a href=\"http://theme-next.iissnan.com/getting-started.html\" target=\"_blank\" rel=\"noopener\">hexo-next主题官方文档</a></li>\n</ul>\n<h3 id=\"idea\"><a href=\"#idea\" class=\"headerlink\" title=\"idea\"></a>idea</h3><ul>\n<li><a href=\"https://blog.csdn.net/qq_40914991/article/details/85543575\" target=\"_blank\" rel=\"noopener\">idea破解</a></li>\n</ul>\n<h3 id=\"mockito\"><a href=\"#mockito\" class=\"headerlink\" title=\"mockito\"></a>mockito</h3><ul>\n<li><a href=\"https://static.javadoc.io/org.mockito/mockito-core/3.0.0/org/mockito/Mockito.html\" target=\"_blank\" rel=\"noopener\">Mockito</a></li>\n</ul>\n<h3 id=\"日常采坑\"><a href=\"#日常采坑\" class=\"headerlink\" title=\"日常采坑\"></a>日常采坑</h3><ul>\n<li><a href=\"https://www.cnblogs.com/hongmoshui/p/10938559.html\" target=\"_blank\" rel=\"noopener\">spring aop</a></li>\n</ul>\n"}],"Post":[{"title":"Iterator循环删除list中元素","date":"2019-06-18T08:49:39.000Z","_content":"\n### 一、业务场景\n当我们需要剔除list中的某些元素时，通常的做法就是循环遍历list,然后符合条件时remove掉该元素。\n### 二、实现逻辑\n    for (Iterator<String> iterator = list.iterator(); iterator.hasNext(); ) {\n            String str=iterator.next();\n            if (Objects.equals(\"one\",str)){\n                iterator.remove();\n            }\n        }\n    // or\n    Iterator<String> iterator = list.iterator();\n        while(iterator.hasNext()){\n            String str=iterator.next();\n            if (Objects.equals(\"one\",str)){\n                iterator.remove();\n            }\n\n\n### 三、代码分析\n使用iterator遍历list同时删除元素，不会因为删除元素改变size而造成异常","source":"_posts/Iterator循环删除list中元素.md","raw":"---\ntitle: Iterator循环删除list中元素\ndate: 2019-06-18 16:49:39\ncategories: java基础\ntags:\n---\n\n### 一、业务场景\n当我们需要剔除list中的某些元素时，通常的做法就是循环遍历list,然后符合条件时remove掉该元素。\n### 二、实现逻辑\n    for (Iterator<String> iterator = list.iterator(); iterator.hasNext(); ) {\n            String str=iterator.next();\n            if (Objects.equals(\"one\",str)){\n                iterator.remove();\n            }\n        }\n    // or\n    Iterator<String> iterator = list.iterator();\n        while(iterator.hasNext()){\n            String str=iterator.next();\n            if (Objects.equals(\"one\",str)){\n                iterator.remove();\n            }\n\n\n### 三、代码分析\n使用iterator遍历list同时删除元素，不会因为删除元素改变size而造成异常","slug":"Iterator循环删除list中元素","published":1,"updated":"2019-07-02T11:21:32.657Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzjwwl70000w4j9ixp0xpov","content":"<h3 id=\"一、业务场景\"><a href=\"#一、业务场景\" class=\"headerlink\" title=\"一、业务场景\"></a>一、业务场景</h3><p>当我们需要剔除list中的某些元素时，通常的做法就是循环遍历list,然后符合条件时remove掉该元素。</p>\n<h3 id=\"二、实现逻辑\"><a href=\"#二、实现逻辑\" class=\"headerlink\" title=\"二、实现逻辑\"></a>二、实现逻辑</h3><pre><code>for (Iterator&lt;String&gt; iterator = list.iterator(); iterator.hasNext(); ) {\n        String str=iterator.next();\n        if (Objects.equals(&quot;one&quot;,str)){\n            iterator.remove();\n        }\n    }\n// or\nIterator&lt;String&gt; iterator = list.iterator();\n    while(iterator.hasNext()){\n        String str=iterator.next();\n        if (Objects.equals(&quot;one&quot;,str)){\n            iterator.remove();\n        }</code></pre><h3 id=\"三、代码分析\"><a href=\"#三、代码分析\" class=\"headerlink\" title=\"三、代码分析\"></a>三、代码分析</h3><p>使用iterator遍历list同时删除元素，不会因为删除元素改变size而造成异常</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、业务场景\"><a href=\"#一、业务场景\" class=\"headerlink\" title=\"一、业务场景\"></a>一、业务场景</h3><p>当我们需要剔除list中的某些元素时，通常的做法就是循环遍历list,然后符合条件时remove掉该元素。</p>\n<h3 id=\"二、实现逻辑\"><a href=\"#二、实现逻辑\" class=\"headerlink\" title=\"二、实现逻辑\"></a>二、实现逻辑</h3><pre><code>for (Iterator&lt;String&gt; iterator = list.iterator(); iterator.hasNext(); ) {\n        String str=iterator.next();\n        if (Objects.equals(&quot;one&quot;,str)){\n            iterator.remove();\n        }\n    }\n// or\nIterator&lt;String&gt; iterator = list.iterator();\n    while(iterator.hasNext()){\n        String str=iterator.next();\n        if (Objects.equals(&quot;one&quot;,str)){\n            iterator.remove();\n        }</code></pre><h3 id=\"三、代码分析\"><a href=\"#三、代码分析\" class=\"headerlink\" title=\"三、代码分析\"></a>三、代码分析</h3><p>使用iterator遍历list同时删除元素，不会因为删除元素改变size而造成异常</p>\n"},{"title":"JSON使用经验之java对象与json字符串的互转问题","date":"2019-07-09T08:26:49.000Z","_content":"\n## java对象转json字符串\n\n\n### fastJson实现方法\n```\nSerializeConfig config = new SerializeConfig();\n        config.propertyNamingStrategy = PropertyNamingStrategy.SnakeCase;\n        String json = JSON.toJSONString(app, config);\n        System.out.println(\"fastJson---\" + json);\n\nconsole result:\n        fastJson---{\"app_id\":431431,\"image_url\":\"http://www.image.com/xxx.png\",\"link_url\":\"http://www.baidu.com\",\"name\":\"美团外卖\"}\n```\n### Jackson实现方法\n```\nObjectMapper mapper = new ObjectMapper();\n        mapper.setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);\n        String json = mapper.writeValueAsString(app);\n        System.out.println(\"jackson--\" + json);\n\nconsole result:\n      jackson--{\"app_id\":431431,\"name\":\"美团外卖\",\"image_url\":\"http://www.image.com/xxx.png\",\"link_url\":\"http://www.baidu.com\"}\n```\n### Gson实现方法\n```\n GsonBuilder gsonBuilder = new GsonBuilder();\n        gsonBuilder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES);\n        Gson gson = gsonBuilder.create();\n\n        String json = gson.toJson(app);\n        System.out.println(\"Gson--\" + json);\n\nconsole result:\n      Gson--{\"app_id\":431431,\"name\":\"美团外卖\",\"image_url\":\"http://www.image.com/xxx.png\",\"link_url\":\"http://www.baidu.com\"}\n```\n\n## json字符串转java对象\n\n\n### fastJson实现方法\n```\n App app1 = JSON.parseObject(jsonStr, App.class);\n```\n### Jackson实现方法\n```\n ObjectMapper mapper = new ObjectMapper();\n        mapper.setPropertyNamingStrategy(PropertyNamingStrategy.LOWER_CAMEL_CASE);\n        App app = mapper.readValue(jsonStr, App.class);\n```\n### Gson实现方法\n```\n        Gson gson = new Gson();\n        Person person = gson.fromJson(json, Person.class)\n```\n\n","source":"_posts/JSON使用经验之java对象与json字符串的互转问题.md","raw":"---\ntitle: JSON使用经验之java对象与json字符串的互转问题\ndate: 2019-07-09 16:26:49\ncategories: json\ntags: json\n---\n\n## java对象转json字符串\n\n\n### fastJson实现方法\n```\nSerializeConfig config = new SerializeConfig();\n        config.propertyNamingStrategy = PropertyNamingStrategy.SnakeCase;\n        String json = JSON.toJSONString(app, config);\n        System.out.println(\"fastJson---\" + json);\n\nconsole result:\n        fastJson---{\"app_id\":431431,\"image_url\":\"http://www.image.com/xxx.png\",\"link_url\":\"http://www.baidu.com\",\"name\":\"美团外卖\"}\n```\n### Jackson实现方法\n```\nObjectMapper mapper = new ObjectMapper();\n        mapper.setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);\n        String json = mapper.writeValueAsString(app);\n        System.out.println(\"jackson--\" + json);\n\nconsole result:\n      jackson--{\"app_id\":431431,\"name\":\"美团外卖\",\"image_url\":\"http://www.image.com/xxx.png\",\"link_url\":\"http://www.baidu.com\"}\n```\n### Gson实现方法\n```\n GsonBuilder gsonBuilder = new GsonBuilder();\n        gsonBuilder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES);\n        Gson gson = gsonBuilder.create();\n\n        String json = gson.toJson(app);\n        System.out.println(\"Gson--\" + json);\n\nconsole result:\n      Gson--{\"app_id\":431431,\"name\":\"美团外卖\",\"image_url\":\"http://www.image.com/xxx.png\",\"link_url\":\"http://www.baidu.com\"}\n```\n\n## json字符串转java对象\n\n\n### fastJson实现方法\n```\n App app1 = JSON.parseObject(jsonStr, App.class);\n```\n### Jackson实现方法\n```\n ObjectMapper mapper = new ObjectMapper();\n        mapper.setPropertyNamingStrategy(PropertyNamingStrategy.LOWER_CAMEL_CASE);\n        App app = mapper.readValue(jsonStr, App.class);\n```\n### Gson实现方法\n```\n        Gson gson = new Gson();\n        Person person = gson.fromJson(json, Person.class)\n```\n\n","slug":"JSON使用经验之java对象与json字符串的互转问题","published":1,"updated":"2019-07-09T10:25:26.522Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzjwwlh0002w4j9hkp3zxkz","content":"<h2 id=\"java对象转json字符串\"><a href=\"#java对象转json字符串\" class=\"headerlink\" title=\"java对象转json字符串\"></a>java对象转json字符串</h2><h3 id=\"fastJson实现方法\"><a href=\"#fastJson实现方法\" class=\"headerlink\" title=\"fastJson实现方法\"></a>fastJson实现方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SerializeConfig config = new SerializeConfig();</span><br><span class=\"line\">        config.propertyNamingStrategy = PropertyNamingStrategy.SnakeCase;</span><br><span class=\"line\">        String json = JSON.toJSONString(app, config);</span><br><span class=\"line\">        System.out.println(&quot;fastJson---&quot; + json);</span><br><span class=\"line\"></span><br><span class=\"line\">console result:</span><br><span class=\"line\">        fastJson---&#123;&quot;app_id&quot;:431431,&quot;image_url&quot;:&quot;http://www.image.com/xxx.png&quot;,&quot;link_url&quot;:&quot;http://www.baidu.com&quot;,&quot;name&quot;:&quot;美团外卖&quot;&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Jackson实现方法\"><a href=\"#Jackson实现方法\" class=\"headerlink\" title=\"Jackson实现方法\"></a>Jackson实现方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ObjectMapper mapper = new ObjectMapper();</span><br><span class=\"line\">        mapper.setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);</span><br><span class=\"line\">        String json = mapper.writeValueAsString(app);</span><br><span class=\"line\">        System.out.println(&quot;jackson--&quot; + json);</span><br><span class=\"line\"></span><br><span class=\"line\">console result:</span><br><span class=\"line\">      jackson--&#123;&quot;app_id&quot;:431431,&quot;name&quot;:&quot;美团外卖&quot;,&quot;image_url&quot;:&quot;http://www.image.com/xxx.png&quot;,&quot;link_url&quot;:&quot;http://www.baidu.com&quot;&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Gson实现方法\"><a href=\"#Gson实现方法\" class=\"headerlink\" title=\"Gson实现方法\"></a>Gson实现方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> GsonBuilder gsonBuilder = new GsonBuilder();</span><br><span class=\"line\">        gsonBuilder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES);</span><br><span class=\"line\">        Gson gson = gsonBuilder.create();</span><br><span class=\"line\"></span><br><span class=\"line\">        String json = gson.toJson(app);</span><br><span class=\"line\">        System.out.println(&quot;Gson--&quot; + json);</span><br><span class=\"line\"></span><br><span class=\"line\">console result:</span><br><span class=\"line\">      Gson--&#123;&quot;app_id&quot;:431431,&quot;name&quot;:&quot;美团外卖&quot;,&quot;image_url&quot;:&quot;http://www.image.com/xxx.png&quot;,&quot;link_url&quot;:&quot;http://www.baidu.com&quot;&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"json字符串转java对象\"><a href=\"#json字符串转java对象\" class=\"headerlink\" title=\"json字符串转java对象\"></a>json字符串转java对象</h2><h3 id=\"fastJson实现方法-1\"><a href=\"#fastJson实现方法-1\" class=\"headerlink\" title=\"fastJson实现方法\"></a>fastJson实现方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">App app1 = JSON.parseObject(jsonStr, App.class);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Jackson实现方法-1\"><a href=\"#Jackson实现方法-1\" class=\"headerlink\" title=\"Jackson实现方法\"></a>Jackson实现方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ObjectMapper mapper = new ObjectMapper();</span><br><span class=\"line\">       mapper.setPropertyNamingStrategy(PropertyNamingStrategy.LOWER_CAMEL_CASE);</span><br><span class=\"line\">       App app = mapper.readValue(jsonStr, App.class);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Gson实现方法-1\"><a href=\"#Gson实现方法-1\" class=\"headerlink\" title=\"Gson实现方法\"></a>Gson实现方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Gson gson = new Gson();</span><br><span class=\"line\">Person person = gson.fromJson(json, Person.class)</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"java对象转json字符串\"><a href=\"#java对象转json字符串\" class=\"headerlink\" title=\"java对象转json字符串\"></a>java对象转json字符串</h2><h3 id=\"fastJson实现方法\"><a href=\"#fastJson实现方法\" class=\"headerlink\" title=\"fastJson实现方法\"></a>fastJson实现方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SerializeConfig config = new SerializeConfig();</span><br><span class=\"line\">        config.propertyNamingStrategy = PropertyNamingStrategy.SnakeCase;</span><br><span class=\"line\">        String json = JSON.toJSONString(app, config);</span><br><span class=\"line\">        System.out.println(&quot;fastJson---&quot; + json);</span><br><span class=\"line\"></span><br><span class=\"line\">console result:</span><br><span class=\"line\">        fastJson---&#123;&quot;app_id&quot;:431431,&quot;image_url&quot;:&quot;http://www.image.com/xxx.png&quot;,&quot;link_url&quot;:&quot;http://www.baidu.com&quot;,&quot;name&quot;:&quot;美团外卖&quot;&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Jackson实现方法\"><a href=\"#Jackson实现方法\" class=\"headerlink\" title=\"Jackson实现方法\"></a>Jackson实现方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ObjectMapper mapper = new ObjectMapper();</span><br><span class=\"line\">        mapper.setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE);</span><br><span class=\"line\">        String json = mapper.writeValueAsString(app);</span><br><span class=\"line\">        System.out.println(&quot;jackson--&quot; + json);</span><br><span class=\"line\"></span><br><span class=\"line\">console result:</span><br><span class=\"line\">      jackson--&#123;&quot;app_id&quot;:431431,&quot;name&quot;:&quot;美团外卖&quot;,&quot;image_url&quot;:&quot;http://www.image.com/xxx.png&quot;,&quot;link_url&quot;:&quot;http://www.baidu.com&quot;&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Gson实现方法\"><a href=\"#Gson实现方法\" class=\"headerlink\" title=\"Gson实现方法\"></a>Gson实现方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> GsonBuilder gsonBuilder = new GsonBuilder();</span><br><span class=\"line\">        gsonBuilder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES);</span><br><span class=\"line\">        Gson gson = gsonBuilder.create();</span><br><span class=\"line\"></span><br><span class=\"line\">        String json = gson.toJson(app);</span><br><span class=\"line\">        System.out.println(&quot;Gson--&quot; + json);</span><br><span class=\"line\"></span><br><span class=\"line\">console result:</span><br><span class=\"line\">      Gson--&#123;&quot;app_id&quot;:431431,&quot;name&quot;:&quot;美团外卖&quot;,&quot;image_url&quot;:&quot;http://www.image.com/xxx.png&quot;,&quot;link_url&quot;:&quot;http://www.baidu.com&quot;&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"json字符串转java对象\"><a href=\"#json字符串转java对象\" class=\"headerlink\" title=\"json字符串转java对象\"></a>json字符串转java对象</h2><h3 id=\"fastJson实现方法-1\"><a href=\"#fastJson实现方法-1\" class=\"headerlink\" title=\"fastJson实现方法\"></a>fastJson实现方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">App app1 = JSON.parseObject(jsonStr, App.class);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Jackson实现方法-1\"><a href=\"#Jackson实现方法-1\" class=\"headerlink\" title=\"Jackson实现方法\"></a>Jackson实现方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ObjectMapper mapper = new ObjectMapper();</span><br><span class=\"line\">       mapper.setPropertyNamingStrategy(PropertyNamingStrategy.LOWER_CAMEL_CASE);</span><br><span class=\"line\">       App app = mapper.readValue(jsonStr, App.class);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Gson实现方法-1\"><a href=\"#Gson实现方法-1\" class=\"headerlink\" title=\"Gson实现方法\"></a>Gson实现方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Gson gson = new Gson();</span><br><span class=\"line\">Person person = gson.fromJson(json, Person.class)</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Mysql学习笔记之事务","date":"2019-08-05T08:25:58.000Z","_content":"","source":"_posts/Mysql学习笔记之事务.md","raw":"---\ntitle: Mysql学习笔记之事务\ndate: 2019-08-05 16:25:58\ntags:\n---\n","slug":"Mysql学习笔记之事务","published":1,"updated":"2019-08-05T08:25:58.434Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzjwwlm0005w4j9qfcewdc9","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Mysql学习笔记之查询优化篇","date":"2019-08-05T08:26:38.000Z","_content":"","source":"_posts/Mysql学习笔记之查询优化篇.md","raw":"---\ntitle: Mysql学习笔记之查询优化篇\ndate: 2019-08-05 16:26:38\ntags:\n---\n","slug":"Mysql学习笔记之查询优化篇","published":1,"updated":"2019-08-05T08:26:38.345Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzjwwlq0008w4j9zo11biyw","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Mysql学习笔记之索引篇","date":"2019-08-05T08:25:34.000Z","_content":"","source":"_posts/Mysql学习笔记之索引篇.md","raw":"---\ntitle: Mysql学习笔记之索引篇\ndate: 2019-08-05 16:25:34\ntags:\n---\n","slug":"Mysql学习笔记之索引篇","published":1,"updated":"2019-08-05T08:25:34.711Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzjwwls0009w4j9key00kj9","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Mysql学习笔记之锁","date":"2019-08-05T08:25:47.000Z","_content":"","source":"_posts/Mysql学习笔记之锁.md","raw":"---\ntitle: Mysql学习笔记之锁\ndate: 2019-08-05 16:25:47\ntags:\n---\n","slug":"Mysql学习笔记之锁","published":1,"updated":"2019-08-05T08:25:47.820Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzjwwlu000bw4j98lyw8c9d","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Mysql学习笔记之explain用法详解","date":"2019-07-09T08:27:54.000Z","_content":"\n### explain的作用\n用来获取查询执行计划的信息，当执行查询时，其返回关于查询计划的每一步的信息，而不是执行它。\n\n### explain输出的列\nexplain的输出总是相同的列，总共11列\n\n#### id\n\n\n#### select_type\n显示对应行时简单查询还是复杂查询（如果是后者，那么是三种复杂类型中的哪一种）\n取值：\n1. simple:简单查询，不包含子查询和union \n2. primary:查询为复杂查询，最外层标记为PRIMARY\n3. subquery:包含在select列表中的select子查询（不在from中的子句的子查询）标记为subquery\n4. dependent subquery\n5. derived:在from子句中的子查询\n6. union:\n7. union result:\n8. dependent union\n9. \n\n#### table\ntable表示对应行正在访问那个表，通常情况下，它就是表明或者别名\n\n\n#### type \n访问类型，或者决定如何查找表中的行，依次从最差到最优。\n\n```all < index < range < index_subquery < unique_subquery < index_merge < ref_or_null < ref < eq_ref < const<system```\n\n1. all:按行全表扫描，mysql必须扫描整张表，去找到需要的行（例外：limit会从开始扫描到下界加偏移量，如limit 100,10，会从开始扫描到110行;Extra列中有Using distinct/not exists时例外）\n2. index:按索引次序扫描全表，需要遍历全表索引\n3. range:范围扫描，只需遍历筛选后的区间的索引，一般带有between或者where的查询\n4. range ： 这个是index了范围限制，例如 >100、<1000之类的查询条件，这样避免的index的全索引扫描，当然限制的范围越小 效率就越高。\n5. index_subquery ： 在 某 些 IN 查 询 中 使 用 此 种 类 型 , 与 unique_subquery 类似,但是查询的是非唯一 性索引\n6. unique_subquery ： 在某些 IN 查询中使用此种类型,而不是常规的 ref\n7. index_merge ： 说明索引合并优化被使用了\n8. ref_or_null ： 如同 ref, 但是 MySQL 必须在初次查找的结果 里找出 null 条目,然后进行二次查找。\n9. ref ： 使用了非唯一性索引进行数据的查找，例如：我们对用户表的用户名这一列建立了非唯一索引，因为用户名可以重复，当我们查找用户的时候select * from user where username=“xxx”的时候就出现了ref，使用非唯一索引查找数据。\n10. eq_ref ： 这个就很好理解了，使用的唯一性索引进行数据查找，例如主键索引之类的。\n11. const ： 通常情况下，将一个主键放置到where后面作为条件查询，mysql优化器就能把这次查询优化转化为一个常量，如何转化以及何时转化，这个取决于优化器。这个比eq_ref效率高一点。\n12. system ： 表只有一行。不过这种情况下就没意义了。\n13. NULL ： MySQL不用访问表或者索引就直接能到结果。\n \n#### possible_keys\n\n#### key\n\n#### key_len\n\n#### ref\nrows列显示MySQL认为它执行查询时必须检查的行数。注意这是一个预估值\n\n#### rows\n\n#### extra\n\n\n\n","source":"_posts/Mysql学习笔记之explain用法详解.md","raw":"---\ntitle: Mysql学习笔记之explain用法详解\ndate: 2019-07-09 16:27:54\ncategories: mysql\ntags: 数据库\n---\n\n### explain的作用\n用来获取查询执行计划的信息，当执行查询时，其返回关于查询计划的每一步的信息，而不是执行它。\n\n### explain输出的列\nexplain的输出总是相同的列，总共11列\n\n#### id\n\n\n#### select_type\n显示对应行时简单查询还是复杂查询（如果是后者，那么是三种复杂类型中的哪一种）\n取值：\n1. simple:简单查询，不包含子查询和union \n2. primary:查询为复杂查询，最外层标记为PRIMARY\n3. subquery:包含在select列表中的select子查询（不在from中的子句的子查询）标记为subquery\n4. dependent subquery\n5. derived:在from子句中的子查询\n6. union:\n7. union result:\n8. dependent union\n9. \n\n#### table\ntable表示对应行正在访问那个表，通常情况下，它就是表明或者别名\n\n\n#### type \n访问类型，或者决定如何查找表中的行，依次从最差到最优。\n\n```all < index < range < index_subquery < unique_subquery < index_merge < ref_or_null < ref < eq_ref < const<system```\n\n1. all:按行全表扫描，mysql必须扫描整张表，去找到需要的行（例外：limit会从开始扫描到下界加偏移量，如limit 100,10，会从开始扫描到110行;Extra列中有Using distinct/not exists时例外）\n2. index:按索引次序扫描全表，需要遍历全表索引\n3. range:范围扫描，只需遍历筛选后的区间的索引，一般带有between或者where的查询\n4. range ： 这个是index了范围限制，例如 >100、<1000之类的查询条件，这样避免的index的全索引扫描，当然限制的范围越小 效率就越高。\n5. index_subquery ： 在 某 些 IN 查 询 中 使 用 此 种 类 型 , 与 unique_subquery 类似,但是查询的是非唯一 性索引\n6. unique_subquery ： 在某些 IN 查询中使用此种类型,而不是常规的 ref\n7. index_merge ： 说明索引合并优化被使用了\n8. ref_or_null ： 如同 ref, 但是 MySQL 必须在初次查找的结果 里找出 null 条目,然后进行二次查找。\n9. ref ： 使用了非唯一性索引进行数据的查找，例如：我们对用户表的用户名这一列建立了非唯一索引，因为用户名可以重复，当我们查找用户的时候select * from user where username=“xxx”的时候就出现了ref，使用非唯一索引查找数据。\n10. eq_ref ： 这个就很好理解了，使用的唯一性索引进行数据查找，例如主键索引之类的。\n11. const ： 通常情况下，将一个主键放置到where后面作为条件查询，mysql优化器就能把这次查询优化转化为一个常量，如何转化以及何时转化，这个取决于优化器。这个比eq_ref效率高一点。\n12. system ： 表只有一行。不过这种情况下就没意义了。\n13. NULL ： MySQL不用访问表或者索引就直接能到结果。\n \n#### possible_keys\n\n#### key\n\n#### key_len\n\n#### ref\nrows列显示MySQL认为它执行查询时必须检查的行数。注意这是一个预估值\n\n#### rows\n\n#### extra\n\n\n\n","slug":"Mysql学习笔记之explain用法详解","published":1,"updated":"2019-07-17T03:07:34.532Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzjwwlx000dw4j9lqqcdd4v","content":"<h3 id=\"explain的作用\"><a href=\"#explain的作用\" class=\"headerlink\" title=\"explain的作用\"></a>explain的作用</h3><p>用来获取查询执行计划的信息，当执行查询时，其返回关于查询计划的每一步的信息，而不是执行它。</p>\n<h3 id=\"explain输出的列\"><a href=\"#explain输出的列\" class=\"headerlink\" title=\"explain输出的列\"></a>explain输出的列</h3><p>explain的输出总是相同的列，总共11列</p>\n<h4 id=\"id\"><a href=\"#id\" class=\"headerlink\" title=\"id\"></a>id</h4><h4 id=\"select-type\"><a href=\"#select-type\" class=\"headerlink\" title=\"select_type\"></a>select_type</h4><p>显示对应行时简单查询还是复杂查询（如果是后者，那么是三种复杂类型中的哪一种）<br>取值：</p>\n<ol>\n<li>simple:简单查询，不包含子查询和union </li>\n<li>primary:查询为复杂查询，最外层标记为PRIMARY</li>\n<li>subquery:包含在select列表中的select子查询（不在from中的子句的子查询）标记为subquery</li>\n<li>dependent subquery</li>\n<li>derived:在from子句中的子查询</li>\n<li>union:</li>\n<li>union result:</li>\n<li>dependent union</li>\n<li></li>\n</ol>\n<h4 id=\"table\"><a href=\"#table\" class=\"headerlink\" title=\"table\"></a>table</h4><p>table表示对应行正在访问那个表，通常情况下，它就是表明或者别名</p>\n<h4 id=\"type\"><a href=\"#type\" class=\"headerlink\" title=\"type\"></a>type</h4><p>访问类型，或者决定如何查找表中的行，依次从最差到最优。</p>\n<p><code>all &lt; index &lt; range &lt; index_subquery &lt; unique_subquery &lt; index_merge &lt; ref_or_null &lt; ref &lt; eq_ref &lt; const&lt;system</code></p>\n<ol>\n<li>all:按行全表扫描，mysql必须扫描整张表，去找到需要的行（例外：limit会从开始扫描到下界加偏移量，如limit 100,10，会从开始扫描到110行;Extra列中有Using distinct/not exists时例外）</li>\n<li>index:按索引次序扫描全表，需要遍历全表索引</li>\n<li>range:范围扫描，只需遍历筛选后的区间的索引，一般带有between或者where的查询</li>\n<li>range ： 这个是index了范围限制，例如 &gt;100、&lt;1000之类的查询条件，这样避免的index的全索引扫描，当然限制的范围越小 效率就越高。</li>\n<li>index_subquery ： 在 某 些 IN 查 询 中 使 用 此 种 类 型 , 与 unique_subquery 类似,但是查询的是非唯一 性索引</li>\n<li>unique_subquery ： 在某些 IN 查询中使用此种类型,而不是常规的 ref</li>\n<li>index_merge ： 说明索引合并优化被使用了</li>\n<li>ref_or_null ： 如同 ref, 但是 MySQL 必须在初次查找的结果 里找出 null 条目,然后进行二次查找。</li>\n<li>ref ： 使用了非唯一性索引进行数据的查找，例如：我们对用户表的用户名这一列建立了非唯一索引，因为用户名可以重复，当我们查找用户的时候select * from user where username=“xxx”的时候就出现了ref，使用非唯一索引查找数据。</li>\n<li>eq_ref ： 这个就很好理解了，使用的唯一性索引进行数据查找，例如主键索引之类的。</li>\n<li>const ： 通常情况下，将一个主键放置到where后面作为条件查询，mysql优化器就能把这次查询优化转化为一个常量，如何转化以及何时转化，这个取决于优化器。这个比eq_ref效率高一点。</li>\n<li>system ： 表只有一行。不过这种情况下就没意义了。</li>\n<li>NULL ： MySQL不用访问表或者索引就直接能到结果。</li>\n</ol>\n<h4 id=\"possible-keys\"><a href=\"#possible-keys\" class=\"headerlink\" title=\"possible_keys\"></a>possible_keys</h4><h4 id=\"key\"><a href=\"#key\" class=\"headerlink\" title=\"key\"></a>key</h4><h4 id=\"key-len\"><a href=\"#key-len\" class=\"headerlink\" title=\"key_len\"></a>key_len</h4><h4 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h4><p>rows列显示MySQL认为它执行查询时必须检查的行数。注意这是一个预估值</p>\n<h4 id=\"rows\"><a href=\"#rows\" class=\"headerlink\" title=\"rows\"></a>rows</h4><h4 id=\"extra\"><a href=\"#extra\" class=\"headerlink\" title=\"extra\"></a>extra</h4>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"explain的作用\"><a href=\"#explain的作用\" class=\"headerlink\" title=\"explain的作用\"></a>explain的作用</h3><p>用来获取查询执行计划的信息，当执行查询时，其返回关于查询计划的每一步的信息，而不是执行它。</p>\n<h3 id=\"explain输出的列\"><a href=\"#explain输出的列\" class=\"headerlink\" title=\"explain输出的列\"></a>explain输出的列</h3><p>explain的输出总是相同的列，总共11列</p>\n<h4 id=\"id\"><a href=\"#id\" class=\"headerlink\" title=\"id\"></a>id</h4><h4 id=\"select-type\"><a href=\"#select-type\" class=\"headerlink\" title=\"select_type\"></a>select_type</h4><p>显示对应行时简单查询还是复杂查询（如果是后者，那么是三种复杂类型中的哪一种）<br>取值：</p>\n<ol>\n<li>simple:简单查询，不包含子查询和union </li>\n<li>primary:查询为复杂查询，最外层标记为PRIMARY</li>\n<li>subquery:包含在select列表中的select子查询（不在from中的子句的子查询）标记为subquery</li>\n<li>dependent subquery</li>\n<li>derived:在from子句中的子查询</li>\n<li>union:</li>\n<li>union result:</li>\n<li>dependent union</li>\n<li></li>\n</ol>\n<h4 id=\"table\"><a href=\"#table\" class=\"headerlink\" title=\"table\"></a>table</h4><p>table表示对应行正在访问那个表，通常情况下，它就是表明或者别名</p>\n<h4 id=\"type\"><a href=\"#type\" class=\"headerlink\" title=\"type\"></a>type</h4><p>访问类型，或者决定如何查找表中的行，依次从最差到最优。</p>\n<p><code>all &lt; index &lt; range &lt; index_subquery &lt; unique_subquery &lt; index_merge &lt; ref_or_null &lt; ref &lt; eq_ref &lt; const&lt;system</code></p>\n<ol>\n<li>all:按行全表扫描，mysql必须扫描整张表，去找到需要的行（例外：limit会从开始扫描到下界加偏移量，如limit 100,10，会从开始扫描到110行;Extra列中有Using distinct/not exists时例外）</li>\n<li>index:按索引次序扫描全表，需要遍历全表索引</li>\n<li>range:范围扫描，只需遍历筛选后的区间的索引，一般带有between或者where的查询</li>\n<li>range ： 这个是index了范围限制，例如 &gt;100、&lt;1000之类的查询条件，这样避免的index的全索引扫描，当然限制的范围越小 效率就越高。</li>\n<li>index_subquery ： 在 某 些 IN 查 询 中 使 用 此 种 类 型 , 与 unique_subquery 类似,但是查询的是非唯一 性索引</li>\n<li>unique_subquery ： 在某些 IN 查询中使用此种类型,而不是常规的 ref</li>\n<li>index_merge ： 说明索引合并优化被使用了</li>\n<li>ref_or_null ： 如同 ref, 但是 MySQL 必须在初次查找的结果 里找出 null 条目,然后进行二次查找。</li>\n<li>ref ： 使用了非唯一性索引进行数据的查找，例如：我们对用户表的用户名这一列建立了非唯一索引，因为用户名可以重复，当我们查找用户的时候select * from user where username=“xxx”的时候就出现了ref，使用非唯一索引查找数据。</li>\n<li>eq_ref ： 这个就很好理解了，使用的唯一性索引进行数据查找，例如主键索引之类的。</li>\n<li>const ： 通常情况下，将一个主键放置到where后面作为条件查询，mysql优化器就能把这次查询优化转化为一个常量，如何转化以及何时转化，这个取决于优化器。这个比eq_ref效率高一点。</li>\n<li>system ： 表只有一行。不过这种情况下就没意义了。</li>\n<li>NULL ： MySQL不用访问表或者索引就直接能到结果。</li>\n</ol>\n<h4 id=\"possible-keys\"><a href=\"#possible-keys\" class=\"headerlink\" title=\"possible_keys\"></a>possible_keys</h4><h4 id=\"key\"><a href=\"#key\" class=\"headerlink\" title=\"key\"></a>key</h4><h4 id=\"key-len\"><a href=\"#key-len\" class=\"headerlink\" title=\"key_len\"></a>key_len</h4><h4 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h4><p>rows列显示MySQL认为它执行查询时必须检查的行数。注意这是一个预估值</p>\n<h4 id=\"rows\"><a href=\"#rows\" class=\"headerlink\" title=\"rows\"></a>rows</h4><h4 id=\"extra\"><a href=\"#extra\" class=\"headerlink\" title=\"extra\"></a>extra</h4>"},{"title":"java 8之Stream Api解析","date":"2019-06-18T08:50:30.000Z","_content":"\n### 一、流操作之中间操作简介\n中间操作主要是用来对Stream做出相应转换及限制流，实际上是将源Stream转换为一个新的Stream，以达到需求效果。\n\n\n### 二、常用中间操作方法\n\n|操作|类型|返回类型|操作参数|函数描述符|作用|\n|-----|-----|----|------|-------|-------|\n|filter|中间|Stream<T>|Predicate<T>   |T -> boolean|返回参数函数为true的元素的流|\n|map   |中间|Stream<T>|Function<T, R> |T -> R      |参数函数会被应用到每个元素上，并将其映射成一个新的元素|\n|flatMap|中间|Stream<T>|Function<T, R> |T -> R      |flatmap 方法让你把一个流中的每个值都换成另一个流，然后把所有的流连接起来成为一个流。|\n|limit |中间|Stream<T>|               ||返回前n个元素的流|\n|skip  |中间|Stream<T>|               ||返回一个跳过前n个元素的流（不足n个元素，返回一个空流）|\n|sorted|中间|Stream<T>|Comparator<T>  |(T, T) -> int|按照传入的Comparator安排续|\n|distinct|中间|Stream<T>|             |            |根据流所生成元素的hashCode 和 equals 方法，实现去重后的流|\n\n### filter方法\n使用实例：遍历出相同的字符串\n```java\n Stream.of(\"a\", \"a\", \"b\")\n                .filter((s) -> s.startsWith(\"a\"))\n                .forEach(System.out::println);\n  //return:\"a\",\"a\"\n```\n### map方法\n类似的有：mapToDouble，mapToInt，mapToLong。\n使用实例：求和处理\n```java\nStream.of(1, 1, 1)\n               .mapToInt(Integer::intValue)\n               .sum();\n       //return:3\n```\n```java\nLong l=Stream.of(1L,2L,4L)\n                .mapToLong(Long::longValue)\n                .sum();\n//return:7\n```\n### flatMap方法\n使用实例： 给 定 单 词 列 表\"Hello\",\"World\" ，你想要返回列表 \"H\",\"e\",\"l\", \"o\",\"W\",\"r\",\"d\" ，做法就是先分割，在去重，返回字符串数组。\n```java\n  List<String> uniqueCharacters =\n                Stream.of(\"heelo\",\"adafa\")\n                        .map(w -> w.split(\"\"))\n                        .flatMap(Arrays::stream)\n                        .distinct()\n                        .collect(Collectors.toList());\n```\n### limit方法和skip方法\n使用实例：取前n个元素\n```java\n Stream.of(1, 2, 3, 4, 5)\n\t   .limit(3)\n\t    .forEach(i -> System.out.println(i));\n//return 1,2,3\n```\n使用实例：跳过前3个元素\n```java\n Stream.of(1, 2, 3, 4, 5)\n\t   .skip(3)\n\t    .forEach(System.out::println);\n//return 4,5\n```\n### distinct方法\n使用实例：去重操作\n```java\nStream.of(\"a\", \"b\", \"c\", \"c\")\n                .distinct()\n                .forEach(System.out::println);\n //return:a,b,c\n```\n\n\n\n","source":"_posts/java8之Stream-Api.md","raw":"---\ntitle: java 8之Stream Api解析\ndate: 2019-06-18 16:50:30\ncategories: java基础\ntags:\n---\n\n### 一、流操作之中间操作简介\n中间操作主要是用来对Stream做出相应转换及限制流，实际上是将源Stream转换为一个新的Stream，以达到需求效果。\n\n\n### 二、常用中间操作方法\n\n|操作|类型|返回类型|操作参数|函数描述符|作用|\n|-----|-----|----|------|-------|-------|\n|filter|中间|Stream<T>|Predicate<T>   |T -> boolean|返回参数函数为true的元素的流|\n|map   |中间|Stream<T>|Function<T, R> |T -> R      |参数函数会被应用到每个元素上，并将其映射成一个新的元素|\n|flatMap|中间|Stream<T>|Function<T, R> |T -> R      |flatmap 方法让你把一个流中的每个值都换成另一个流，然后把所有的流连接起来成为一个流。|\n|limit |中间|Stream<T>|               ||返回前n个元素的流|\n|skip  |中间|Stream<T>|               ||返回一个跳过前n个元素的流（不足n个元素，返回一个空流）|\n|sorted|中间|Stream<T>|Comparator<T>  |(T, T) -> int|按照传入的Comparator安排续|\n|distinct|中间|Stream<T>|             |            |根据流所生成元素的hashCode 和 equals 方法，实现去重后的流|\n\n### filter方法\n使用实例：遍历出相同的字符串\n```java\n Stream.of(\"a\", \"a\", \"b\")\n                .filter((s) -> s.startsWith(\"a\"))\n                .forEach(System.out::println);\n  //return:\"a\",\"a\"\n```\n### map方法\n类似的有：mapToDouble，mapToInt，mapToLong。\n使用实例：求和处理\n```java\nStream.of(1, 1, 1)\n               .mapToInt(Integer::intValue)\n               .sum();\n       //return:3\n```\n```java\nLong l=Stream.of(1L,2L,4L)\n                .mapToLong(Long::longValue)\n                .sum();\n//return:7\n```\n### flatMap方法\n使用实例： 给 定 单 词 列 表\"Hello\",\"World\" ，你想要返回列表 \"H\",\"e\",\"l\", \"o\",\"W\",\"r\",\"d\" ，做法就是先分割，在去重，返回字符串数组。\n```java\n  List<String> uniqueCharacters =\n                Stream.of(\"heelo\",\"adafa\")\n                        .map(w -> w.split(\"\"))\n                        .flatMap(Arrays::stream)\n                        .distinct()\n                        .collect(Collectors.toList());\n```\n### limit方法和skip方法\n使用实例：取前n个元素\n```java\n Stream.of(1, 2, 3, 4, 5)\n\t   .limit(3)\n\t    .forEach(i -> System.out.println(i));\n//return 1,2,3\n```\n使用实例：跳过前3个元素\n```java\n Stream.of(1, 2, 3, 4, 5)\n\t   .skip(3)\n\t    .forEach(System.out::println);\n//return 4,5\n```\n### distinct方法\n使用实例：去重操作\n```java\nStream.of(\"a\", \"b\", \"c\", \"c\")\n                .distinct()\n                .forEach(System.out::println);\n //return:a,b,c\n```\n\n\n\n","slug":"java8之Stream-Api","published":1,"updated":"2019-07-02T11:21:32.668Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzjwwlz000fw4j90dbkjpd0","content":"<h3 id=\"一、流操作之中间操作简介\"><a href=\"#一、流操作之中间操作简介\" class=\"headerlink\" title=\"一、流操作之中间操作简介\"></a>一、流操作之中间操作简介</h3><p>中间操作主要是用来对Stream做出相应转换及限制流，实际上是将源Stream转换为一个新的Stream，以达到需求效果。</p>\n<h3 id=\"二、常用中间操作方法\"><a href=\"#二、常用中间操作方法\" class=\"headerlink\" title=\"二、常用中间操作方法\"></a>二、常用中间操作方法</h3><table>\n<thead>\n<tr>\n<th>操作</th>\n<th>类型</th>\n<th>返回类型</th>\n<th>操作参数</th>\n<th>函数描述符</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>filter</td>\n<td>中间</td>\n<td>Stream<t></t></td>\n<td>Predicate<t></t></td>\n<td>T -&gt; boolean</td>\n<td>返回参数函数为true的元素的流</td>\n</tr>\n<tr>\n<td>map</td>\n<td>中间</td>\n<td>Stream<t></t></td>\n<td>Function&lt;T, R&gt;</td>\n<td>T -&gt; R</td>\n<td>参数函数会被应用到每个元素上，并将其映射成一个新的元素</td>\n</tr>\n<tr>\n<td>flatMap</td>\n<td>中间</td>\n<td>Stream<t></t></td>\n<td>Function&lt;T, R&gt;</td>\n<td>T -&gt; R</td>\n<td>flatmap 方法让你把一个流中的每个值都换成另一个流，然后把所有的流连接起来成为一个流。</td>\n</tr>\n<tr>\n<td>limit</td>\n<td>中间</td>\n<td>Stream<t></t></td>\n<td></td>\n<td></td>\n<td>返回前n个元素的流</td>\n</tr>\n<tr>\n<td>skip</td>\n<td>中间</td>\n<td>Stream<t></t></td>\n<td></td>\n<td></td>\n<td>返回一个跳过前n个元素的流（不足n个元素，返回一个空流）</td>\n</tr>\n<tr>\n<td>sorted</td>\n<td>中间</td>\n<td>Stream<t></t></td>\n<td>Comparator<t></t></td>\n<td>(T, T) -&gt; int</td>\n<td>按照传入的Comparator安排续</td>\n</tr>\n<tr>\n<td>distinct</td>\n<td>中间</td>\n<td>Stream<t></t></td>\n<td></td>\n<td></td>\n<td>根据流所生成元素的hashCode 和 equals 方法，实现去重后的流</td>\n</tr>\n</tbody></table>\n<h3 id=\"filter方法\"><a href=\"#filter方法\" class=\"headerlink\" title=\"filter方法\"></a>filter方法</h3><p>使用实例：遍历出相同的字符串</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream.of(<span class=\"string\">\"a\"</span>, <span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>)</span><br><span class=\"line\">               .filter((s) -&gt; s.startsWith(<span class=\"string\">\"a\"</span>))</span><br><span class=\"line\">               .forEach(System.out::println);</span><br><span class=\"line\"> <span class=\"comment\">//return:\"a\",\"a\"</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"map方法\"><a href=\"#map方法\" class=\"headerlink\" title=\"map方法\"></a>map方法</h3><p>类似的有：mapToDouble，mapToInt，mapToLong。<br>使用实例：求和处理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream.of(<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">               .mapToInt(Integer::intValue)</span><br><span class=\"line\">               .sum();</span><br><span class=\"line\">       <span class=\"comment\">//return:3</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Long l=Stream.of(<span class=\"number\">1L</span>,<span class=\"number\">2L</span>,<span class=\"number\">4L</span>)</span><br><span class=\"line\">                .mapToLong(Long::longValue)</span><br><span class=\"line\">                .sum();</span><br><span class=\"line\"><span class=\"comment\">//return:7</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"flatMap方法\"><a href=\"#flatMap方法\" class=\"headerlink\" title=\"flatMap方法\"></a>flatMap方法</h3><p>使用实例： 给 定 单 词 列 表”Hello”,”World” ，你想要返回列表 “H”,”e”,”l”, “o”,”W”,”r”,”d” ，做法就是先分割，在去重，返回字符串数组。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; uniqueCharacters =</span><br><span class=\"line\">              Stream.of(<span class=\"string\">\"heelo\"</span>,<span class=\"string\">\"adafa\"</span>)</span><br><span class=\"line\">                      .map(w -&gt; w.split(<span class=\"string\">\"\"</span>))</span><br><span class=\"line\">                      .flatMap(Arrays::stream)</span><br><span class=\"line\">                      .distinct()</span><br><span class=\"line\">                      .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"limit方法和skip方法\"><a href=\"#limit方法和skip方法\" class=\"headerlink\" title=\"limit方法和skip方法\"></a>limit方法和skip方法</h3><p>使用实例：取前n个元素</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> Stream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">\t   .limit(<span class=\"number\">3</span>)</span><br><span class=\"line\">\t    .forEach(i -&gt; System.out.println(i));</span><br><span class=\"line\"><span class=\"comment\">//return 1,2,3</span></span><br></pre></td></tr></table></figure>\n\n<p>使用实例：跳过前3个元素</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> Stream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">\t   .skip(<span class=\"number\">3</span>)</span><br><span class=\"line\">\t    .forEach(System.out::println);</span><br><span class=\"line\"><span class=\"comment\">//return 4,5</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"distinct方法\"><a href=\"#distinct方法\" class=\"headerlink\" title=\"distinct方法\"></a>distinct方法</h3><p>使用实例：去重操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream.of(<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>, <span class=\"string\">\"c\"</span>)</span><br><span class=\"line\">                .distinct()</span><br><span class=\"line\">                .forEach(System.out::println);</span><br><span class=\"line\"> <span class=\"comment\">//return:a,b,c</span></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、流操作之中间操作简介\"><a href=\"#一、流操作之中间操作简介\" class=\"headerlink\" title=\"一、流操作之中间操作简介\"></a>一、流操作之中间操作简介</h3><p>中间操作主要是用来对Stream做出相应转换及限制流，实际上是将源Stream转换为一个新的Stream，以达到需求效果。</p>\n<h3 id=\"二、常用中间操作方法\"><a href=\"#二、常用中间操作方法\" class=\"headerlink\" title=\"二、常用中间操作方法\"></a>二、常用中间操作方法</h3><table>\n<thead>\n<tr>\n<th>操作</th>\n<th>类型</th>\n<th>返回类型</th>\n<th>操作参数</th>\n<th>函数描述符</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>filter</td>\n<td>中间</td>\n<td>Stream<t></t></td>\n<td>Predicate<t></t></td>\n<td>T -&gt; boolean</td>\n<td>返回参数函数为true的元素的流</td>\n</tr>\n<tr>\n<td>map</td>\n<td>中间</td>\n<td>Stream<t></t></td>\n<td>Function&lt;T, R&gt;</td>\n<td>T -&gt; R</td>\n<td>参数函数会被应用到每个元素上，并将其映射成一个新的元素</td>\n</tr>\n<tr>\n<td>flatMap</td>\n<td>中间</td>\n<td>Stream<t></t></td>\n<td>Function&lt;T, R&gt;</td>\n<td>T -&gt; R</td>\n<td>flatmap 方法让你把一个流中的每个值都换成另一个流，然后把所有的流连接起来成为一个流。</td>\n</tr>\n<tr>\n<td>limit</td>\n<td>中间</td>\n<td>Stream<t></t></td>\n<td></td>\n<td></td>\n<td>返回前n个元素的流</td>\n</tr>\n<tr>\n<td>skip</td>\n<td>中间</td>\n<td>Stream<t></t></td>\n<td></td>\n<td></td>\n<td>返回一个跳过前n个元素的流（不足n个元素，返回一个空流）</td>\n</tr>\n<tr>\n<td>sorted</td>\n<td>中间</td>\n<td>Stream<t></t></td>\n<td>Comparator<t></t></td>\n<td>(T, T) -&gt; int</td>\n<td>按照传入的Comparator安排续</td>\n</tr>\n<tr>\n<td>distinct</td>\n<td>中间</td>\n<td>Stream<t></t></td>\n<td></td>\n<td></td>\n<td>根据流所生成元素的hashCode 和 equals 方法，实现去重后的流</td>\n</tr>\n</tbody></table>\n<h3 id=\"filter方法\"><a href=\"#filter方法\" class=\"headerlink\" title=\"filter方法\"></a>filter方法</h3><p>使用实例：遍历出相同的字符串</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream.of(<span class=\"string\">\"a\"</span>, <span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>)</span><br><span class=\"line\">               .filter((s) -&gt; s.startsWith(<span class=\"string\">\"a\"</span>))</span><br><span class=\"line\">               .forEach(System.out::println);</span><br><span class=\"line\"> <span class=\"comment\">//return:\"a\",\"a\"</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"map方法\"><a href=\"#map方法\" class=\"headerlink\" title=\"map方法\"></a>map方法</h3><p>类似的有：mapToDouble，mapToInt，mapToLong。<br>使用实例：求和处理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream.of(<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">               .mapToInt(Integer::intValue)</span><br><span class=\"line\">               .sum();</span><br><span class=\"line\">       <span class=\"comment\">//return:3</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Long l=Stream.of(<span class=\"number\">1L</span>,<span class=\"number\">2L</span>,<span class=\"number\">4L</span>)</span><br><span class=\"line\">                .mapToLong(Long::longValue)</span><br><span class=\"line\">                .sum();</span><br><span class=\"line\"><span class=\"comment\">//return:7</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"flatMap方法\"><a href=\"#flatMap方法\" class=\"headerlink\" title=\"flatMap方法\"></a>flatMap方法</h3><p>使用实例： 给 定 单 词 列 表”Hello”,”World” ，你想要返回列表 “H”,”e”,”l”, “o”,”W”,”r”,”d” ，做法就是先分割，在去重，返回字符串数组。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; uniqueCharacters =</span><br><span class=\"line\">              Stream.of(<span class=\"string\">\"heelo\"</span>,<span class=\"string\">\"adafa\"</span>)</span><br><span class=\"line\">                      .map(w -&gt; w.split(<span class=\"string\">\"\"</span>))</span><br><span class=\"line\">                      .flatMap(Arrays::stream)</span><br><span class=\"line\">                      .distinct()</span><br><span class=\"line\">                      .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"limit方法和skip方法\"><a href=\"#limit方法和skip方法\" class=\"headerlink\" title=\"limit方法和skip方法\"></a>limit方法和skip方法</h3><p>使用实例：取前n个元素</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> Stream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">\t   .limit(<span class=\"number\">3</span>)</span><br><span class=\"line\">\t    .forEach(i -&gt; System.out.println(i));</span><br><span class=\"line\"><span class=\"comment\">//return 1,2,3</span></span><br></pre></td></tr></table></figure>\n\n<p>使用实例：跳过前3个元素</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> Stream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">\t   .skip(<span class=\"number\">3</span>)</span><br><span class=\"line\">\t    .forEach(System.out::println);</span><br><span class=\"line\"><span class=\"comment\">//return 4,5</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"distinct方法\"><a href=\"#distinct方法\" class=\"headerlink\" title=\"distinct方法\"></a>distinct方法</h3><p>使用实例：去重操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream.of(<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>, <span class=\"string\">\"c\"</span>)</span><br><span class=\"line\">                .distinct()</span><br><span class=\"line\">                .forEach(System.out::println);</span><br><span class=\"line\"> <span class=\"comment\">//return:a,b,c</span></span><br></pre></td></tr></table></figure>\n\n"},{"title":"interceptor 配合Threadlocal全局处理请求基本信息","date":"2019-06-18T08:43:32.000Z","_content":"\n### 业务场景\n\n> 最近接手一个供app端调用的网关项目，app端迭代更新，接口就要相应的区分版本并做相应的逻辑区分，所以每一次请求必须要获取版本号。\n\n### 实现逻辑\n\n> 期初的做法是在controller中直接定义 @RequestParam(\"name\") String name，但发现调用的方法层数增加时，参数需要逐层传递，调用链上每个方法都需要加参数，代码及不优雅。后改为添加一个拦截器VersionInfoInterceptor，在拦截器中操作Threadlocal中的变量，代码如下：\n\n    /**\n     * @author:xiantao.wu\n     * @createDate:2018/7/1011:25\n     * 先执行preHandle方法，将需要的变量放入ThreadLocal,方法执行完执行afterCompletion，将变量remove掉，拦截器原理后续文章将会介绍\n     * \n     **/\n    public class VersionInfoInterceptor extends HandlerInterceptorAdapter {\n        @Override\n        public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n            String clientVersion = request.getHeader(\"x-client-version\");\n            if (clientVersion != null) {\n                RequestHeaderBaseInfo requestHeaderBaseInfo=new RequestHeaderBaseInfo();\n                requestHeaderBaseInfo.setVersion(clientVersion);\n                ThreadLocalUtil.set(requestHeaderBaseInfo);\n                return true;\n            } else {\n                return false;\n            }\n        }\n    \n        @Override\n        public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n            ThreadLocalUtil.remove();\n        }\n    \n\n> 直接TreadlocalUtil.get()即可获取version放入的变量\n\n    /**\n     * @author:xiantao.wu\n     * @createDate:2018/7/1011:25\n     * 提供工具类你，操作Threadlocal\n     **/\n    public class ThreadLocalUtil {\n        private ThreadLocalUtil() {\n        }\n    \n        private static ThreadLocal<RequestHeaderBaseInfo> LOCAL = new  TransmittableThreadLocal<>();\n    \n        public static void set(RequestHeaderBaseInfo requestHeaderBaseInfo) {\n            LOCAL.set(requestHeaderBaseInfo);\n        }\n    \n        public static RequestHeaderBaseInfo get() {\n            return LOCAL.get();\n        }\n    \n        public static void remove() {\n            LOCAL.remove();\n        }\n    \n    }\n    \n\n### 敲黑板（需要避免的坑） 现在ThreadLocal除原生实现外，还有InheritableThreadLocal，TransmittableThreadLocal（眼尖的同学可能已经注意到了）这两种实现，上面选用的就是TransmittableThreadLocal，以下是三者的比较：\n\n|  实现 | 能否在传递到子线程  | 使用注意点  |\n| :------------ | :------------ | :------------ |\n| ThreadLocal  | 否  | 只能在当前线程中获取本地变量  |\n|InheritableThreadLocal|是|可获取父线程的中的本地变量，线程池场景不适用，存在线程复用，会导致混|\n|TransmittableThreadLocal|是|可获取父线程中的本地变量，适用线程池场景|\n\n    \n\n### 测试结果\n\n/** * Created by wuxiantao on 2018/7/14. */ public class TransmittableThreadlocalTest {\n\n    private static ThreadLocal<String> transmittableThreadLocal=new TransmittableThreadLocal<>();\n    \n    public static void main(String[] args) throws InterruptedException {\n        ThreadPoolExecutor threadPoolExecutor=new ThreadPoolExecutor(3,3,10, TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>());\n        transmittableThreadLocal.set(\"父线程设定的值\");\n        System.out.println(Thread.currentThread().getName()+\"====\"+transmittableThreadLocal.get());\n    \n        for (int i = 0; i < 5; i++) {\n            threadPoolExecutor.submit(TtlCallable.get(new Callable<String>() {\n                public String call() throws Exception {\n                    System.out.println(Thread.currentThread().getName()+\"------\"+transmittableThreadLocal.get());\n                    transmittableThreadLocal.set(\"我被修改了\");\n                    return transmittableThreadLocal.get();\n                }\n            }));\n        }\n    }\n    \n\n}\n\n    <br />使用transmimttable-threadlocal中TtlCallable.get()提交任务，在子线程中修改Threadlocal,子线程还是会取主线程中的threadlocal\n    \n```java\nmain====父线程设定的值\npool-1-thread-2------父线程设定的值\npool-1-thread-1------父线程设定的值\npool-1-thread-1------父线程设定的值\npool-1-thread-1------父线程设定的值\npool-1-thread-3------父线程设定的值\n```\n\\``\\`\n","source":"_posts/interceptor-配合Threadlocal全局处理请求基本信息.md","raw":"---\ntitle: interceptor 配合Threadlocal全局处理请求基本信息\ndate: 2019-06-18 16:43:32\ncategories: java基础\ntags: java\n---\n\n### 业务场景\n\n> 最近接手一个供app端调用的网关项目，app端迭代更新，接口就要相应的区分版本并做相应的逻辑区分，所以每一次请求必须要获取版本号。\n\n### 实现逻辑\n\n> 期初的做法是在controller中直接定义 @RequestParam(\"name\") String name，但发现调用的方法层数增加时，参数需要逐层传递，调用链上每个方法都需要加参数，代码及不优雅。后改为添加一个拦截器VersionInfoInterceptor，在拦截器中操作Threadlocal中的变量，代码如下：\n\n    /**\n     * @author:xiantao.wu\n     * @createDate:2018/7/1011:25\n     * 先执行preHandle方法，将需要的变量放入ThreadLocal,方法执行完执行afterCompletion，将变量remove掉，拦截器原理后续文章将会介绍\n     * \n     **/\n    public class VersionInfoInterceptor extends HandlerInterceptorAdapter {\n        @Override\n        public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n            String clientVersion = request.getHeader(\"x-client-version\");\n            if (clientVersion != null) {\n                RequestHeaderBaseInfo requestHeaderBaseInfo=new RequestHeaderBaseInfo();\n                requestHeaderBaseInfo.setVersion(clientVersion);\n                ThreadLocalUtil.set(requestHeaderBaseInfo);\n                return true;\n            } else {\n                return false;\n            }\n        }\n    \n        @Override\n        public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n            ThreadLocalUtil.remove();\n        }\n    \n\n> 直接TreadlocalUtil.get()即可获取version放入的变量\n\n    /**\n     * @author:xiantao.wu\n     * @createDate:2018/7/1011:25\n     * 提供工具类你，操作Threadlocal\n     **/\n    public class ThreadLocalUtil {\n        private ThreadLocalUtil() {\n        }\n    \n        private static ThreadLocal<RequestHeaderBaseInfo> LOCAL = new  TransmittableThreadLocal<>();\n    \n        public static void set(RequestHeaderBaseInfo requestHeaderBaseInfo) {\n            LOCAL.set(requestHeaderBaseInfo);\n        }\n    \n        public static RequestHeaderBaseInfo get() {\n            return LOCAL.get();\n        }\n    \n        public static void remove() {\n            LOCAL.remove();\n        }\n    \n    }\n    \n\n### 敲黑板（需要避免的坑） 现在ThreadLocal除原生实现外，还有InheritableThreadLocal，TransmittableThreadLocal（眼尖的同学可能已经注意到了）这两种实现，上面选用的就是TransmittableThreadLocal，以下是三者的比较：\n\n|  实现 | 能否在传递到子线程  | 使用注意点  |\n| :------------ | :------------ | :------------ |\n| ThreadLocal  | 否  | 只能在当前线程中获取本地变量  |\n|InheritableThreadLocal|是|可获取父线程的中的本地变量，线程池场景不适用，存在线程复用，会导致混|\n|TransmittableThreadLocal|是|可获取父线程中的本地变量，适用线程池场景|\n\n    \n\n### 测试结果\n\n/** * Created by wuxiantao on 2018/7/14. */ public class TransmittableThreadlocalTest {\n\n    private static ThreadLocal<String> transmittableThreadLocal=new TransmittableThreadLocal<>();\n    \n    public static void main(String[] args) throws InterruptedException {\n        ThreadPoolExecutor threadPoolExecutor=new ThreadPoolExecutor(3,3,10, TimeUnit.MINUTES, new LinkedBlockingQueue<Runnable>());\n        transmittableThreadLocal.set(\"父线程设定的值\");\n        System.out.println(Thread.currentThread().getName()+\"====\"+transmittableThreadLocal.get());\n    \n        for (int i = 0; i < 5; i++) {\n            threadPoolExecutor.submit(TtlCallable.get(new Callable<String>() {\n                public String call() throws Exception {\n                    System.out.println(Thread.currentThread().getName()+\"------\"+transmittableThreadLocal.get());\n                    transmittableThreadLocal.set(\"我被修改了\");\n                    return transmittableThreadLocal.get();\n                }\n            }));\n        }\n    }\n    \n\n}\n\n    <br />使用transmimttable-threadlocal中TtlCallable.get()提交任务，在子线程中修改Threadlocal,子线程还是会取主线程中的threadlocal\n    \n```java\nmain====父线程设定的值\npool-1-thread-2------父线程设定的值\npool-1-thread-1------父线程设定的值\npool-1-thread-1------父线程设定的值\npool-1-thread-1------父线程设定的值\npool-1-thread-3------父线程设定的值\n```\n\\``\\`\n","slug":"interceptor-配合Threadlocal全局处理请求基本信息","published":1,"updated":"2019-07-02T11:21:32.664Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzjwwm1000iw4j9qn40qjn1","content":"<h3 id=\"业务场景\"><a href=\"#业务场景\" class=\"headerlink\" title=\"业务场景\"></a>业务场景</h3><blockquote>\n<p>最近接手一个供app端调用的网关项目，app端迭代更新，接口就要相应的区分版本并做相应的逻辑区分，所以每一次请求必须要获取版本号。</p>\n</blockquote>\n<h3 id=\"实现逻辑\"><a href=\"#实现逻辑\" class=\"headerlink\" title=\"实现逻辑\"></a>实现逻辑</h3><blockquote>\n<p>期初的做法是在controller中直接定义 @RequestParam(“name”) String name，但发现调用的方法层数增加时，参数需要逐层传递，调用链上每个方法都需要加参数，代码及不优雅。后改为添加一个拦截器VersionInfoInterceptor，在拦截器中操作Threadlocal中的变量，代码如下：</p>\n</blockquote>\n<pre><code>/**\n * @author:xiantao.wu\n * @createDate:2018/7/1011:25\n * 先执行preHandle方法，将需要的变量放入ThreadLocal,方法执行完执行afterCompletion，将变量remove掉，拦截器原理后续文章将会介绍\n * \n **/\npublic class VersionInfoInterceptor extends HandlerInterceptorAdapter {\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        String clientVersion = request.getHeader(&quot;x-client-version&quot;);\n        if (clientVersion != null) {\n            RequestHeaderBaseInfo requestHeaderBaseInfo=new RequestHeaderBaseInfo();\n            requestHeaderBaseInfo.setVersion(clientVersion);\n            ThreadLocalUtil.set(requestHeaderBaseInfo);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n        ThreadLocalUtil.remove();\n    }</code></pre><blockquote>\n<p>直接TreadlocalUtil.get()即可获取version放入的变量</p>\n</blockquote>\n<pre><code>/**\n * @author:xiantao.wu\n * @createDate:2018/7/1011:25\n * 提供工具类你，操作Threadlocal\n **/\npublic class ThreadLocalUtil {\n    private ThreadLocalUtil() {\n    }\n\n    private static ThreadLocal&lt;RequestHeaderBaseInfo&gt; LOCAL = new  TransmittableThreadLocal&lt;&gt;();\n\n    public static void set(RequestHeaderBaseInfo requestHeaderBaseInfo) {\n        LOCAL.set(requestHeaderBaseInfo);\n    }\n\n    public static RequestHeaderBaseInfo get() {\n        return LOCAL.get();\n    }\n\n    public static void remove() {\n        LOCAL.remove();\n    }\n\n}</code></pre><h3 id=\"敲黑板（需要避免的坑）-现在ThreadLocal除原生实现外，还有InheritableThreadLocal，TransmittableThreadLocal（眼尖的同学可能已经注意到了）这两种实现，上面选用的就是TransmittableThreadLocal，以下是三者的比较：\"><a href=\"#敲黑板（需要避免的坑）-现在ThreadLocal除原生实现外，还有InheritableThreadLocal，TransmittableThreadLocal（眼尖的同学可能已经注意到了）这两种实现，上面选用的就是TransmittableThreadLocal，以下是三者的比较：\" class=\"headerlink\" title=\"敲黑板（需要避免的坑） 现在ThreadLocal除原生实现外，还有InheritableThreadLocal，TransmittableThreadLocal（眼尖的同学可能已经注意到了）这两种实现，上面选用的就是TransmittableThreadLocal，以下是三者的比较：\"></a>敲黑板（需要避免的坑） 现在ThreadLocal除原生实现外，还有InheritableThreadLocal，TransmittableThreadLocal（眼尖的同学可能已经注意到了）这两种实现，上面选用的就是TransmittableThreadLocal，以下是三者的比较：</h3><table>\n<thead>\n<tr>\n<th align=\"left\">实现</th>\n<th align=\"left\">能否在传递到子线程</th>\n<th align=\"left\">使用注意点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">ThreadLocal</td>\n<td align=\"left\">否</td>\n<td align=\"left\">只能在当前线程中获取本地变量</td>\n</tr>\n<tr>\n<td align=\"left\">InheritableThreadLocal</td>\n<td align=\"left\">是</td>\n<td align=\"left\">可获取父线程的中的本地变量，线程池场景不适用，存在线程复用，会导致混</td>\n</tr>\n<tr>\n<td align=\"left\">TransmittableThreadLocal</td>\n<td align=\"left\">是</td>\n<td align=\"left\">可获取父线程中的本地变量，适用线程池场景</td>\n</tr>\n</tbody></table>\n<h3 id=\"测试结果\"><a href=\"#测试结果\" class=\"headerlink\" title=\"测试结果\"></a>测试结果</h3><p>/** * Created by wuxiantao on 2018/7/14. */ public class TransmittableThreadlocalTest {</p>\n<pre><code>private static ThreadLocal&lt;String&gt; transmittableThreadLocal=new TransmittableThreadLocal&lt;&gt;();\n\npublic static void main(String[] args) throws InterruptedException {\n    ThreadPoolExecutor threadPoolExecutor=new ThreadPoolExecutor(3,3,10, TimeUnit.MINUTES, new LinkedBlockingQueue&lt;Runnable&gt;());\n    transmittableThreadLocal.set(&quot;父线程设定的值&quot;);\n    System.out.println(Thread.currentThread().getName()+&quot;====&quot;+transmittableThreadLocal.get());\n\n    for (int i = 0; i &lt; 5; i++) {\n        threadPoolExecutor.submit(TtlCallable.get(new Callable&lt;String&gt;() {\n            public String call() throws Exception {\n                System.out.println(Thread.currentThread().getName()+&quot;------&quot;+transmittableThreadLocal.get());\n                transmittableThreadLocal.set(&quot;我被修改了&quot;);\n                return transmittableThreadLocal.get();\n            }\n        }));\n    }\n}</code></pre><p>}</p>\n<pre><code>&lt;br /&gt;使用transmimttable-threadlocal中TtlCallable.get()提交任务，在子线程中修改Threadlocal,子线程还是会取主线程中的threadlocal</code></pre><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">main====父线程设定的值</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">2</span>------父线程设定的值</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span>------父线程设定的值</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span>------父线程设定的值</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span>------父线程设定的值</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">3</span>------父线程设定的值</span><br></pre></td></tr></table></figure>\n\n<p>`<code>\\</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"业务场景\"><a href=\"#业务场景\" class=\"headerlink\" title=\"业务场景\"></a>业务场景</h3><blockquote>\n<p>最近接手一个供app端调用的网关项目，app端迭代更新，接口就要相应的区分版本并做相应的逻辑区分，所以每一次请求必须要获取版本号。</p>\n</blockquote>\n<h3 id=\"实现逻辑\"><a href=\"#实现逻辑\" class=\"headerlink\" title=\"实现逻辑\"></a>实现逻辑</h3><blockquote>\n<p>期初的做法是在controller中直接定义 @RequestParam(“name”) String name，但发现调用的方法层数增加时，参数需要逐层传递，调用链上每个方法都需要加参数，代码及不优雅。后改为添加一个拦截器VersionInfoInterceptor，在拦截器中操作Threadlocal中的变量，代码如下：</p>\n</blockquote>\n<pre><code>/**\n * @author:xiantao.wu\n * @createDate:2018/7/1011:25\n * 先执行preHandle方法，将需要的变量放入ThreadLocal,方法执行完执行afterCompletion，将变量remove掉，拦截器原理后续文章将会介绍\n * \n **/\npublic class VersionInfoInterceptor extends HandlerInterceptorAdapter {\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        String clientVersion = request.getHeader(&quot;x-client-version&quot;);\n        if (clientVersion != null) {\n            RequestHeaderBaseInfo requestHeaderBaseInfo=new RequestHeaderBaseInfo();\n            requestHeaderBaseInfo.setVersion(clientVersion);\n            ThreadLocalUtil.set(requestHeaderBaseInfo);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n        ThreadLocalUtil.remove();\n    }</code></pre><blockquote>\n<p>直接TreadlocalUtil.get()即可获取version放入的变量</p>\n</blockquote>\n<pre><code>/**\n * @author:xiantao.wu\n * @createDate:2018/7/1011:25\n * 提供工具类你，操作Threadlocal\n **/\npublic class ThreadLocalUtil {\n    private ThreadLocalUtil() {\n    }\n\n    private static ThreadLocal&lt;RequestHeaderBaseInfo&gt; LOCAL = new  TransmittableThreadLocal&lt;&gt;();\n\n    public static void set(RequestHeaderBaseInfo requestHeaderBaseInfo) {\n        LOCAL.set(requestHeaderBaseInfo);\n    }\n\n    public static RequestHeaderBaseInfo get() {\n        return LOCAL.get();\n    }\n\n    public static void remove() {\n        LOCAL.remove();\n    }\n\n}</code></pre><h3 id=\"敲黑板（需要避免的坑）-现在ThreadLocal除原生实现外，还有InheritableThreadLocal，TransmittableThreadLocal（眼尖的同学可能已经注意到了）这两种实现，上面选用的就是TransmittableThreadLocal，以下是三者的比较：\"><a href=\"#敲黑板（需要避免的坑）-现在ThreadLocal除原生实现外，还有InheritableThreadLocal，TransmittableThreadLocal（眼尖的同学可能已经注意到了）这两种实现，上面选用的就是TransmittableThreadLocal，以下是三者的比较：\" class=\"headerlink\" title=\"敲黑板（需要避免的坑） 现在ThreadLocal除原生实现外，还有InheritableThreadLocal，TransmittableThreadLocal（眼尖的同学可能已经注意到了）这两种实现，上面选用的就是TransmittableThreadLocal，以下是三者的比较：\"></a>敲黑板（需要避免的坑） 现在ThreadLocal除原生实现外，还有InheritableThreadLocal，TransmittableThreadLocal（眼尖的同学可能已经注意到了）这两种实现，上面选用的就是TransmittableThreadLocal，以下是三者的比较：</h3><table>\n<thead>\n<tr>\n<th align=\"left\">实现</th>\n<th align=\"left\">能否在传递到子线程</th>\n<th align=\"left\">使用注意点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">ThreadLocal</td>\n<td align=\"left\">否</td>\n<td align=\"left\">只能在当前线程中获取本地变量</td>\n</tr>\n<tr>\n<td align=\"left\">InheritableThreadLocal</td>\n<td align=\"left\">是</td>\n<td align=\"left\">可获取父线程的中的本地变量，线程池场景不适用，存在线程复用，会导致混</td>\n</tr>\n<tr>\n<td align=\"left\">TransmittableThreadLocal</td>\n<td align=\"left\">是</td>\n<td align=\"left\">可获取父线程中的本地变量，适用线程池场景</td>\n</tr>\n</tbody></table>\n<h3 id=\"测试结果\"><a href=\"#测试结果\" class=\"headerlink\" title=\"测试结果\"></a>测试结果</h3><p>/** * Created by wuxiantao on 2018/7/14. */ public class TransmittableThreadlocalTest {</p>\n<pre><code>private static ThreadLocal&lt;String&gt; transmittableThreadLocal=new TransmittableThreadLocal&lt;&gt;();\n\npublic static void main(String[] args) throws InterruptedException {\n    ThreadPoolExecutor threadPoolExecutor=new ThreadPoolExecutor(3,3,10, TimeUnit.MINUTES, new LinkedBlockingQueue&lt;Runnable&gt;());\n    transmittableThreadLocal.set(&quot;父线程设定的值&quot;);\n    System.out.println(Thread.currentThread().getName()+&quot;====&quot;+transmittableThreadLocal.get());\n\n    for (int i = 0; i &lt; 5; i++) {\n        threadPoolExecutor.submit(TtlCallable.get(new Callable&lt;String&gt;() {\n            public String call() throws Exception {\n                System.out.println(Thread.currentThread().getName()+&quot;------&quot;+transmittableThreadLocal.get());\n                transmittableThreadLocal.set(&quot;我被修改了&quot;);\n                return transmittableThreadLocal.get();\n            }\n        }));\n    }\n}</code></pre><p>}</p>\n<pre><code>&lt;br /&gt;使用transmimttable-threadlocal中TtlCallable.get()提交任务，在子线程中修改Threadlocal,子线程还是会取主线程中的threadlocal</code></pre><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">main====父线程设定的值</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">2</span>------父线程设定的值</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span>------父线程设定的值</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span>------父线程设定的值</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span>------父线程设定的值</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">3</span>------父线程设定的值</span><br></pre></td></tr></table></figure>\n\n<p>`<code>\\</code></p>\n"},{"title":"java8之lamda表达式","date":"2019-06-18T08:47:39.000Z","_content":"\n## lamda表达式 ##\njava8中lamda表达式的引入，标志着java开始拥抱主流函数式编程语言，其实lamda表达式并不是什么新鲜事物，在JavaScript中早已存在。作为经典语言引入lamda表达式以及java8中的其他新特性，如流式处理，会一定程度上让代码更简洁，当然还是无法和JavaScript这类语言相比，但这也正是各自所处的角色的不同决定的。\n## lamda表达式的格式 ##\n1. 参数类型声明：可以不需要声明参数类型，编译器会识别参数值。\n2. 参数圆括号（可选）：在单个参数时可以不使用括号，多个参数时必须使用。\n3. 大括号和return关键字（可选）：如果只有一个表达式，则可以省略大括号和return关键字，编译器会自动的返回值；相对的，在使用大括号的情况下，则必须指明返回值。\n\n## lamda表达式例子 ##\n以Collections.sort为例\n\n    /**\n     * @author xiantao.wu\n     * @create 2018/8/1514:09\n     **/\n    public class TestLamda {\n        public static void main(String[] args) {\n            //原生方法\n            List<Student> students1=getStudentList();\n            Collections.sort(students1, new Comparator<Student>() {\n                @Override\n                public int compare(Student o1, Student o2) {\n                    return o1.getAge().compareTo(o2.getAge());\n                }\n            });\n            students1.forEach(in-> System.out.print(in.getName()+in.getAge()+\"|\"));\n            System.out.println(\"原生方法\");\n    \n    \n            //第一种情况：传入静态方法\n            List<Student> students2=getStudentList();\n            Collections.sort(students2, (s1, s2) -> Student.sortByAgeStatic(s1, s2));\n            students2.forEach(in-> System.out.print(in.getName()+in.getAge()+\"|\"));\n            System.out.println(\"第一种情况：传入静态方法\");\n    \n    \n            //第二种情况：传入实例方法\n            List<Student> students3=getStudentList();\n            Collections.sort(students3, (s1, s2) -> new Student().sortByAgeNonStatic(s1, s2));\n            students3.forEach(in-> System.out.print(in.getName()+in.getAge()+\"|\"));\n            System.out.println(\"第二种情况：传入实例方法\");\n    \n    \n            //第三种请款，不适用大括号\n            List<Student> students4=getStudentList();\n            Collections.sort(students4, (s1, s2) -> s1.getAge().compareTo(s2.getAge()));\n            students4.forEach(in-> System.out.print(in.getName()+in.getAge()+\"|\"));\n            System.out.println(\"第三种请款，不适用大括号\");\n    \n    \n            //第四种情况，使用大括号\n            List<Student> students5=getStudentList();\n            Collections.sort(students5, (s1, s2) -> {\n                return s1.getAge().compareTo(s2.getAge());\n            });\n            students5.forEach(in-> System.out.print(in.getName()+in.getAge()+\"|\"));\n            System.out.println(\"第四种情况，使用大括号\");\n    \n        }\n    \n        private static List<Student> getStudentList() {\n            List<Student> studentList = new ArrayList();\n            for (int i = 0; i < 5; i++) {\n                Student stu = new Student();\n                stu.setAge(new Random().nextInt(10));\n                stu.setName(\"tom\");\n                studentList.add(stu);\n            }\n            return studentList;\n        }\n    \n    \n    }\n    \n    \n    /**\n     * @author xiantao.wu\n     * @create 2018/8/1515:44\n     **/\n    public class Student {\n        private Integer age;\n        private String name;\n    \n    \n        public static int sortByAgeStatic(Student o1, Student o2) {\n            return o1.getAge().compareTo(o2.getAge());\n        }\n    \n    \n        public int sortByAgeNonStatic(Student o1, Student o2) {\n            return o1.getAge().compareTo(o2.getAge());\n        }\n    \n    \n        public Integer getAge() {\n            return age;\n        }\n    \n        public void setAge(Integer age) {\n            this.age = age;\n        }\n    \n        public String getName() {\n            return name;\n        }\n    \n        public void setName(String name) {\n            this.name = name;\n        }\n    }\n    \n### 测试结果： ####\n    tom1|tom2|tom3|tom3|tom9|原生方法\n    tom0|tom0|tom1|tom2|tom4|第一种情况：传入静态方法\n    tom2|tom2|tom3|tom4|tom8|第二种情况：传入实例方法\n    tom1|tom1|tom1|tom4|tom8|第三种请款，不适用大括号\n    tom0|tom1|tom1|tom3|tom7|第四种情况，使用大括号","source":"_posts/java8之lamda表达式.md","raw":"---\ntitle: java8之lamda表达式\ndate: 2019-06-18 16:47:39\ncategories: java基础\ntags:\n---\n\n## lamda表达式 ##\njava8中lamda表达式的引入，标志着java开始拥抱主流函数式编程语言，其实lamda表达式并不是什么新鲜事物，在JavaScript中早已存在。作为经典语言引入lamda表达式以及java8中的其他新特性，如流式处理，会一定程度上让代码更简洁，当然还是无法和JavaScript这类语言相比，但这也正是各自所处的角色的不同决定的。\n## lamda表达式的格式 ##\n1. 参数类型声明：可以不需要声明参数类型，编译器会识别参数值。\n2. 参数圆括号（可选）：在单个参数时可以不使用括号，多个参数时必须使用。\n3. 大括号和return关键字（可选）：如果只有一个表达式，则可以省略大括号和return关键字，编译器会自动的返回值；相对的，在使用大括号的情况下，则必须指明返回值。\n\n## lamda表达式例子 ##\n以Collections.sort为例\n\n    /**\n     * @author xiantao.wu\n     * @create 2018/8/1514:09\n     **/\n    public class TestLamda {\n        public static void main(String[] args) {\n            //原生方法\n            List<Student> students1=getStudentList();\n            Collections.sort(students1, new Comparator<Student>() {\n                @Override\n                public int compare(Student o1, Student o2) {\n                    return o1.getAge().compareTo(o2.getAge());\n                }\n            });\n            students1.forEach(in-> System.out.print(in.getName()+in.getAge()+\"|\"));\n            System.out.println(\"原生方法\");\n    \n    \n            //第一种情况：传入静态方法\n            List<Student> students2=getStudentList();\n            Collections.sort(students2, (s1, s2) -> Student.sortByAgeStatic(s1, s2));\n            students2.forEach(in-> System.out.print(in.getName()+in.getAge()+\"|\"));\n            System.out.println(\"第一种情况：传入静态方法\");\n    \n    \n            //第二种情况：传入实例方法\n            List<Student> students3=getStudentList();\n            Collections.sort(students3, (s1, s2) -> new Student().sortByAgeNonStatic(s1, s2));\n            students3.forEach(in-> System.out.print(in.getName()+in.getAge()+\"|\"));\n            System.out.println(\"第二种情况：传入实例方法\");\n    \n    \n            //第三种请款，不适用大括号\n            List<Student> students4=getStudentList();\n            Collections.sort(students4, (s1, s2) -> s1.getAge().compareTo(s2.getAge()));\n            students4.forEach(in-> System.out.print(in.getName()+in.getAge()+\"|\"));\n            System.out.println(\"第三种请款，不适用大括号\");\n    \n    \n            //第四种情况，使用大括号\n            List<Student> students5=getStudentList();\n            Collections.sort(students5, (s1, s2) -> {\n                return s1.getAge().compareTo(s2.getAge());\n            });\n            students5.forEach(in-> System.out.print(in.getName()+in.getAge()+\"|\"));\n            System.out.println(\"第四种情况，使用大括号\");\n    \n        }\n    \n        private static List<Student> getStudentList() {\n            List<Student> studentList = new ArrayList();\n            for (int i = 0; i < 5; i++) {\n                Student stu = new Student();\n                stu.setAge(new Random().nextInt(10));\n                stu.setName(\"tom\");\n                studentList.add(stu);\n            }\n            return studentList;\n        }\n    \n    \n    }\n    \n    \n    /**\n     * @author xiantao.wu\n     * @create 2018/8/1515:44\n     **/\n    public class Student {\n        private Integer age;\n        private String name;\n    \n    \n        public static int sortByAgeStatic(Student o1, Student o2) {\n            return o1.getAge().compareTo(o2.getAge());\n        }\n    \n    \n        public int sortByAgeNonStatic(Student o1, Student o2) {\n            return o1.getAge().compareTo(o2.getAge());\n        }\n    \n    \n        public Integer getAge() {\n            return age;\n        }\n    \n        public void setAge(Integer age) {\n            this.age = age;\n        }\n    \n        public String getName() {\n            return name;\n        }\n    \n        public void setName(String name) {\n            this.name = name;\n        }\n    }\n    \n### 测试结果： ####\n    tom1|tom2|tom3|tom3|tom9|原生方法\n    tom0|tom0|tom1|tom2|tom4|第一种情况：传入静态方法\n    tom2|tom2|tom3|tom4|tom8|第二种情况：传入实例方法\n    tom1|tom1|tom1|tom4|tom8|第三种请款，不适用大括号\n    tom0|tom1|tom1|tom3|tom7|第四种情况，使用大括号","slug":"java8之lamda表达式","published":1,"updated":"2019-07-02T11:21:32.672Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzjwwm3000kw4j93lwnap30","content":"<h2 id=\"lamda表达式\"><a href=\"#lamda表达式\" class=\"headerlink\" title=\"lamda表达式\"></a>lamda表达式</h2><p>java8中lamda表达式的引入，标志着java开始拥抱主流函数式编程语言，其实lamda表达式并不是什么新鲜事物，在JavaScript中早已存在。作为经典语言引入lamda表达式以及java8中的其他新特性，如流式处理，会一定程度上让代码更简洁，当然还是无法和JavaScript这类语言相比，但这也正是各自所处的角色的不同决定的。</p>\n<h2 id=\"lamda表达式的格式\"><a href=\"#lamda表达式的格式\" class=\"headerlink\" title=\"lamda表达式的格式\"></a>lamda表达式的格式</h2><ol>\n<li>参数类型声明：可以不需要声明参数类型，编译器会识别参数值。</li>\n<li>参数圆括号（可选）：在单个参数时可以不使用括号，多个参数时必须使用。</li>\n<li>大括号和return关键字（可选）：如果只有一个表达式，则可以省略大括号和return关键字，编译器会自动的返回值；相对的，在使用大括号的情况下，则必须指明返回值。</li>\n</ol>\n<h2 id=\"lamda表达式例子\"><a href=\"#lamda表达式例子\" class=\"headerlink\" title=\"lamda表达式例子\"></a>lamda表达式例子</h2><p>以Collections.sort为例</p>\n<pre><code>/**\n * @author xiantao.wu\n * @create 2018/8/1514:09\n **/\npublic class TestLamda {\n    public static void main(String[] args) {\n        //原生方法\n        List&lt;Student&gt; students1=getStudentList();\n        Collections.sort(students1, new Comparator&lt;Student&gt;() {\n            @Override\n            public int compare(Student o1, Student o2) {\n                return o1.getAge().compareTo(o2.getAge());\n            }\n        });\n        students1.forEach(in-&gt; System.out.print(in.getName()+in.getAge()+&quot;|&quot;));\n        System.out.println(&quot;原生方法&quot;);\n\n\n        //第一种情况：传入静态方法\n        List&lt;Student&gt; students2=getStudentList();\n        Collections.sort(students2, (s1, s2) -&gt; Student.sortByAgeStatic(s1, s2));\n        students2.forEach(in-&gt; System.out.print(in.getName()+in.getAge()+&quot;|&quot;));\n        System.out.println(&quot;第一种情况：传入静态方法&quot;);\n\n\n        //第二种情况：传入实例方法\n        List&lt;Student&gt; students3=getStudentList();\n        Collections.sort(students3, (s1, s2) -&gt; new Student().sortByAgeNonStatic(s1, s2));\n        students3.forEach(in-&gt; System.out.print(in.getName()+in.getAge()+&quot;|&quot;));\n        System.out.println(&quot;第二种情况：传入实例方法&quot;);\n\n\n        //第三种请款，不适用大括号\n        List&lt;Student&gt; students4=getStudentList();\n        Collections.sort(students4, (s1, s2) -&gt; s1.getAge().compareTo(s2.getAge()));\n        students4.forEach(in-&gt; System.out.print(in.getName()+in.getAge()+&quot;|&quot;));\n        System.out.println(&quot;第三种请款，不适用大括号&quot;);\n\n\n        //第四种情况，使用大括号\n        List&lt;Student&gt; students5=getStudentList();\n        Collections.sort(students5, (s1, s2) -&gt; {\n            return s1.getAge().compareTo(s2.getAge());\n        });\n        students5.forEach(in-&gt; System.out.print(in.getName()+in.getAge()+&quot;|&quot;));\n        System.out.println(&quot;第四种情况，使用大括号&quot;);\n\n    }\n\n    private static List&lt;Student&gt; getStudentList() {\n        List&lt;Student&gt; studentList = new ArrayList();\n        for (int i = 0; i &lt; 5; i++) {\n            Student stu = new Student();\n            stu.setAge(new Random().nextInt(10));\n            stu.setName(&quot;tom&quot;);\n            studentList.add(stu);\n        }\n        return studentList;\n    }\n\n\n}\n\n\n/**\n * @author xiantao.wu\n * @create 2018/8/1515:44\n **/\npublic class Student {\n    private Integer age;\n    private String name;\n\n\n    public static int sortByAgeStatic(Student o1, Student o2) {\n        return o1.getAge().compareTo(o2.getAge());\n    }\n\n\n    public int sortByAgeNonStatic(Student o1, Student o2) {\n        return o1.getAge().compareTo(o2.getAge());\n    }\n\n\n    public Integer getAge() {\n        return age;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}</code></pre><h3 id=\"测试结果：\"><a href=\"#测试结果：\" class=\"headerlink\" title=\"测试结果：\"></a>测试结果：</h3><pre><code>tom1|tom2|tom3|tom3|tom9|原生方法\ntom0|tom0|tom1|tom2|tom4|第一种情况：传入静态方法\ntom2|tom2|tom3|tom4|tom8|第二种情况：传入实例方法\ntom1|tom1|tom1|tom4|tom8|第三种请款，不适用大括号\ntom0|tom1|tom1|tom3|tom7|第四种情况，使用大括号</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"lamda表达式\"><a href=\"#lamda表达式\" class=\"headerlink\" title=\"lamda表达式\"></a>lamda表达式</h2><p>java8中lamda表达式的引入，标志着java开始拥抱主流函数式编程语言，其实lamda表达式并不是什么新鲜事物，在JavaScript中早已存在。作为经典语言引入lamda表达式以及java8中的其他新特性，如流式处理，会一定程度上让代码更简洁，当然还是无法和JavaScript这类语言相比，但这也正是各自所处的角色的不同决定的。</p>\n<h2 id=\"lamda表达式的格式\"><a href=\"#lamda表达式的格式\" class=\"headerlink\" title=\"lamda表达式的格式\"></a>lamda表达式的格式</h2><ol>\n<li>参数类型声明：可以不需要声明参数类型，编译器会识别参数值。</li>\n<li>参数圆括号（可选）：在单个参数时可以不使用括号，多个参数时必须使用。</li>\n<li>大括号和return关键字（可选）：如果只有一个表达式，则可以省略大括号和return关键字，编译器会自动的返回值；相对的，在使用大括号的情况下，则必须指明返回值。</li>\n</ol>\n<h2 id=\"lamda表达式例子\"><a href=\"#lamda表达式例子\" class=\"headerlink\" title=\"lamda表达式例子\"></a>lamda表达式例子</h2><p>以Collections.sort为例</p>\n<pre><code>/**\n * @author xiantao.wu\n * @create 2018/8/1514:09\n **/\npublic class TestLamda {\n    public static void main(String[] args) {\n        //原生方法\n        List&lt;Student&gt; students1=getStudentList();\n        Collections.sort(students1, new Comparator&lt;Student&gt;() {\n            @Override\n            public int compare(Student o1, Student o2) {\n                return o1.getAge().compareTo(o2.getAge());\n            }\n        });\n        students1.forEach(in-&gt; System.out.print(in.getName()+in.getAge()+&quot;|&quot;));\n        System.out.println(&quot;原生方法&quot;);\n\n\n        //第一种情况：传入静态方法\n        List&lt;Student&gt; students2=getStudentList();\n        Collections.sort(students2, (s1, s2) -&gt; Student.sortByAgeStatic(s1, s2));\n        students2.forEach(in-&gt; System.out.print(in.getName()+in.getAge()+&quot;|&quot;));\n        System.out.println(&quot;第一种情况：传入静态方法&quot;);\n\n\n        //第二种情况：传入实例方法\n        List&lt;Student&gt; students3=getStudentList();\n        Collections.sort(students3, (s1, s2) -&gt; new Student().sortByAgeNonStatic(s1, s2));\n        students3.forEach(in-&gt; System.out.print(in.getName()+in.getAge()+&quot;|&quot;));\n        System.out.println(&quot;第二种情况：传入实例方法&quot;);\n\n\n        //第三种请款，不适用大括号\n        List&lt;Student&gt; students4=getStudentList();\n        Collections.sort(students4, (s1, s2) -&gt; s1.getAge().compareTo(s2.getAge()));\n        students4.forEach(in-&gt; System.out.print(in.getName()+in.getAge()+&quot;|&quot;));\n        System.out.println(&quot;第三种请款，不适用大括号&quot;);\n\n\n        //第四种情况，使用大括号\n        List&lt;Student&gt; students5=getStudentList();\n        Collections.sort(students5, (s1, s2) -&gt; {\n            return s1.getAge().compareTo(s2.getAge());\n        });\n        students5.forEach(in-&gt; System.out.print(in.getName()+in.getAge()+&quot;|&quot;));\n        System.out.println(&quot;第四种情况，使用大括号&quot;);\n\n    }\n\n    private static List&lt;Student&gt; getStudentList() {\n        List&lt;Student&gt; studentList = new ArrayList();\n        for (int i = 0; i &lt; 5; i++) {\n            Student stu = new Student();\n            stu.setAge(new Random().nextInt(10));\n            stu.setName(&quot;tom&quot;);\n            studentList.add(stu);\n        }\n        return studentList;\n    }\n\n\n}\n\n\n/**\n * @author xiantao.wu\n * @create 2018/8/1515:44\n **/\npublic class Student {\n    private Integer age;\n    private String name;\n\n\n    public static int sortByAgeStatic(Student o1, Student o2) {\n        return o1.getAge().compareTo(o2.getAge());\n    }\n\n\n    public int sortByAgeNonStatic(Student o1, Student o2) {\n        return o1.getAge().compareTo(o2.getAge());\n    }\n\n\n    public Integer getAge() {\n        return age;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}</code></pre><h3 id=\"测试结果：\"><a href=\"#测试结果：\" class=\"headerlink\" title=\"测试结果：\"></a>测试结果：</h3><pre><code>tom1|tom2|tom3|tom3|tom9|原生方法\ntom0|tom0|tom1|tom2|tom4|第一种情况：传入静态方法\ntom2|tom2|tom3|tom4|tom8|第二种情况：传入实例方法\ntom1|tom1|tom1|tom4|tom8|第三种请款，不适用大括号\ntom0|tom1|tom1|tom3|tom7|第四种情况，使用大括号</code></pre>"},{"title":"java多线程之FutureTask","date":"2019-07-01T13:14:54.000Z","_content":"\n## FutureTask和Future\n\n### Future\n#### Future接口主要方法：\n```\n    boolean cancel(boolean mayInterruptIfRunning);\n\n    boolean isCancelled();\n\n    boolean isDone();\n\n    V get() throws InterruptedException, ExecutionException;\n\n    V get(long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutException;\n```\n\n\n### FutureTask\nFutureTask是Future的实现类，它提供了对Future的基本实现。可使用FutureTask包装Callable或Runnable对象，因为FutureTask实现了Runnable，所以也可以将FutureTask提交给Executor\n\n#### FutureTask的几种状态\nFutureTask实现了Runnable和Future接口。因此，FutureTask可以交给\nExecutor执行，也可以由调用线程直接执行（FutureTask.run()）。根据FutureTask.run()方法被执行\n的时机，FutureTask可以处于下面3种状态。\n1. 未启动:FutureTask.run()方法还没有被执行之前，FutureTask处于未启动状态。当创建一\n个FutureTask，且没有执行FutureTask.run()方法之前，这个FutureTask处于未启动状态。\n2. 已启动:FutureTask.run()方法被执行的过程中，FutureTask处于已启动状态。\n3. 已完成:此状态有三种情况\n    - 正常结束：FutureTask.run()方法执行完后。\n    - 被取消：FutureTask.cancel（…）\n    - 异常结束： 执行FutureTask.run()方法时抛出异常而异常结束，FutureTask处于已完成状态\n\n#### FutureTask中get和cancel\n1. get方法：`V get() throws InterruptedException, ExecutionException;`\n    - 当FutureTask处于未启动或已启动状态时，执行FutureTask.get()方法将导致调用线程阻塞；\n    -  当FutureTask处于已完成状态，调用FutureTask.get()方法将导致调用线程立即返回结果或者抛出异常。\n 2. cancel方法: `boolean cancel(boolean mayInterruptIfRunning);`\n    - 当FutureTask处于未启动状态时，执行FutureTask.cancel()方法将导致此任务永远不会被执行；\n    - 当FutureTask处于已启动状态时，执行FutureTask.cancel（true）方法将以中断执行此任务线程的方式来试图停止任务；\n    - 当FutureTask处于已启动状态时，执行FutureTask.cancel（false）方法将不会对正在执行此任务的线程产生影响（让正在执行的任务运行完成）；\n    - 当FutureTask处于已完成状态时，执行FutureTask.cancel（…）方法将返回false。\n3. get和cancel执行示例图\n![FutureTask的get和cancel的执行示意图.jpg](/source/images/jus/FutureTask1.png)\n\n#### FutureTask和Future的使用\nCallable、Future、FutureTask一般都是和线程池配合使用的,以下是常用方法：\n```\n <T> Future<T> submit(Callable<T> task);\n <T> Future<T> submit(Runnable task, T result);\n <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)throws InterruptedException;\n <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,long timeout, TimeUnit unit)throws  InterruptedException;\n```\n\n\n 1. Callable+Future使用示例\n ```\n public class FutureTaskTest {\n    static class CallableTask implements Callable<String> {\n        private Integer sleepTime;\n\n        public CallableTask(Integer sleepTime) {\n            this.sleepTime = sleepTime;\n        }\n\n        @Override\n        public String call() throws Exception {\n            System.out.println(Thread.currentThread().getName()+\"--begin--\"+System.currentTimeMillis());\n            Thread.sleep(sleepTime);\n            System.out.println(Thread.currentThread().getName()+\"-------end--\"+System.currentTimeMillis());\n            return Thread.currentThread().getName();\n        }\n    }\n\n    public static void main(String[] args) {\n\n        ExecutorService executorService = Executors.newFixedThreadPool(3);\n\n        List<Callable<String>> callableList = new ArrayList<>();\n        callableList.add(new CallableTask(2000));\n        callableList.add(new CallableTask(5000));\n        callableList.add(new CallableTask(2000));\n\n        try {\n            List<Future<String>> futures = executorService.invokeAll(callableList);\n            System.out.println(\"return future--\"+System.currentTimeMillis());\n            for (Future future : futures) {\n                System.out.println(future.get() + \"--get---\"+System.currentTimeMillis());\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        System.out.println(\"main thread compelete\");\n        executorService.shutdown();\n    }\n}\nconsole result:\npool-1-thread-1--begin--1561992318002\npool-1-thread-3--begin--1561992318002\npool-1-thread-2--begin--1561992318002\npool-1-thread-3-------end--1561992320003\npool-1-thread-1-------end--1561992320003\npool-1-thread-2-------end--1561992323003\nreturn future--1561992323003\npool-1-thread-1--get---1561992323003\npool-1-thread-2--get---1561992323004\npool-1-thread-3--get---1561992323004\n ```\n\n 2. Callable+FutureTask使用示例\n ```\npublic static class CallableThread implements Callable<String>\n{\n    public String call() throws Exception\n    {\n        System.out.println(\"进入CallableThread的call()方法, 开始睡觉, 睡觉时间为\" + System.currentTimeMillis());\n        Thread.sleep(10000);\n        return \"123\";\n    }\n}\n    \npublic static void main(String[] args) throws Exception\n{\n    ExecutorService es = Executors.newCachedThreadPool();\n    CallableThread ct = new CallableThread();\n    FutureTask<String> f = new FutureTask<String>(ct);\n    es.submit(f);\n    es.shutdown();\n        \n    Thread.sleep(5000);\n    System.out.println(\"主线程等待5秒, 当前时间为\" + System.currentTimeMillis());\n        \n    String str = f.get();\n    System.out.println(\"Future已拿到数据, str = \" + str + \", 当前时间为\" + System.currentTimeMillis());\n}\n ```\n Callable+Future的方式，es.submit(ct)方法返回的Future，底层实现new出来的是一个FutureTask\n\n\n \n\n","source":"_posts/java多线程之FutureTask-Future和Callable.md","raw":"---\ntitle: 'java多线程之FutureTask'\ndate: 2019-07-01 21:14:54\ncategories: java多线程\ntags: java\n---\n\n## FutureTask和Future\n\n### Future\n#### Future接口主要方法：\n```\n    boolean cancel(boolean mayInterruptIfRunning);\n\n    boolean isCancelled();\n\n    boolean isDone();\n\n    V get() throws InterruptedException, ExecutionException;\n\n    V get(long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutException;\n```\n\n\n### FutureTask\nFutureTask是Future的实现类，它提供了对Future的基本实现。可使用FutureTask包装Callable或Runnable对象，因为FutureTask实现了Runnable，所以也可以将FutureTask提交给Executor\n\n#### FutureTask的几种状态\nFutureTask实现了Runnable和Future接口。因此，FutureTask可以交给\nExecutor执行，也可以由调用线程直接执行（FutureTask.run()）。根据FutureTask.run()方法被执行\n的时机，FutureTask可以处于下面3种状态。\n1. 未启动:FutureTask.run()方法还没有被执行之前，FutureTask处于未启动状态。当创建一\n个FutureTask，且没有执行FutureTask.run()方法之前，这个FutureTask处于未启动状态。\n2. 已启动:FutureTask.run()方法被执行的过程中，FutureTask处于已启动状态。\n3. 已完成:此状态有三种情况\n    - 正常结束：FutureTask.run()方法执行完后。\n    - 被取消：FutureTask.cancel（…）\n    - 异常结束： 执行FutureTask.run()方法时抛出异常而异常结束，FutureTask处于已完成状态\n\n#### FutureTask中get和cancel\n1. get方法：`V get() throws InterruptedException, ExecutionException;`\n    - 当FutureTask处于未启动或已启动状态时，执行FutureTask.get()方法将导致调用线程阻塞；\n    -  当FutureTask处于已完成状态，调用FutureTask.get()方法将导致调用线程立即返回结果或者抛出异常。\n 2. cancel方法: `boolean cancel(boolean mayInterruptIfRunning);`\n    - 当FutureTask处于未启动状态时，执行FutureTask.cancel()方法将导致此任务永远不会被执行；\n    - 当FutureTask处于已启动状态时，执行FutureTask.cancel（true）方法将以中断执行此任务线程的方式来试图停止任务；\n    - 当FutureTask处于已启动状态时，执行FutureTask.cancel（false）方法将不会对正在执行此任务的线程产生影响（让正在执行的任务运行完成）；\n    - 当FutureTask处于已完成状态时，执行FutureTask.cancel（…）方法将返回false。\n3. get和cancel执行示例图\n![FutureTask的get和cancel的执行示意图.jpg](/source/images/jus/FutureTask1.png)\n\n#### FutureTask和Future的使用\nCallable、Future、FutureTask一般都是和线程池配合使用的,以下是常用方法：\n```\n <T> Future<T> submit(Callable<T> task);\n <T> Future<T> submit(Runnable task, T result);\n <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)throws InterruptedException;\n <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,long timeout, TimeUnit unit)throws  InterruptedException;\n```\n\n\n 1. Callable+Future使用示例\n ```\n public class FutureTaskTest {\n    static class CallableTask implements Callable<String> {\n        private Integer sleepTime;\n\n        public CallableTask(Integer sleepTime) {\n            this.sleepTime = sleepTime;\n        }\n\n        @Override\n        public String call() throws Exception {\n            System.out.println(Thread.currentThread().getName()+\"--begin--\"+System.currentTimeMillis());\n            Thread.sleep(sleepTime);\n            System.out.println(Thread.currentThread().getName()+\"-------end--\"+System.currentTimeMillis());\n            return Thread.currentThread().getName();\n        }\n    }\n\n    public static void main(String[] args) {\n\n        ExecutorService executorService = Executors.newFixedThreadPool(3);\n\n        List<Callable<String>> callableList = new ArrayList<>();\n        callableList.add(new CallableTask(2000));\n        callableList.add(new CallableTask(5000));\n        callableList.add(new CallableTask(2000));\n\n        try {\n            List<Future<String>> futures = executorService.invokeAll(callableList);\n            System.out.println(\"return future--\"+System.currentTimeMillis());\n            for (Future future : futures) {\n                System.out.println(future.get() + \"--get---\"+System.currentTimeMillis());\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        System.out.println(\"main thread compelete\");\n        executorService.shutdown();\n    }\n}\nconsole result:\npool-1-thread-1--begin--1561992318002\npool-1-thread-3--begin--1561992318002\npool-1-thread-2--begin--1561992318002\npool-1-thread-3-------end--1561992320003\npool-1-thread-1-------end--1561992320003\npool-1-thread-2-------end--1561992323003\nreturn future--1561992323003\npool-1-thread-1--get---1561992323003\npool-1-thread-2--get---1561992323004\npool-1-thread-3--get---1561992323004\n ```\n\n 2. Callable+FutureTask使用示例\n ```\npublic static class CallableThread implements Callable<String>\n{\n    public String call() throws Exception\n    {\n        System.out.println(\"进入CallableThread的call()方法, 开始睡觉, 睡觉时间为\" + System.currentTimeMillis());\n        Thread.sleep(10000);\n        return \"123\";\n    }\n}\n    \npublic static void main(String[] args) throws Exception\n{\n    ExecutorService es = Executors.newCachedThreadPool();\n    CallableThread ct = new CallableThread();\n    FutureTask<String> f = new FutureTask<String>(ct);\n    es.submit(f);\n    es.shutdown();\n        \n    Thread.sleep(5000);\n    System.out.println(\"主线程等待5秒, 当前时间为\" + System.currentTimeMillis());\n        \n    String str = f.get();\n    System.out.println(\"Future已拿到数据, str = \" + str + \", 当前时间为\" + System.currentTimeMillis());\n}\n ```\n Callable+Future的方式，es.submit(ct)方法返回的Future，底层实现new出来的是一个FutureTask\n\n\n \n\n","slug":"java多线程之FutureTask-Future和Callable","published":1,"updated":"2019-07-02T11:21:32.674Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzjwwm4000lw4j9vl77pziy","content":"<h2 id=\"FutureTask和Future\"><a href=\"#FutureTask和Future\" class=\"headerlink\" title=\"FutureTask和Future\"></a>FutureTask和Future</h2><h3 id=\"Future\"><a href=\"#Future\" class=\"headerlink\" title=\"Future\"></a>Future</h3><h4 id=\"Future接口主要方法：\"><a href=\"#Future接口主要方法：\" class=\"headerlink\" title=\"Future接口主要方法：\"></a>Future接口主要方法：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">boolean cancel(boolean mayInterruptIfRunning);</span><br><span class=\"line\"></span><br><span class=\"line\">boolean isCancelled();</span><br><span class=\"line\"></span><br><span class=\"line\">boolean isDone();</span><br><span class=\"line\"></span><br><span class=\"line\">V get() throws InterruptedException, ExecutionException;</span><br><span class=\"line\"></span><br><span class=\"line\">V get(long timeout, TimeUnit unit)</span><br><span class=\"line\">    throws InterruptedException, ExecutionException, TimeoutException;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"FutureTask\"><a href=\"#FutureTask\" class=\"headerlink\" title=\"FutureTask\"></a>FutureTask</h3><p>FutureTask是Future的实现类，它提供了对Future的基本实现。可使用FutureTask包装Callable或Runnable对象，因为FutureTask实现了Runnable，所以也可以将FutureTask提交给Executor</p>\n<h4 id=\"FutureTask的几种状态\"><a href=\"#FutureTask的几种状态\" class=\"headerlink\" title=\"FutureTask的几种状态\"></a>FutureTask的几种状态</h4><p>FutureTask实现了Runnable和Future接口。因此，FutureTask可以交给<br>Executor执行，也可以由调用线程直接执行（FutureTask.run()）。根据FutureTask.run()方法被执行<br>的时机，FutureTask可以处于下面3种状态。</p>\n<ol>\n<li>未启动:FutureTask.run()方法还没有被执行之前，FutureTask处于未启动状态。当创建一<br>个FutureTask，且没有执行FutureTask.run()方法之前，这个FutureTask处于未启动状态。</li>\n<li>已启动:FutureTask.run()方法被执行的过程中，FutureTask处于已启动状态。</li>\n<li>已完成:此状态有三种情况<ul>\n<li>正常结束：FutureTask.run()方法执行完后。</li>\n<li>被取消：FutureTask.cancel（…）</li>\n<li>异常结束： 执行FutureTask.run()方法时抛出异常而异常结束，FutureTask处于已完成状态</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"FutureTask中get和cancel\"><a href=\"#FutureTask中get和cancel\" class=\"headerlink\" title=\"FutureTask中get和cancel\"></a>FutureTask中get和cancel</h4><ol>\n<li>get方法：<code>V get() throws InterruptedException, ExecutionException;</code><ul>\n<li>当FutureTask处于未启动或已启动状态时，执行FutureTask.get()方法将导致调用线程阻塞；</li>\n<li>当FutureTask处于已完成状态，调用FutureTask.get()方法将导致调用线程立即返回结果或者抛出异常。<ol start=\"2\">\n<li>cancel方法: <code>boolean cancel(boolean mayInterruptIfRunning);</code></li>\n</ol>\n</li>\n<li>当FutureTask处于未启动状态时，执行FutureTask.cancel()方法将导致此任务永远不会被执行；</li>\n<li>当FutureTask处于已启动状态时，执行FutureTask.cancel（true）方法将以中断执行此任务线程的方式来试图停止任务；</li>\n<li>当FutureTask处于已启动状态时，执行FutureTask.cancel（false）方法将不会对正在执行此任务的线程产生影响（让正在执行的任务运行完成）；</li>\n<li>当FutureTask处于已完成状态时，执行FutureTask.cancel（…）方法将返回false。</li>\n</ul>\n</li>\n<li>get和cancel执行示例图<br><img src=\"/source/images/jus/FutureTask1.png\" alt=\"FutureTask的get和cancel的执行示意图.jpg\"></li>\n</ol>\n<h4 id=\"FutureTask和Future的使用\"><a href=\"#FutureTask和Future的使用\" class=\"headerlink\" title=\"FutureTask和Future的使用\"></a>FutureTask和Future的使用</h4><p>Callable、Future、FutureTask一般都是和线程池配合使用的,以下是常用方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</span><br><span class=\"line\">&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</span><br><span class=\"line\">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)throws InterruptedException;</span><br><span class=\"line\">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,long timeout, TimeUnit unit)throws  InterruptedException;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>Callable+Future使用示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> public class FutureTaskTest &#123;</span><br><span class=\"line\">    static class CallableTask implements Callable&lt;String&gt; &#123;</span><br><span class=\"line\">        private Integer sleepTime;</span><br><span class=\"line\"></span><br><span class=\"line\">        public CallableTask(Integer sleepTime) &#123;</span><br><span class=\"line\">            this.sleepTime = sleepTime;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public String call() throws Exception &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName()+&quot;--begin--&quot;+System.currentTimeMillis());</span><br><span class=\"line\">            Thread.sleep(sleepTime);</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName()+&quot;-------end--&quot;+System.currentTimeMillis());</span><br><span class=\"line\">            return Thread.currentThread().getName();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ExecutorService executorService = Executors.newFixedThreadPool(3);</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;Callable&lt;String&gt;&gt; callableList = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        callableList.add(new CallableTask(2000));</span><br><span class=\"line\">        callableList.add(new CallableTask(5000));</span><br><span class=\"line\">        callableList.add(new CallableTask(2000));</span><br><span class=\"line\"></span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            List&lt;Future&lt;String&gt;&gt; futures = executorService.invokeAll(callableList);</span><br><span class=\"line\">            System.out.println(&quot;return future--&quot;+System.currentTimeMillis());</span><br><span class=\"line\">            for (Future future : futures) &#123;</span><br><span class=\"line\">                System.out.println(future.get() + &quot;--get---&quot;+System.currentTimeMillis());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(&quot;main thread compelete&quot;);</span><br><span class=\"line\">        executorService.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console result:</span><br><span class=\"line\">pool-1-thread-1--begin--1561992318002</span><br><span class=\"line\">pool-1-thread-3--begin--1561992318002</span><br><span class=\"line\">pool-1-thread-2--begin--1561992318002</span><br><span class=\"line\">pool-1-thread-3-------end--1561992320003</span><br><span class=\"line\">pool-1-thread-1-------end--1561992320003</span><br><span class=\"line\">pool-1-thread-2-------end--1561992323003</span><br><span class=\"line\">return future--1561992323003</span><br><span class=\"line\">pool-1-thread-1--get---1561992323003</span><br><span class=\"line\">pool-1-thread-2--get---1561992323004</span><br><span class=\"line\">pool-1-thread-3--get---1561992323004</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Callable+FutureTask使用示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static class CallableThread implements Callable&lt;String&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public String call() throws Exception</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.println(&quot;进入CallableThread的call()方法, 开始睡觉, 睡觉时间为&quot; + System.currentTimeMillis());</span><br><span class=\"line\">        Thread.sleep(10000);</span><br><span class=\"line\">        return &quot;123&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">public static void main(String[] args) throws Exception</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ExecutorService es = Executors.newCachedThreadPool();</span><br><span class=\"line\">    CallableThread ct = new CallableThread();</span><br><span class=\"line\">    FutureTask&lt;String&gt; f = new FutureTask&lt;String&gt;(ct);</span><br><span class=\"line\">    es.submit(f);</span><br><span class=\"line\">    es.shutdown();</span><br><span class=\"line\">        </span><br><span class=\"line\">    Thread.sleep(5000);</span><br><span class=\"line\">    System.out.println(&quot;主线程等待5秒, 当前时间为&quot; + System.currentTimeMillis());</span><br><span class=\"line\">        </span><br><span class=\"line\">    String str = f.get();</span><br><span class=\"line\">    System.out.println(&quot;Future已拿到数据, str = &quot; + str + &quot;, 当前时间为&quot; + System.currentTimeMillis());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Callable+Future的方式，es.submit(ct)方法返回的Future，底层实现new出来的是一个FutureTask</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"FutureTask和Future\"><a href=\"#FutureTask和Future\" class=\"headerlink\" title=\"FutureTask和Future\"></a>FutureTask和Future</h2><h3 id=\"Future\"><a href=\"#Future\" class=\"headerlink\" title=\"Future\"></a>Future</h3><h4 id=\"Future接口主要方法：\"><a href=\"#Future接口主要方法：\" class=\"headerlink\" title=\"Future接口主要方法：\"></a>Future接口主要方法：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">boolean cancel(boolean mayInterruptIfRunning);</span><br><span class=\"line\"></span><br><span class=\"line\">boolean isCancelled();</span><br><span class=\"line\"></span><br><span class=\"line\">boolean isDone();</span><br><span class=\"line\"></span><br><span class=\"line\">V get() throws InterruptedException, ExecutionException;</span><br><span class=\"line\"></span><br><span class=\"line\">V get(long timeout, TimeUnit unit)</span><br><span class=\"line\">    throws InterruptedException, ExecutionException, TimeoutException;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"FutureTask\"><a href=\"#FutureTask\" class=\"headerlink\" title=\"FutureTask\"></a>FutureTask</h3><p>FutureTask是Future的实现类，它提供了对Future的基本实现。可使用FutureTask包装Callable或Runnable对象，因为FutureTask实现了Runnable，所以也可以将FutureTask提交给Executor</p>\n<h4 id=\"FutureTask的几种状态\"><a href=\"#FutureTask的几种状态\" class=\"headerlink\" title=\"FutureTask的几种状态\"></a>FutureTask的几种状态</h4><p>FutureTask实现了Runnable和Future接口。因此，FutureTask可以交给<br>Executor执行，也可以由调用线程直接执行（FutureTask.run()）。根据FutureTask.run()方法被执行<br>的时机，FutureTask可以处于下面3种状态。</p>\n<ol>\n<li>未启动:FutureTask.run()方法还没有被执行之前，FutureTask处于未启动状态。当创建一<br>个FutureTask，且没有执行FutureTask.run()方法之前，这个FutureTask处于未启动状态。</li>\n<li>已启动:FutureTask.run()方法被执行的过程中，FutureTask处于已启动状态。</li>\n<li>已完成:此状态有三种情况<ul>\n<li>正常结束：FutureTask.run()方法执行完后。</li>\n<li>被取消：FutureTask.cancel（…）</li>\n<li>异常结束： 执行FutureTask.run()方法时抛出异常而异常结束，FutureTask处于已完成状态</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"FutureTask中get和cancel\"><a href=\"#FutureTask中get和cancel\" class=\"headerlink\" title=\"FutureTask中get和cancel\"></a>FutureTask中get和cancel</h4><ol>\n<li>get方法：<code>V get() throws InterruptedException, ExecutionException;</code><ul>\n<li>当FutureTask处于未启动或已启动状态时，执行FutureTask.get()方法将导致调用线程阻塞；</li>\n<li>当FutureTask处于已完成状态，调用FutureTask.get()方法将导致调用线程立即返回结果或者抛出异常。<ol start=\"2\">\n<li>cancel方法: <code>boolean cancel(boolean mayInterruptIfRunning);</code></li>\n</ol>\n</li>\n<li>当FutureTask处于未启动状态时，执行FutureTask.cancel()方法将导致此任务永远不会被执行；</li>\n<li>当FutureTask处于已启动状态时，执行FutureTask.cancel（true）方法将以中断执行此任务线程的方式来试图停止任务；</li>\n<li>当FutureTask处于已启动状态时，执行FutureTask.cancel（false）方法将不会对正在执行此任务的线程产生影响（让正在执行的任务运行完成）；</li>\n<li>当FutureTask处于已完成状态时，执行FutureTask.cancel（…）方法将返回false。</li>\n</ul>\n</li>\n<li>get和cancel执行示例图<br><img src=\"/source/images/jus/FutureTask1.png\" alt=\"FutureTask的get和cancel的执行示意图.jpg\"></li>\n</ol>\n<h4 id=\"FutureTask和Future的使用\"><a href=\"#FutureTask和Future的使用\" class=\"headerlink\" title=\"FutureTask和Future的使用\"></a>FutureTask和Future的使用</h4><p>Callable、Future、FutureTask一般都是和线程池配合使用的,以下是常用方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</span><br><span class=\"line\">&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</span><br><span class=\"line\">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)throws InterruptedException;</span><br><span class=\"line\">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,long timeout, TimeUnit unit)throws  InterruptedException;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p>Callable+Future使用示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> public class FutureTaskTest &#123;</span><br><span class=\"line\">    static class CallableTask implements Callable&lt;String&gt; &#123;</span><br><span class=\"line\">        private Integer sleepTime;</span><br><span class=\"line\"></span><br><span class=\"line\">        public CallableTask(Integer sleepTime) &#123;</span><br><span class=\"line\">            this.sleepTime = sleepTime;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public String call() throws Exception &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName()+&quot;--begin--&quot;+System.currentTimeMillis());</span><br><span class=\"line\">            Thread.sleep(sleepTime);</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName()+&quot;-------end--&quot;+System.currentTimeMillis());</span><br><span class=\"line\">            return Thread.currentThread().getName();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        ExecutorService executorService = Executors.newFixedThreadPool(3);</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;Callable&lt;String&gt;&gt; callableList = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        callableList.add(new CallableTask(2000));</span><br><span class=\"line\">        callableList.add(new CallableTask(5000));</span><br><span class=\"line\">        callableList.add(new CallableTask(2000));</span><br><span class=\"line\"></span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            List&lt;Future&lt;String&gt;&gt; futures = executorService.invokeAll(callableList);</span><br><span class=\"line\">            System.out.println(&quot;return future--&quot;+System.currentTimeMillis());</span><br><span class=\"line\">            for (Future future : futures) &#123;</span><br><span class=\"line\">                System.out.println(future.get() + &quot;--get---&quot;+System.currentTimeMillis());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(&quot;main thread compelete&quot;);</span><br><span class=\"line\">        executorService.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console result:</span><br><span class=\"line\">pool-1-thread-1--begin--1561992318002</span><br><span class=\"line\">pool-1-thread-3--begin--1561992318002</span><br><span class=\"line\">pool-1-thread-2--begin--1561992318002</span><br><span class=\"line\">pool-1-thread-3-------end--1561992320003</span><br><span class=\"line\">pool-1-thread-1-------end--1561992320003</span><br><span class=\"line\">pool-1-thread-2-------end--1561992323003</span><br><span class=\"line\">return future--1561992323003</span><br><span class=\"line\">pool-1-thread-1--get---1561992323003</span><br><span class=\"line\">pool-1-thread-2--get---1561992323004</span><br><span class=\"line\">pool-1-thread-3--get---1561992323004</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Callable+FutureTask使用示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static class CallableThread implements Callable&lt;String&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public String call() throws Exception</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        System.out.println(&quot;进入CallableThread的call()方法, 开始睡觉, 睡觉时间为&quot; + System.currentTimeMillis());</span><br><span class=\"line\">        Thread.sleep(10000);</span><br><span class=\"line\">        return &quot;123&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">public static void main(String[] args) throws Exception</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ExecutorService es = Executors.newCachedThreadPool();</span><br><span class=\"line\">    CallableThread ct = new CallableThread();</span><br><span class=\"line\">    FutureTask&lt;String&gt; f = new FutureTask&lt;String&gt;(ct);</span><br><span class=\"line\">    es.submit(f);</span><br><span class=\"line\">    es.shutdown();</span><br><span class=\"line\">        </span><br><span class=\"line\">    Thread.sleep(5000);</span><br><span class=\"line\">    System.out.println(&quot;主线程等待5秒, 当前时间为&quot; + System.currentTimeMillis());</span><br><span class=\"line\">        </span><br><span class=\"line\">    String str = f.get();</span><br><span class=\"line\">    System.out.println(&quot;Future已拿到数据, str = &quot; + str + &quot;, 当前时间为&quot; + System.currentTimeMillis());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Callable+Future的方式，es.submit(ct)方法返回的Future，底层实现new出来的是一个FutureTask</p>\n</li>\n</ol>\n"},{"title":"java多线程之ThreadPoolExcutor","date":"2019-06-18T08:53:26.000Z","_content":"\n## 一、为什么需要使用线程池\n- **线程创建和销毁的开销非常高**：频繁的创建和销毁线程需要消耗时间，会使响应变慢；同时消耗计算资源。\n- **资源耗尽**：空闲的线程会占用内存，会给垃圾回收带来压力，线程竞争CPU也会产生性能开销，线程池可合理管理空闲线程\n- **稳定性**：在一定范围内，增加线程可以提升系统的处理能力，如果超过这个范围，继续创建线程只会降低执行速度，甚至导致系统OOM,线程池即可以通过程序控制线程数。\n\n## 二、几个常用线程池\n首先看下线程池的构造函数：\n``` \n/**\n    public ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler) {\n        if (corePoolSize < 0 ||\n            maximumPoolSize <= 0 ||\n            maximumPoolSize < corePoolSize ||\n            keepAliveTime < 0)\n            throw new IllegalArgumentException();\n        if (workQueue == null || threadFactory == null || handler == null)\n            throw new NullPointerException();\n        this.acc = System.getSecurityManager() == null ?\n                null :\n                AccessController.getContext();\n        this.corePoolSize = corePoolSize;\n        this.maximumPoolSize = maximumPoolSize;\n        this.workQueue = workQueue;\n        this.keepAliveTime = unit.toNanos(keepAliveTime);\n        this.threadFactory = threadFactory;\n        this.handler = handler;\n    }\n\n```\n\n1. **newFixedThreadPool**:将创建一个**长度固定的线程池**，每当新提交一个任务时就创建一个新线程，直到达到线程池的最大数量，这时线程池的大小不在变化（如果某个线程发生未预期的Exception而结束，那么线程池会补充一个新线程）。\n```\n public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue<Runnable>(),\n                                      threadFactory);\n    }\n```\n2. **newCachedThreadPool**:将创建一个**可缓存的线程池**，如果有线程空闲，会回收空闲线程；如果任务增加时，可添加新线程，线程池的规模不存在任何界限。\n```\n public static ExecutorService newCachedThreadPool() {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue<Runnable>());\n    }\n```\n3. **newSingleThreadPool**:将创建一个**单线程的线程池**，如果线程异常结束，将创建另一个线程来替代；阻塞队列为LinkedBlockingQueue，提交的任务可按照顺序执行\n```\npublic static ExecutorService newSingleThreadExecutor() {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>()));\n    }\n```\n4. **newScheduledThreadPool**： 创建了一个**固定长度的线程池,而且以延迟或定时的方式来执行任务**,类似于Timer。\n```\n    public ScheduledThreadPoolExecutor(int corePoolSize,\n                                       ThreadFactory threadFactory) {\n        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,\n              new DelayedWorkQueue(), threadFactory);\n    }\n```\n\n## 三、线程池的六个重要参数：\n1. **corePoolSize**：核心线程数\n    - 核心线程会一直存活，及时没有任务需要执行\n    - 线程数 < corePoolSize时，即使有线程空闲，线程池也会优先创建新线程处理\n    - 设置allowCoreThreadTimeout=true（默认false）时，核心线程会超时关闭\n2. **queueCapacity**：任务队列容量（阻塞队列）\n    当核心线程数达到最大时，新任务会放在队列中排队等待执行\n3. **maxPoolSize**：最大线程数\n    - 线程数>=corePoolSize，且任务队列已满时。线程池会创建新线程来处理任务\n    - 线程数=maxPoolSize，且任务队列已满时，线程池会拒绝处理任务而抛出异常\n4. **keepAliveTime**：线程空闲时间\n    - 当线程空闲时间达到keepAliveTime时，线程会退出，直到线程数量=corePoolSize\n    - 如果allowCoreThreadTimeout=true，则会直到线程数量=0\n5. **allowCoreThreadTimeout**：允许核心线程超时\n6. **rejectedExecutionHandler**：任务拒绝处理器,两种情况会拒绝处理任务：\n    - 当线程数已经达到maxPoolSize，切队列已满，会拒绝新任务\n    - 当线程池被调用shutdown()后，会等待线程池里的任务执行完毕，再shutdown。如果在调用shutdown()和线程池真正shutdown之间提交任务，会拒绝新任务\n    - 线程池会调用rejectedExecutionHandler来处理这个任务。如果没有设置默认是AbortPolicy，会抛出异常\n7. 拒绝策略：\n    - AbortPolicy 直接抛出一个RejectedExecutionException，这也是JDK默认的拒绝策略\n    - CallerRunsPolicy 尝试直接运行被拒绝的任务，如果线程池已经被关闭了，任务就被丢弃了\n    - DiscardPolicy 不能执行的任务将被删除\n    - DiscardOldestPolicy 移除最晚的那个没有被处理的任务，然后执行被拒绝的任务。同样，如果线程池已经被关闭了，任务就被丢弃了\n    - 自定义：实现RejectedExecutionHandler接口，可自定义处理器\n \n## 四、ThreadPoolExecutor执行顺序：\n     线程池按以下行为执行任务\n \n1. currentThreadNum < corePoolSize->创建线程。\n2. corePoolSize =< currentThreadNum ，对列未满，加入队列。\n3. corePoolSize =< currentThreadNum <maxPoolSize ，且任务队列已满,创建线程\n4. corePoolSize =< currentThreadNum &&currentThreadNum>=maxPoolSize ,且任务队列已满,创建线程，抛出异常，拒绝任务\n \n## 五、如何设置参数\n \n- 默认值\ncorePoolSize=1\nqueueCapacity=Integer.MAX_VALUE\nmaxPoolSize=Integer.MAX_VALUE\nkeepAliveTime=60s\nallowCoreThreadTimeout=false\nrejectedExecutionHandler=AbortPolicy()\n- 如何来设置\n    1. 需要根据几个值来决定\n    - tasks ：每秒的任务数，假设为500~1000\n    - taskcost：每个任务花费时间，假设为0.1s\n    - responsetime：系统允许容忍的最大响应时间，假设为1s\n    2. 做几个计算\n    - corePoolSize = 每秒需要多少个线程处理？ \nthreadcount = tasks/(1/taskcost) =tasks*taskcout =  (500~1000)*0.1 = 50~100 个线程。corePoolSize设置应该大于50\n根据8020原则，如果80%的每秒任务数小于800，那么corePoolSize设置为80即可\n    - queueCapacity = (coreSizePool/taskcost)*responsetime\n计算可得 queueCapacity = 80/0.1*1 = 80。意思是队列里的线程可以等待1s，超过了的需要新开线程来执行\n切记不能设置为Integer.MAX_VALUE，这样队列会很大，线程数只会保持在corePoolSize大小，当任务陡增时，不能新开线程来执行，响应时间会随之陡增。\n    - maxPoolSize = (max(tasks)- queueCapacity)/(1/taskcost)\n计算可得 maxPoolSize = (1000-80)/10 = 92\n（最大任务数-队列容量）/每个线程每秒处理能力 = 最大线程数\n    - rejectedExecutionHandler：根据具体情况来决定，任务不重要可丢弃，任务重要则要利用一些缓冲机制来处理\n    - keepAliveTime和allowCoreThreadTimeout采用默认通常能满足\n\n ","source":"_posts/java多线程之ThreadPoolExcutor.md","raw":"---\ntitle: java多线程之ThreadPoolExcutor\ndate: 2019-06-18 16:53:26\ncategories: java多线程\ntags: java\n---\n\n## 一、为什么需要使用线程池\n- **线程创建和销毁的开销非常高**：频繁的创建和销毁线程需要消耗时间，会使响应变慢；同时消耗计算资源。\n- **资源耗尽**：空闲的线程会占用内存，会给垃圾回收带来压力，线程竞争CPU也会产生性能开销，线程池可合理管理空闲线程\n- **稳定性**：在一定范围内，增加线程可以提升系统的处理能力，如果超过这个范围，继续创建线程只会降低执行速度，甚至导致系统OOM,线程池即可以通过程序控制线程数。\n\n## 二、几个常用线程池\n首先看下线程池的构造函数：\n``` \n/**\n    public ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler) {\n        if (corePoolSize < 0 ||\n            maximumPoolSize <= 0 ||\n            maximumPoolSize < corePoolSize ||\n            keepAliveTime < 0)\n            throw new IllegalArgumentException();\n        if (workQueue == null || threadFactory == null || handler == null)\n            throw new NullPointerException();\n        this.acc = System.getSecurityManager() == null ?\n                null :\n                AccessController.getContext();\n        this.corePoolSize = corePoolSize;\n        this.maximumPoolSize = maximumPoolSize;\n        this.workQueue = workQueue;\n        this.keepAliveTime = unit.toNanos(keepAliveTime);\n        this.threadFactory = threadFactory;\n        this.handler = handler;\n    }\n\n```\n\n1. **newFixedThreadPool**:将创建一个**长度固定的线程池**，每当新提交一个任务时就创建一个新线程，直到达到线程池的最大数量，这时线程池的大小不在变化（如果某个线程发生未预期的Exception而结束，那么线程池会补充一个新线程）。\n```\n public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue<Runnable>(),\n                                      threadFactory);\n    }\n```\n2. **newCachedThreadPool**:将创建一个**可缓存的线程池**，如果有线程空闲，会回收空闲线程；如果任务增加时，可添加新线程，线程池的规模不存在任何界限。\n```\n public static ExecutorService newCachedThreadPool() {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue<Runnable>());\n    }\n```\n3. **newSingleThreadPool**:将创建一个**单线程的线程池**，如果线程异常结束，将创建另一个线程来替代；阻塞队列为LinkedBlockingQueue，提交的任务可按照顺序执行\n```\npublic static ExecutorService newSingleThreadExecutor() {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>()));\n    }\n```\n4. **newScheduledThreadPool**： 创建了一个**固定长度的线程池,而且以延迟或定时的方式来执行任务**,类似于Timer。\n```\n    public ScheduledThreadPoolExecutor(int corePoolSize,\n                                       ThreadFactory threadFactory) {\n        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,\n              new DelayedWorkQueue(), threadFactory);\n    }\n```\n\n## 三、线程池的六个重要参数：\n1. **corePoolSize**：核心线程数\n    - 核心线程会一直存活，及时没有任务需要执行\n    - 线程数 < corePoolSize时，即使有线程空闲，线程池也会优先创建新线程处理\n    - 设置allowCoreThreadTimeout=true（默认false）时，核心线程会超时关闭\n2. **queueCapacity**：任务队列容量（阻塞队列）\n    当核心线程数达到最大时，新任务会放在队列中排队等待执行\n3. **maxPoolSize**：最大线程数\n    - 线程数>=corePoolSize，且任务队列已满时。线程池会创建新线程来处理任务\n    - 线程数=maxPoolSize，且任务队列已满时，线程池会拒绝处理任务而抛出异常\n4. **keepAliveTime**：线程空闲时间\n    - 当线程空闲时间达到keepAliveTime时，线程会退出，直到线程数量=corePoolSize\n    - 如果allowCoreThreadTimeout=true，则会直到线程数量=0\n5. **allowCoreThreadTimeout**：允许核心线程超时\n6. **rejectedExecutionHandler**：任务拒绝处理器,两种情况会拒绝处理任务：\n    - 当线程数已经达到maxPoolSize，切队列已满，会拒绝新任务\n    - 当线程池被调用shutdown()后，会等待线程池里的任务执行完毕，再shutdown。如果在调用shutdown()和线程池真正shutdown之间提交任务，会拒绝新任务\n    - 线程池会调用rejectedExecutionHandler来处理这个任务。如果没有设置默认是AbortPolicy，会抛出异常\n7. 拒绝策略：\n    - AbortPolicy 直接抛出一个RejectedExecutionException，这也是JDK默认的拒绝策略\n    - CallerRunsPolicy 尝试直接运行被拒绝的任务，如果线程池已经被关闭了，任务就被丢弃了\n    - DiscardPolicy 不能执行的任务将被删除\n    - DiscardOldestPolicy 移除最晚的那个没有被处理的任务，然后执行被拒绝的任务。同样，如果线程池已经被关闭了，任务就被丢弃了\n    - 自定义：实现RejectedExecutionHandler接口，可自定义处理器\n \n## 四、ThreadPoolExecutor执行顺序：\n     线程池按以下行为执行任务\n \n1. currentThreadNum < corePoolSize->创建线程。\n2. corePoolSize =< currentThreadNum ，对列未满，加入队列。\n3. corePoolSize =< currentThreadNum <maxPoolSize ，且任务队列已满,创建线程\n4. corePoolSize =< currentThreadNum &&currentThreadNum>=maxPoolSize ,且任务队列已满,创建线程，抛出异常，拒绝任务\n \n## 五、如何设置参数\n \n- 默认值\ncorePoolSize=1\nqueueCapacity=Integer.MAX_VALUE\nmaxPoolSize=Integer.MAX_VALUE\nkeepAliveTime=60s\nallowCoreThreadTimeout=false\nrejectedExecutionHandler=AbortPolicy()\n- 如何来设置\n    1. 需要根据几个值来决定\n    - tasks ：每秒的任务数，假设为500~1000\n    - taskcost：每个任务花费时间，假设为0.1s\n    - responsetime：系统允许容忍的最大响应时间，假设为1s\n    2. 做几个计算\n    - corePoolSize = 每秒需要多少个线程处理？ \nthreadcount = tasks/(1/taskcost) =tasks*taskcout =  (500~1000)*0.1 = 50~100 个线程。corePoolSize设置应该大于50\n根据8020原则，如果80%的每秒任务数小于800，那么corePoolSize设置为80即可\n    - queueCapacity = (coreSizePool/taskcost)*responsetime\n计算可得 queueCapacity = 80/0.1*1 = 80。意思是队列里的线程可以等待1s，超过了的需要新开线程来执行\n切记不能设置为Integer.MAX_VALUE，这样队列会很大，线程数只会保持在corePoolSize大小，当任务陡增时，不能新开线程来执行，响应时间会随之陡增。\n    - maxPoolSize = (max(tasks)- queueCapacity)/(1/taskcost)\n计算可得 maxPoolSize = (1000-80)/10 = 92\n（最大任务数-队列容量）/每个线程每秒处理能力 = 最大线程数\n    - rejectedExecutionHandler：根据具体情况来决定，任务不重要可丢弃，任务重要则要利用一些缓冲机制来处理\n    - keepAliveTime和allowCoreThreadTimeout采用默认通常能满足\n\n ","slug":"java多线程之ThreadPoolExcutor","published":1,"updated":"2019-07-02T11:21:32.678Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzjwwm6000pw4j94p5qlhws","content":"<h2 id=\"一、为什么需要使用线程池\"><a href=\"#一、为什么需要使用线程池\" class=\"headerlink\" title=\"一、为什么需要使用线程池\"></a>一、为什么需要使用线程池</h2><ul>\n<li><strong>线程创建和销毁的开销非常高</strong>：频繁的创建和销毁线程需要消耗时间，会使响应变慢；同时消耗计算资源。</li>\n<li><strong>资源耗尽</strong>：空闲的线程会占用内存，会给垃圾回收带来压力，线程竞争CPU也会产生性能开销，线程池可合理管理空闲线程</li>\n<li><strong>稳定性</strong>：在一定范围内，增加线程可以提升系统的处理能力，如果超过这个范围，继续创建线程只会降低执行速度，甚至导致系统OOM,线程池即可以通过程序控制线程数。</li>\n</ul>\n<h2 id=\"二、几个常用线程池\"><a href=\"#二、几个常用线程池\" class=\"headerlink\" title=\"二、几个常用线程池\"></a>二、几个常用线程池</h2><p>首先看下线程池的构造函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">    public ThreadPoolExecutor(int corePoolSize,</span><br><span class=\"line\">                              int maximumPoolSize,</span><br><span class=\"line\">                              long keepAliveTime,</span><br><span class=\"line\">                              TimeUnit unit,</span><br><span class=\"line\">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class=\"line\">                              ThreadFactory threadFactory,</span><br><span class=\"line\">                              RejectedExecutionHandler handler) &#123;</span><br><span class=\"line\">        if (corePoolSize &lt; 0 ||</span><br><span class=\"line\">            maximumPoolSize &lt;= 0 ||</span><br><span class=\"line\">            maximumPoolSize &lt; corePoolSize ||</span><br><span class=\"line\">            keepAliveTime &lt; 0)</span><br><span class=\"line\">            throw new IllegalArgumentException();</span><br><span class=\"line\">        if (workQueue == null || threadFactory == null || handler == null)</span><br><span class=\"line\">            throw new NullPointerException();</span><br><span class=\"line\">        this.acc = System.getSecurityManager() == null ?</span><br><span class=\"line\">                null :</span><br><span class=\"line\">                AccessController.getContext();</span><br><span class=\"line\">        this.corePoolSize = corePoolSize;</span><br><span class=\"line\">        this.maximumPoolSize = maximumPoolSize;</span><br><span class=\"line\">        this.workQueue = workQueue;</span><br><span class=\"line\">        this.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class=\"line\">        this.threadFactory = threadFactory;</span><br><span class=\"line\">        this.handler = handler;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p><strong>newFixedThreadPool</strong>:将创建一个<strong>长度固定的线程池</strong>，每当新提交一个任务时就创建一个新线程，直到达到线程池的最大数量，这时线程池的大小不在变化（如果某个线程发生未预期的Exception而结束，那么线程池会补充一个新线程）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) &#123;</span><br><span class=\"line\">       return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class=\"line\">                                     0L, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                     new LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class=\"line\">                                     threadFactory);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>newCachedThreadPool</strong>:将创建一个<strong>可缓存的线程池</strong>，如果有线程空闲，会回收空闲线程；如果任务增加时，可添加新线程，线程池的规模不存在任何界限。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class=\"line\">       return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class=\"line\">                                     60L, TimeUnit.SECONDS,</span><br><span class=\"line\">                                     new SynchronousQueue&lt;Runnable&gt;());</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>newSingleThreadPool</strong>:将创建一个<strong>单线程的线程池</strong>，如果线程异常结束，将创建另一个线程来替代；阻塞队列为LinkedBlockingQueue，提交的任务可按照顺序执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class=\"line\">        return new FinalizableDelegatedExecutorService</span><br><span class=\"line\">            (new ThreadPoolExecutor(1, 1,</span><br><span class=\"line\">                                    0L, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                    new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>newScheduledThreadPool</strong>： 创建了一个<strong>固定长度的线程池,而且以延迟或定时的方式来执行任务</strong>,类似于Timer。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public ScheduledThreadPoolExecutor(int corePoolSize,</span><br><span class=\"line\">                                   ThreadFactory threadFactory) &#123;</span><br><span class=\"line\">    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,</span><br><span class=\"line\">          new DelayedWorkQueue(), threadFactory);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h2 id=\"三、线程池的六个重要参数：\"><a href=\"#三、线程池的六个重要参数：\" class=\"headerlink\" title=\"三、线程池的六个重要参数：\"></a>三、线程池的六个重要参数：</h2><ol>\n<li><strong>corePoolSize</strong>：核心线程数<ul>\n<li>核心线程会一直存活，及时没有任务需要执行</li>\n<li>线程数 &lt; corePoolSize时，即使有线程空闲，线程池也会优先创建新线程处理</li>\n<li>设置allowCoreThreadTimeout=true（默认false）时，核心线程会超时关闭</li>\n</ul>\n</li>\n<li><strong>queueCapacity</strong>：任务队列容量（阻塞队列）<br> 当核心线程数达到最大时，新任务会放在队列中排队等待执行</li>\n<li><strong>maxPoolSize</strong>：最大线程数<ul>\n<li>线程数&gt;=corePoolSize，且任务队列已满时。线程池会创建新线程来处理任务</li>\n<li>线程数=maxPoolSize，且任务队列已满时，线程池会拒绝处理任务而抛出异常</li>\n</ul>\n</li>\n<li><strong>keepAliveTime</strong>：线程空闲时间<ul>\n<li>当线程空闲时间达到keepAliveTime时，线程会退出，直到线程数量=corePoolSize</li>\n<li>如果allowCoreThreadTimeout=true，则会直到线程数量=0</li>\n</ul>\n</li>\n<li><strong>allowCoreThreadTimeout</strong>：允许核心线程超时</li>\n<li><strong>rejectedExecutionHandler</strong>：任务拒绝处理器,两种情况会拒绝处理任务：<ul>\n<li>当线程数已经达到maxPoolSize，切队列已满，会拒绝新任务</li>\n<li>当线程池被调用shutdown()后，会等待线程池里的任务执行完毕，再shutdown。如果在调用shutdown()和线程池真正shutdown之间提交任务，会拒绝新任务</li>\n<li>线程池会调用rejectedExecutionHandler来处理这个任务。如果没有设置默认是AbortPolicy，会抛出异常</li>\n</ul>\n</li>\n<li>拒绝策略：<ul>\n<li>AbortPolicy 直接抛出一个RejectedExecutionException，这也是JDK默认的拒绝策略</li>\n<li>CallerRunsPolicy 尝试直接运行被拒绝的任务，如果线程池已经被关闭了，任务就被丢弃了</li>\n<li>DiscardPolicy 不能执行的任务将被删除</li>\n<li>DiscardOldestPolicy 移除最晚的那个没有被处理的任务，然后执行被拒绝的任务。同样，如果线程池已经被关闭了，任务就被丢弃了</li>\n<li>自定义：实现RejectedExecutionHandler接口，可自定义处理器</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"四、ThreadPoolExecutor执行顺序：\"><a href=\"#四、ThreadPoolExecutor执行顺序：\" class=\"headerlink\" title=\"四、ThreadPoolExecutor执行顺序：\"></a>四、ThreadPoolExecutor执行顺序：</h2><pre><code>线程池按以下行为执行任务</code></pre><ol>\n<li>currentThreadNum &lt; corePoolSize-&gt;创建线程。</li>\n<li>corePoolSize =&lt; currentThreadNum ，对列未满，加入队列。</li>\n<li>corePoolSize =&lt; currentThreadNum &lt;maxPoolSize ，且任务队列已满,创建线程</li>\n<li>corePoolSize =&lt; currentThreadNum &amp;&amp;currentThreadNum&gt;=maxPoolSize ,且任务队列已满,创建线程，抛出异常，拒绝任务</li>\n</ol>\n<h2 id=\"五、如何设置参数\"><a href=\"#五、如何设置参数\" class=\"headerlink\" title=\"五、如何设置参数\"></a>五、如何设置参数</h2><ul>\n<li>默认值<br>corePoolSize=1<br>queueCapacity=Integer.MAX_VALUE<br>maxPoolSize=Integer.MAX_VALUE<br>keepAliveTime=60s<br>allowCoreThreadTimeout=false<br>rejectedExecutionHandler=AbortPolicy()</li>\n<li>如何来设置<ol>\n<li>需要根据几个值来决定</li>\n</ol>\n<ul>\n<li>tasks ：每秒的任务数，假设为500~1000</li>\n<li>taskcost：每个任务花费时间，假设为0.1s</li>\n<li>responsetime：系统允许容忍的最大响应时间，假设为1s</li>\n</ul>\n<ol start=\"2\">\n<li>做几个计算</li>\n</ol>\n<ul>\n<li>corePoolSize = 每秒需要多少个线程处理？<br>threadcount = tasks/(1/taskcost) =tasks<em>taskcout =  (500~1000)</em>0.1 = 50~100 个线程。corePoolSize设置应该大于50<br>根据8020原则，如果80%的每秒任务数小于800，那么corePoolSize设置为80即可</li>\n<li>queueCapacity = (coreSizePool/taskcost)<em>responsetime<br>计算可得 queueCapacity = 80/0.1</em>1 = 80。意思是队列里的线程可以等待1s，超过了的需要新开线程来执行<br>切记不能设置为Integer.MAX_VALUE，这样队列会很大，线程数只会保持在corePoolSize大小，当任务陡增时，不能新开线程来执行，响应时间会随之陡增。</li>\n<li>maxPoolSize = (max(tasks)- queueCapacity)/(1/taskcost)<br>计算可得 maxPoolSize = (1000-80)/10 = 92<br>（最大任务数-队列容量）/每个线程每秒处理能力 = 最大线程数</li>\n<li>rejectedExecutionHandler：根据具体情况来决定，任务不重要可丢弃，任务重要则要利用一些缓冲机制来处理</li>\n<li>keepAliveTime和allowCoreThreadTimeout采用默认通常能满足</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、为什么需要使用线程池\"><a href=\"#一、为什么需要使用线程池\" class=\"headerlink\" title=\"一、为什么需要使用线程池\"></a>一、为什么需要使用线程池</h2><ul>\n<li><strong>线程创建和销毁的开销非常高</strong>：频繁的创建和销毁线程需要消耗时间，会使响应变慢；同时消耗计算资源。</li>\n<li><strong>资源耗尽</strong>：空闲的线程会占用内存，会给垃圾回收带来压力，线程竞争CPU也会产生性能开销，线程池可合理管理空闲线程</li>\n<li><strong>稳定性</strong>：在一定范围内，增加线程可以提升系统的处理能力，如果超过这个范围，继续创建线程只会降低执行速度，甚至导致系统OOM,线程池即可以通过程序控制线程数。</li>\n</ul>\n<h2 id=\"二、几个常用线程池\"><a href=\"#二、几个常用线程池\" class=\"headerlink\" title=\"二、几个常用线程池\"></a>二、几个常用线程池</h2><p>首先看下线程池的构造函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">    public ThreadPoolExecutor(int corePoolSize,</span><br><span class=\"line\">                              int maximumPoolSize,</span><br><span class=\"line\">                              long keepAliveTime,</span><br><span class=\"line\">                              TimeUnit unit,</span><br><span class=\"line\">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class=\"line\">                              ThreadFactory threadFactory,</span><br><span class=\"line\">                              RejectedExecutionHandler handler) &#123;</span><br><span class=\"line\">        if (corePoolSize &lt; 0 ||</span><br><span class=\"line\">            maximumPoolSize &lt;= 0 ||</span><br><span class=\"line\">            maximumPoolSize &lt; corePoolSize ||</span><br><span class=\"line\">            keepAliveTime &lt; 0)</span><br><span class=\"line\">            throw new IllegalArgumentException();</span><br><span class=\"line\">        if (workQueue == null || threadFactory == null || handler == null)</span><br><span class=\"line\">            throw new NullPointerException();</span><br><span class=\"line\">        this.acc = System.getSecurityManager() == null ?</span><br><span class=\"line\">                null :</span><br><span class=\"line\">                AccessController.getContext();</span><br><span class=\"line\">        this.corePoolSize = corePoolSize;</span><br><span class=\"line\">        this.maximumPoolSize = maximumPoolSize;</span><br><span class=\"line\">        this.workQueue = workQueue;</span><br><span class=\"line\">        this.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class=\"line\">        this.threadFactory = threadFactory;</span><br><span class=\"line\">        this.handler = handler;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><p><strong>newFixedThreadPool</strong>:将创建一个<strong>长度固定的线程池</strong>，每当新提交一个任务时就创建一个新线程，直到达到线程池的最大数量，这时线程池的大小不在变化（如果某个线程发生未预期的Exception而结束，那么线程池会补充一个新线程）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) &#123;</span><br><span class=\"line\">       return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class=\"line\">                                     0L, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                     new LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class=\"line\">                                     threadFactory);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>newCachedThreadPool</strong>:将创建一个<strong>可缓存的线程池</strong>，如果有线程空闲，会回收空闲线程；如果任务增加时，可添加新线程，线程池的规模不存在任何界限。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class=\"line\">       return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class=\"line\">                                     60L, TimeUnit.SECONDS,</span><br><span class=\"line\">                                     new SynchronousQueue&lt;Runnable&gt;());</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>newSingleThreadPool</strong>:将创建一个<strong>单线程的线程池</strong>，如果线程异常结束，将创建另一个线程来替代；阻塞队列为LinkedBlockingQueue，提交的任务可按照顺序执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class=\"line\">        return new FinalizableDelegatedExecutorService</span><br><span class=\"line\">            (new ThreadPoolExecutor(1, 1,</span><br><span class=\"line\">                                    0L, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                    new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>newScheduledThreadPool</strong>： 创建了一个<strong>固定长度的线程池,而且以延迟或定时的方式来执行任务</strong>,类似于Timer。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public ScheduledThreadPoolExecutor(int corePoolSize,</span><br><span class=\"line\">                                   ThreadFactory threadFactory) &#123;</span><br><span class=\"line\">    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,</span><br><span class=\"line\">          new DelayedWorkQueue(), threadFactory);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h2 id=\"三、线程池的六个重要参数：\"><a href=\"#三、线程池的六个重要参数：\" class=\"headerlink\" title=\"三、线程池的六个重要参数：\"></a>三、线程池的六个重要参数：</h2><ol>\n<li><strong>corePoolSize</strong>：核心线程数<ul>\n<li>核心线程会一直存活，及时没有任务需要执行</li>\n<li>线程数 &lt; corePoolSize时，即使有线程空闲，线程池也会优先创建新线程处理</li>\n<li>设置allowCoreThreadTimeout=true（默认false）时，核心线程会超时关闭</li>\n</ul>\n</li>\n<li><strong>queueCapacity</strong>：任务队列容量（阻塞队列）<br> 当核心线程数达到最大时，新任务会放在队列中排队等待执行</li>\n<li><strong>maxPoolSize</strong>：最大线程数<ul>\n<li>线程数&gt;=corePoolSize，且任务队列已满时。线程池会创建新线程来处理任务</li>\n<li>线程数=maxPoolSize，且任务队列已满时，线程池会拒绝处理任务而抛出异常</li>\n</ul>\n</li>\n<li><strong>keepAliveTime</strong>：线程空闲时间<ul>\n<li>当线程空闲时间达到keepAliveTime时，线程会退出，直到线程数量=corePoolSize</li>\n<li>如果allowCoreThreadTimeout=true，则会直到线程数量=0</li>\n</ul>\n</li>\n<li><strong>allowCoreThreadTimeout</strong>：允许核心线程超时</li>\n<li><strong>rejectedExecutionHandler</strong>：任务拒绝处理器,两种情况会拒绝处理任务：<ul>\n<li>当线程数已经达到maxPoolSize，切队列已满，会拒绝新任务</li>\n<li>当线程池被调用shutdown()后，会等待线程池里的任务执行完毕，再shutdown。如果在调用shutdown()和线程池真正shutdown之间提交任务，会拒绝新任务</li>\n<li>线程池会调用rejectedExecutionHandler来处理这个任务。如果没有设置默认是AbortPolicy，会抛出异常</li>\n</ul>\n</li>\n<li>拒绝策略：<ul>\n<li>AbortPolicy 直接抛出一个RejectedExecutionException，这也是JDK默认的拒绝策略</li>\n<li>CallerRunsPolicy 尝试直接运行被拒绝的任务，如果线程池已经被关闭了，任务就被丢弃了</li>\n<li>DiscardPolicy 不能执行的任务将被删除</li>\n<li>DiscardOldestPolicy 移除最晚的那个没有被处理的任务，然后执行被拒绝的任务。同样，如果线程池已经被关闭了，任务就被丢弃了</li>\n<li>自定义：实现RejectedExecutionHandler接口，可自定义处理器</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"四、ThreadPoolExecutor执行顺序：\"><a href=\"#四、ThreadPoolExecutor执行顺序：\" class=\"headerlink\" title=\"四、ThreadPoolExecutor执行顺序：\"></a>四、ThreadPoolExecutor执行顺序：</h2><pre><code>线程池按以下行为执行任务</code></pre><ol>\n<li>currentThreadNum &lt; corePoolSize-&gt;创建线程。</li>\n<li>corePoolSize =&lt; currentThreadNum ，对列未满，加入队列。</li>\n<li>corePoolSize =&lt; currentThreadNum &lt;maxPoolSize ，且任务队列已满,创建线程</li>\n<li>corePoolSize =&lt; currentThreadNum &amp;&amp;currentThreadNum&gt;=maxPoolSize ,且任务队列已满,创建线程，抛出异常，拒绝任务</li>\n</ol>\n<h2 id=\"五、如何设置参数\"><a href=\"#五、如何设置参数\" class=\"headerlink\" title=\"五、如何设置参数\"></a>五、如何设置参数</h2><ul>\n<li>默认值<br>corePoolSize=1<br>queueCapacity=Integer.MAX_VALUE<br>maxPoolSize=Integer.MAX_VALUE<br>keepAliveTime=60s<br>allowCoreThreadTimeout=false<br>rejectedExecutionHandler=AbortPolicy()</li>\n<li>如何来设置<ol>\n<li>需要根据几个值来决定</li>\n</ol>\n<ul>\n<li>tasks ：每秒的任务数，假设为500~1000</li>\n<li>taskcost：每个任务花费时间，假设为0.1s</li>\n<li>responsetime：系统允许容忍的最大响应时间，假设为1s</li>\n</ul>\n<ol start=\"2\">\n<li>做几个计算</li>\n</ol>\n<ul>\n<li>corePoolSize = 每秒需要多少个线程处理？<br>threadcount = tasks/(1/taskcost) =tasks<em>taskcout =  (500~1000)</em>0.1 = 50~100 个线程。corePoolSize设置应该大于50<br>根据8020原则，如果80%的每秒任务数小于800，那么corePoolSize设置为80即可</li>\n<li>queueCapacity = (coreSizePool/taskcost)<em>responsetime<br>计算可得 queueCapacity = 80/0.1</em>1 = 80。意思是队列里的线程可以等待1s，超过了的需要新开线程来执行<br>切记不能设置为Integer.MAX_VALUE，这样队列会很大，线程数只会保持在corePoolSize大小，当任务陡增时，不能新开线程来执行，响应时间会随之陡增。</li>\n<li>maxPoolSize = (max(tasks)- queueCapacity)/(1/taskcost)<br>计算可得 maxPoolSize = (1000-80)/10 = 92<br>（最大任务数-队列容量）/每个线程每秒处理能力 = 最大线程数</li>\n<li>rejectedExecutionHandler：根据具体情况来决定，任务不重要可丢弃，任务重要则要利用一些缓冲机制来处理</li>\n<li>keepAliveTime和allowCoreThreadTimeout采用默认通常能满足</li>\n</ul>\n</li>\n</ul>\n"},{"title":"java多线程之synchronized,volatle和final关键字","date":"2019-06-26T14:53:03.000Z","_content":"\n## synchronized简介\n一个共享变量同时被多个线程读写时，会出现不一致问题。我们来看下面的代码：\n```\n\n/**\n * @Description: 同时1000个线程给count加一\n * @Auther: ThomasWu\n * @Date: 2019/6/27 21:43\n * @Email:1414924381@qq.com\n */\npublic class SynchronizedTest {\n    private static Integer count = 0;\n\n    public static class MyThread extends Thread {\n        @Override\n        public void run() {\n            addNum();\n        }\n    }\n\n    public static void addNum() {\n        count++;\n    }\n\n    public static void main(String[] args) {\n        for (int i = 0; i < 1000; i++) {\n            MyThread thread = new MyThread();\n            thread.start();\n        }\n\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        System.out.println(\"result:\" + count);\n    }\n}\n第一次运行：result:660\n第二次运行：result:660\n第三次运行：result:660\n每一次运行结果都不等于1000\n\n```\n## synchronized使用的各种场景\n|位置|被锁住的对象|实例|\n|---|----|----|\n| 实例方法|类的实例对象|`public synchronized void method{}`|\n| 静态方法|类对象|`public static synchronized void method{}`|\n| 实例对象|类的实例对象|` synchronized (this){}`|\n| class对象|类对象|` synchronized (Demo.class){}`|\n| 任意实例对象|实例对象|` String loclk=\"\";   synchronized (lock){}`|\n\n\n### synchronized用于实例方法上\n示例代码\n```\n package syn;\n\n/**\n * @Description: TODO\n * @Auther: ThomasWu\n * @Date: 2019/6/27 22:25\n * @Email:1414924381@qq.com\n */\npublic class LockObject {\n\n    static class ThreadB extends Thread {\n        private LockObject lockObject;\n\n        public ThreadB(LockObject lockObject) {\n            super();\n            this.lockObject = lockObject;\n        }\n\n        @Override\n        public void run() {\n            super.run();\n            lockObject.methodB();\n\n        }\n    }\n\n    static class ThreadA extends Thread {\n        private LockObject lockObject;\n\n        public ThreadA(LockObject lockObject) {\n            super();\n            this.lockObject = lockObject;\n        }\n\n        @Override\n        public void run() {\n            super.run();\n            lockObject.methodA();\n        }\n    }\n\n    public synchronized void methodA() {\n        try {\n            System.out.println(Thread.currentThread().getName() + \"--begin--\" + System.currentTimeMillis());\n            Thread.sleep(1000);\n            System.out.println(Thread.currentThread().getName() + \"--end----\" + System.currentTimeMillis());\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public synchronized void methodB() {\n        try {\n            System.out.println(Thread.currentThread().getName() + \"--begin--\" + System.currentTimeMillis());\n            Thread.sleep(1000);\n            System.out.println(Thread.currentThread().getName() + \"--end----\" + System.currentTimeMillis());\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        LockObject lockObject = new LockObject();\n\n        ThreadA threadA = new ThreadA(lockObject);\n        threadA.setName(\"A\");\n\n        ThreadB threadB = new ThreadB(lockObject);\n        threadB.setName(\"A\");\n\n        threadA.start();\n        threadB.start();\n    }\n}\n\nresult1 :methodA为同步方法，methodB为同步方法执行结果\nA--begin--1561647391094\nA--begin--1561647391094\nA--end----1561647392094\nA--end----1561647392094\n\nresult2:methodB,methodA都为同步方法执行结果\nA--begin--1561647419478\nA--end----1561647420480\nA--begin--1561647420480\nA--end----1561647421480\n\n```\n由此上面的实验可以得出：\n- 1、A线程持有Object对象的Lock锁，B线程可以以异步方式调用Object对象中的非synchronized类型的方法\n- 2、A线程持有Object对象的Lock锁，B线程如果在这时调用Object对象中的synchronized类型的方法则需要等待，也就是同步","source":"_posts/java多线程之synchronized-volatle和final关键字.md","raw":"---\ntitle: 'java多线程之synchronized,volatle和final关键字'\ndate: 2019-06-26 22:53:03\ncategories: java多线程\ntags: java\n---\n\n## synchronized简介\n一个共享变量同时被多个线程读写时，会出现不一致问题。我们来看下面的代码：\n```\n\n/**\n * @Description: 同时1000个线程给count加一\n * @Auther: ThomasWu\n * @Date: 2019/6/27 21:43\n * @Email:1414924381@qq.com\n */\npublic class SynchronizedTest {\n    private static Integer count = 0;\n\n    public static class MyThread extends Thread {\n        @Override\n        public void run() {\n            addNum();\n        }\n    }\n\n    public static void addNum() {\n        count++;\n    }\n\n    public static void main(String[] args) {\n        for (int i = 0; i < 1000; i++) {\n            MyThread thread = new MyThread();\n            thread.start();\n        }\n\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        System.out.println(\"result:\" + count);\n    }\n}\n第一次运行：result:660\n第二次运行：result:660\n第三次运行：result:660\n每一次运行结果都不等于1000\n\n```\n## synchronized使用的各种场景\n|位置|被锁住的对象|实例|\n|---|----|----|\n| 实例方法|类的实例对象|`public synchronized void method{}`|\n| 静态方法|类对象|`public static synchronized void method{}`|\n| 实例对象|类的实例对象|` synchronized (this){}`|\n| class对象|类对象|` synchronized (Demo.class){}`|\n| 任意实例对象|实例对象|` String loclk=\"\";   synchronized (lock){}`|\n\n\n### synchronized用于实例方法上\n示例代码\n```\n package syn;\n\n/**\n * @Description: TODO\n * @Auther: ThomasWu\n * @Date: 2019/6/27 22:25\n * @Email:1414924381@qq.com\n */\npublic class LockObject {\n\n    static class ThreadB extends Thread {\n        private LockObject lockObject;\n\n        public ThreadB(LockObject lockObject) {\n            super();\n            this.lockObject = lockObject;\n        }\n\n        @Override\n        public void run() {\n            super.run();\n            lockObject.methodB();\n\n        }\n    }\n\n    static class ThreadA extends Thread {\n        private LockObject lockObject;\n\n        public ThreadA(LockObject lockObject) {\n            super();\n            this.lockObject = lockObject;\n        }\n\n        @Override\n        public void run() {\n            super.run();\n            lockObject.methodA();\n        }\n    }\n\n    public synchronized void methodA() {\n        try {\n            System.out.println(Thread.currentThread().getName() + \"--begin--\" + System.currentTimeMillis());\n            Thread.sleep(1000);\n            System.out.println(Thread.currentThread().getName() + \"--end----\" + System.currentTimeMillis());\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public synchronized void methodB() {\n        try {\n            System.out.println(Thread.currentThread().getName() + \"--begin--\" + System.currentTimeMillis());\n            Thread.sleep(1000);\n            System.out.println(Thread.currentThread().getName() + \"--end----\" + System.currentTimeMillis());\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        LockObject lockObject = new LockObject();\n\n        ThreadA threadA = new ThreadA(lockObject);\n        threadA.setName(\"A\");\n\n        ThreadB threadB = new ThreadB(lockObject);\n        threadB.setName(\"A\");\n\n        threadA.start();\n        threadB.start();\n    }\n}\n\nresult1 :methodA为同步方法，methodB为同步方法执行结果\nA--begin--1561647391094\nA--begin--1561647391094\nA--end----1561647392094\nA--end----1561647392094\n\nresult2:methodB,methodA都为同步方法执行结果\nA--begin--1561647419478\nA--end----1561647420480\nA--begin--1561647420480\nA--end----1561647421480\n\n```\n由此上面的实验可以得出：\n- 1、A线程持有Object对象的Lock锁，B线程可以以异步方式调用Object对象中的非synchronized类型的方法\n- 2、A线程持有Object对象的Lock锁，B线程如果在这时调用Object对象中的synchronized类型的方法则需要等待，也就是同步","slug":"java多线程之synchronized-volatle和final关键字","published":1,"updated":"2019-07-02T11:21:32.681Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzjwwm9000sw4j9lwegwruz","content":"<h2 id=\"synchronized简介\"><a href=\"#synchronized简介\" class=\"headerlink\" title=\"synchronized简介\"></a>synchronized简介</h2><p>一个共享变量同时被多个线程读写时，会出现不一致问题。我们来看下面的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @Description: 同时1000个线程给count加一</span><br><span class=\"line\"> * @Auther: ThomasWu</span><br><span class=\"line\"> * @Date: 2019/6/27 21:43</span><br><span class=\"line\"> * @Email:1414924381@qq.com</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class SynchronizedTest &#123;</span><br><span class=\"line\">    private static Integer count = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static class MyThread extends Thread &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            addNum();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void addNum() &#123;</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class=\"line\">            MyThread thread = new MyThread();</span><br><span class=\"line\">            thread.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Thread.sleep(1000);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(&quot;result:&quot; + count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">第一次运行：result:660</span><br><span class=\"line\">第二次运行：result:660</span><br><span class=\"line\">第三次运行：result:660</span><br><span class=\"line\">每一次运行结果都不等于1000</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"synchronized使用的各种场景\"><a href=\"#synchronized使用的各种场景\" class=\"headerlink\" title=\"synchronized使用的各种场景\"></a>synchronized使用的各种场景</h2><table>\n<thead>\n<tr>\n<th>位置</th>\n<th>被锁住的对象</th>\n<th>实例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>实例方法</td>\n<td>类的实例对象</td>\n<td><code>public synchronized void method{}</code></td>\n</tr>\n<tr>\n<td>静态方法</td>\n<td>类对象</td>\n<td><code>public static synchronized void method{}</code></td>\n</tr>\n<tr>\n<td>实例对象</td>\n<td>类的实例对象</td>\n<td><code>synchronized (this){}</code></td>\n</tr>\n<tr>\n<td>class对象</td>\n<td>类对象</td>\n<td><code>synchronized (Demo.class){}</code></td>\n</tr>\n<tr>\n<td>任意实例对象</td>\n<td>实例对象</td>\n<td><code>String loclk=&quot;&quot;;   synchronized (lock){}</code></td>\n</tr>\n</tbody></table>\n<h3 id=\"synchronized用于实例方法上\"><a href=\"#synchronized用于实例方法上\" class=\"headerlink\" title=\"synchronized用于实例方法上\"></a>synchronized用于实例方法上</h3><p>示例代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> package syn;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @Description: TODO</span><br><span class=\"line\"> * @Auther: ThomasWu</span><br><span class=\"line\"> * @Date: 2019/6/27 22:25</span><br><span class=\"line\"> * @Email:1414924381@qq.com</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class LockObject &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    static class ThreadB extends Thread &#123;</span><br><span class=\"line\">        private LockObject lockObject;</span><br><span class=\"line\"></span><br><span class=\"line\">        public ThreadB(LockObject lockObject) &#123;</span><br><span class=\"line\">            super();</span><br><span class=\"line\">            this.lockObject = lockObject;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            super.run();</span><br><span class=\"line\">            lockObject.methodB();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    static class ThreadA extends Thread &#123;</span><br><span class=\"line\">        private LockObject lockObject;</span><br><span class=\"line\"></span><br><span class=\"line\">        public ThreadA(LockObject lockObject) &#123;</span><br><span class=\"line\">            super();</span><br><span class=\"line\">            this.lockObject = lockObject;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            super.run();</span><br><span class=\"line\">            lockObject.methodA();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public synchronized void methodA() &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + &quot;--begin--&quot; + System.currentTimeMillis());</span><br><span class=\"line\">            Thread.sleep(1000);</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + &quot;--end----&quot; + System.currentTimeMillis());</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public synchronized void methodB() &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + &quot;--begin--&quot; + System.currentTimeMillis());</span><br><span class=\"line\">            Thread.sleep(1000);</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + &quot;--end----&quot; + System.currentTimeMillis());</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        LockObject lockObject = new LockObject();</span><br><span class=\"line\"></span><br><span class=\"line\">        ThreadA threadA = new ThreadA(lockObject);</span><br><span class=\"line\">        threadA.setName(&quot;A&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        ThreadB threadB = new ThreadB(lockObject);</span><br><span class=\"line\">        threadB.setName(&quot;A&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        threadA.start();</span><br><span class=\"line\">        threadB.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">result1 :methodA为同步方法，methodB为同步方法执行结果</span><br><span class=\"line\">A--begin--1561647391094</span><br><span class=\"line\">A--begin--1561647391094</span><br><span class=\"line\">A--end----1561647392094</span><br><span class=\"line\">A--end----1561647392094</span><br><span class=\"line\"></span><br><span class=\"line\">result2:methodB,methodA都为同步方法执行结果</span><br><span class=\"line\">A--begin--1561647419478</span><br><span class=\"line\">A--end----1561647420480</span><br><span class=\"line\">A--begin--1561647420480</span><br><span class=\"line\">A--end----1561647421480</span><br></pre></td></tr></table></figure>\n\n<p>由此上面的实验可以得出：</p>\n<ul>\n<li>1、A线程持有Object对象的Lock锁，B线程可以以异步方式调用Object对象中的非synchronized类型的方法</li>\n<li>2、A线程持有Object对象的Lock锁，B线程如果在这时调用Object对象中的synchronized类型的方法则需要等待，也就是同步</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"synchronized简介\"><a href=\"#synchronized简介\" class=\"headerlink\" title=\"synchronized简介\"></a>synchronized简介</h2><p>一个共享变量同时被多个线程读写时，会出现不一致问题。我们来看下面的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @Description: 同时1000个线程给count加一</span><br><span class=\"line\"> * @Auther: ThomasWu</span><br><span class=\"line\"> * @Date: 2019/6/27 21:43</span><br><span class=\"line\"> * @Email:1414924381@qq.com</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class SynchronizedTest &#123;</span><br><span class=\"line\">    private static Integer count = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static class MyThread extends Thread &#123;</span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            addNum();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void addNum() &#123;</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class=\"line\">            MyThread thread = new MyThread();</span><br><span class=\"line\">            thread.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Thread.sleep(1000);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(&quot;result:&quot; + count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">第一次运行：result:660</span><br><span class=\"line\">第二次运行：result:660</span><br><span class=\"line\">第三次运行：result:660</span><br><span class=\"line\">每一次运行结果都不等于1000</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"synchronized使用的各种场景\"><a href=\"#synchronized使用的各种场景\" class=\"headerlink\" title=\"synchronized使用的各种场景\"></a>synchronized使用的各种场景</h2><table>\n<thead>\n<tr>\n<th>位置</th>\n<th>被锁住的对象</th>\n<th>实例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>实例方法</td>\n<td>类的实例对象</td>\n<td><code>public synchronized void method{}</code></td>\n</tr>\n<tr>\n<td>静态方法</td>\n<td>类对象</td>\n<td><code>public static synchronized void method{}</code></td>\n</tr>\n<tr>\n<td>实例对象</td>\n<td>类的实例对象</td>\n<td><code>synchronized (this){}</code></td>\n</tr>\n<tr>\n<td>class对象</td>\n<td>类对象</td>\n<td><code>synchronized (Demo.class){}</code></td>\n</tr>\n<tr>\n<td>任意实例对象</td>\n<td>实例对象</td>\n<td><code>String loclk=&quot;&quot;;   synchronized (lock){}</code></td>\n</tr>\n</tbody></table>\n<h3 id=\"synchronized用于实例方法上\"><a href=\"#synchronized用于实例方法上\" class=\"headerlink\" title=\"synchronized用于实例方法上\"></a>synchronized用于实例方法上</h3><p>示例代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> package syn;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @Description: TODO</span><br><span class=\"line\"> * @Auther: ThomasWu</span><br><span class=\"line\"> * @Date: 2019/6/27 22:25</span><br><span class=\"line\"> * @Email:1414924381@qq.com</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class LockObject &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    static class ThreadB extends Thread &#123;</span><br><span class=\"line\">        private LockObject lockObject;</span><br><span class=\"line\"></span><br><span class=\"line\">        public ThreadB(LockObject lockObject) &#123;</span><br><span class=\"line\">            super();</span><br><span class=\"line\">            this.lockObject = lockObject;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            super.run();</span><br><span class=\"line\">            lockObject.methodB();</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    static class ThreadA extends Thread &#123;</span><br><span class=\"line\">        private LockObject lockObject;</span><br><span class=\"line\"></span><br><span class=\"line\">        public ThreadA(LockObject lockObject) &#123;</span><br><span class=\"line\">            super();</span><br><span class=\"line\">            this.lockObject = lockObject;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            super.run();</span><br><span class=\"line\">            lockObject.methodA();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public synchronized void methodA() &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + &quot;--begin--&quot; + System.currentTimeMillis());</span><br><span class=\"line\">            Thread.sleep(1000);</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + &quot;--end----&quot; + System.currentTimeMillis());</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public synchronized void methodB() &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + &quot;--begin--&quot; + System.currentTimeMillis());</span><br><span class=\"line\">            Thread.sleep(1000);</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + &quot;--end----&quot; + System.currentTimeMillis());</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        LockObject lockObject = new LockObject();</span><br><span class=\"line\"></span><br><span class=\"line\">        ThreadA threadA = new ThreadA(lockObject);</span><br><span class=\"line\">        threadA.setName(&quot;A&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        ThreadB threadB = new ThreadB(lockObject);</span><br><span class=\"line\">        threadB.setName(&quot;A&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        threadA.start();</span><br><span class=\"line\">        threadB.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">result1 :methodA为同步方法，methodB为同步方法执行结果</span><br><span class=\"line\">A--begin--1561647391094</span><br><span class=\"line\">A--begin--1561647391094</span><br><span class=\"line\">A--end----1561647392094</span><br><span class=\"line\">A--end----1561647392094</span><br><span class=\"line\"></span><br><span class=\"line\">result2:methodB,methodA都为同步方法执行结果</span><br><span class=\"line\">A--begin--1561647419478</span><br><span class=\"line\">A--end----1561647420480</span><br><span class=\"line\">A--begin--1561647420480</span><br><span class=\"line\">A--end----1561647421480</span><br></pre></td></tr></table></figure>\n\n<p>由此上面的实验可以得出：</p>\n<ul>\n<li>1、A线程持有Object对象的Lock锁，B线程可以以异步方式调用Object对象中的非synchronized类型的方法</li>\n<li>2、A线程持有Object对象的Lock锁，B线程如果在这时调用Object对象中的synchronized类型的方法则需要等待，也就是同步</li>\n</ul>\n"},{"title":"java多线程之内存模型","date":"2019-06-26T13:54:31.000Z","_content":"## 概述\n### 背景\n现代计算机存储设备与处理器的计算速度存在着几个数量级的差距，大量的时间花费在磁盘I/O或数据库访问上，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器速度的高速缓存来作为内存与处理器之间的缓中；将计算时需要使用的数据复制到缓存中，让计算速度快速进行，当计算结束后再从缓存同步到内存之中，这样处理器就无需等待缓慢的内存读写了。\n### 新的问题\n高速缓存解决了处理器与内存的速度矛盾，但却引入了一个新的问题-缓存不一致问题；多处理器系统中，每个处理器都有自己的高速缓存，而他们都共享同一个主内存，各自处理器计算完成后，需要将各自缓存的数据回写到主内存时，处理器之间缓存的数据不一致时就会导致不一致问题，java内存模型的出现即为解决这一问题\n### 什么是java内存模型\n不同的硬件生产商和不同的操作系统下，内存的访问逻辑有一定的差异，结果就是当你的代码在某个系统环境下运行良好，并且线程安全，但是换了个系统就出现各种问题。Java内存模型，就是为了屏蔽系统和硬件的差异，让一套代码在不同平台下能到达相同的访问结果。JMM从java 5开始的JSR-133发布后，已经成熟和完善起来。\n\n## 工作原理\n### 内存划分\nJVM在设计时候考虑到，如果JAVA线程每次读取和写入变量都直接操作主内存，对性能影响比较大，所以每条线程拥有各自的工作内存，工作内存中的变量是主内存中的一份拷贝，线程对变量的读取和写入，直接在工作内存中操作，而不能直接去操作主内存中的变量。但是这样就会出现一个问题，当一个线程修改了自己工作内存中变量，对其他线程是不可见的，会导致线程不安全的问题。因为JMM制定了一套标准来保证开发者在编写多线程程序的时候，能够控制什么时候内存会被同步给其他线程。\n![alt](/source/images/jus/JMM1.png)\n\n### 内存之间的交互操作\n内存交互操作有8种，虚拟机实现必须保证每一个操作都是原子的，不可在分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许例外）\n\n- lock     （锁定）：作用于主内存的变量，把一个变量标识为线程独占状态\n- unlock （解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定\n- read    （读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用\n- load     （载入）：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中\n- use      （使用）：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令\n- assign  （赋值）：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中\n- store    （存储）：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用\n- write 　（写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中\n\n　　JMM对这八种指令的使用，制定了如下规则：\n\n- 不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write\n- 不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存\n- 不允许一个线程将没有assign的数据从工作内存同步回主内存\n- 一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作\n- 一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁\n- 如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值\n- 如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量\n- 对一个变量进行unlock操作之前，必须把此变量同步回主内存\n\nJMM对这八种操作规则和对volatile的一些特殊规则就能确定哪里操作是线程安全，哪些操作是线程不安全的了。但是这些规则实在复杂，很难在实践中直接分析。所以一般我们也不会通过上述规则进行分析。更多的时候，使用java的happen-before规则来进行分析。\n\n## Happen-Before（先行发生规则）\n\n　　在常规的开发中，如果我们通过上述规则来分析一个并发程序是否安全，估计脑壳会很疼。因为更多时候，我们是分析一个并发程序是否安全，其实都依赖Happen-Before原则进行分析。Happen-Before被翻译成先行发生原则，意思就是当A操作先行发生于B操作，则在发生B操作的时候，操作A产生的影响能被B观察到，“影响”包括修改了内存中的共享变量的值、发送了消息、调用了方法等。\n\n　　Happen-Before的规则有以下几条\n\n-  程序次序规则（Program Order Rule）：在一个线程内，程序的执行规则跟程序的书写规则是一致的，从上往下执行。\n- 管程锁定规则（Monitor Lock Rule）：一个Unlock的操作肯定先于下一次Lock的操作。这里必须是同一个锁。同理我们可以认为在synchronized同步同一个锁的时候，锁内先行执行的代码，对后续同步该锁的线程来说是完全可见的。\n- volatile变量规则（volatile Variable Rule）：对同一个volatile的变量，先行发生的写操作，肯定早于后续发生的读操作\n- 线程启动规则（Thread Start Rule）：Thread对象的start()方法先行发生于此线程的没一个动作\n- 线程中止规则（Thread Termination Rule）：Thread对象的中止检测（如：Thread.join()，Thread.isAlive()等）操作，必行晚于线程中所有操作\n- 线程中断规则（Thread Interruption Rule）：对线程的interruption（）调用，先于被调用的线程检测中断事件(Thread.interrupted())的发生\n- 对象中止规则（Finalizer Rule）：一个对象的初始化方法先于一个方法执行Finalizer()方法\n- 传递性（Transitivity）：如果操作A先于操作B、操作B先于操作C,则操作A先于操作C\n\n　　以上就是Happen-Before中的规则。通过这些条件的判定，仍然很难判断一个线程是否能安全执行，毕竟在我们的时候线程安全多数依赖于工具类的安全性来保证。想提高自己对线程是否安全的判断能力，必然需要理解所使用的框架或者工具的实现，并积累线程安全的经验。\n\n参考：\n- http://tutorials.jenkov.com/java-concurrency/java-memory-model.html\n- 深入理解java虚拟第12张","source":"_posts/java多线程之内存模型.md","raw":"---\ntitle: java多线程之内存模型\ndate: 2019-06-26 21:54:31\ncategories: java多线程\ntags: java\n---\n## 概述\n### 背景\n现代计算机存储设备与处理器的计算速度存在着几个数量级的差距，大量的时间花费在磁盘I/O或数据库访问上，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器速度的高速缓存来作为内存与处理器之间的缓中；将计算时需要使用的数据复制到缓存中，让计算速度快速进行，当计算结束后再从缓存同步到内存之中，这样处理器就无需等待缓慢的内存读写了。\n### 新的问题\n高速缓存解决了处理器与内存的速度矛盾，但却引入了一个新的问题-缓存不一致问题；多处理器系统中，每个处理器都有自己的高速缓存，而他们都共享同一个主内存，各自处理器计算完成后，需要将各自缓存的数据回写到主内存时，处理器之间缓存的数据不一致时就会导致不一致问题，java内存模型的出现即为解决这一问题\n### 什么是java内存模型\n不同的硬件生产商和不同的操作系统下，内存的访问逻辑有一定的差异，结果就是当你的代码在某个系统环境下运行良好，并且线程安全，但是换了个系统就出现各种问题。Java内存模型，就是为了屏蔽系统和硬件的差异，让一套代码在不同平台下能到达相同的访问结果。JMM从java 5开始的JSR-133发布后，已经成熟和完善起来。\n\n## 工作原理\n### 内存划分\nJVM在设计时候考虑到，如果JAVA线程每次读取和写入变量都直接操作主内存，对性能影响比较大，所以每条线程拥有各自的工作内存，工作内存中的变量是主内存中的一份拷贝，线程对变量的读取和写入，直接在工作内存中操作，而不能直接去操作主内存中的变量。但是这样就会出现一个问题，当一个线程修改了自己工作内存中变量，对其他线程是不可见的，会导致线程不安全的问题。因为JMM制定了一套标准来保证开发者在编写多线程程序的时候，能够控制什么时候内存会被同步给其他线程。\n![alt](/source/images/jus/JMM1.png)\n\n### 内存之间的交互操作\n内存交互操作有8种，虚拟机实现必须保证每一个操作都是原子的，不可在分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许例外）\n\n- lock     （锁定）：作用于主内存的变量，把一个变量标识为线程独占状态\n- unlock （解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定\n- read    （读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用\n- load     （载入）：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中\n- use      （使用）：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令\n- assign  （赋值）：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中\n- store    （存储）：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用\n- write 　（写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中\n\n　　JMM对这八种指令的使用，制定了如下规则：\n\n- 不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write\n- 不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存\n- 不允许一个线程将没有assign的数据从工作内存同步回主内存\n- 一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作\n- 一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁\n- 如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值\n- 如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量\n- 对一个变量进行unlock操作之前，必须把此变量同步回主内存\n\nJMM对这八种操作规则和对volatile的一些特殊规则就能确定哪里操作是线程安全，哪些操作是线程不安全的了。但是这些规则实在复杂，很难在实践中直接分析。所以一般我们也不会通过上述规则进行分析。更多的时候，使用java的happen-before规则来进行分析。\n\n## Happen-Before（先行发生规则）\n\n　　在常规的开发中，如果我们通过上述规则来分析一个并发程序是否安全，估计脑壳会很疼。因为更多时候，我们是分析一个并发程序是否安全，其实都依赖Happen-Before原则进行分析。Happen-Before被翻译成先行发生原则，意思就是当A操作先行发生于B操作，则在发生B操作的时候，操作A产生的影响能被B观察到，“影响”包括修改了内存中的共享变量的值、发送了消息、调用了方法等。\n\n　　Happen-Before的规则有以下几条\n\n-  程序次序规则（Program Order Rule）：在一个线程内，程序的执行规则跟程序的书写规则是一致的，从上往下执行。\n- 管程锁定规则（Monitor Lock Rule）：一个Unlock的操作肯定先于下一次Lock的操作。这里必须是同一个锁。同理我们可以认为在synchronized同步同一个锁的时候，锁内先行执行的代码，对后续同步该锁的线程来说是完全可见的。\n- volatile变量规则（volatile Variable Rule）：对同一个volatile的变量，先行发生的写操作，肯定早于后续发生的读操作\n- 线程启动规则（Thread Start Rule）：Thread对象的start()方法先行发生于此线程的没一个动作\n- 线程中止规则（Thread Termination Rule）：Thread对象的中止检测（如：Thread.join()，Thread.isAlive()等）操作，必行晚于线程中所有操作\n- 线程中断规则（Thread Interruption Rule）：对线程的interruption（）调用，先于被调用的线程检测中断事件(Thread.interrupted())的发生\n- 对象中止规则（Finalizer Rule）：一个对象的初始化方法先于一个方法执行Finalizer()方法\n- 传递性（Transitivity）：如果操作A先于操作B、操作B先于操作C,则操作A先于操作C\n\n　　以上就是Happen-Before中的规则。通过这些条件的判定，仍然很难判断一个线程是否能安全执行，毕竟在我们的时候线程安全多数依赖于工具类的安全性来保证。想提高自己对线程是否安全的判断能力，必然需要理解所使用的框架或者工具的实现，并积累线程安全的经验。\n\n参考：\n- http://tutorials.jenkov.com/java-concurrency/java-memory-model.html\n- 深入理解java虚拟第12张","slug":"java多线程之内存模型","published":1,"updated":"2019-07-02T11:21:32.684Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzjwwmd000ww4j9jh2wgl8b","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>现代计算机存储设备与处理器的计算速度存在着几个数量级的差距，大量的时间花费在磁盘I/O或数据库访问上，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器速度的高速缓存来作为内存与处理器之间的缓中；将计算时需要使用的数据复制到缓存中，让计算速度快速进行，当计算结束后再从缓存同步到内存之中，这样处理器就无需等待缓慢的内存读写了。</p>\n<h3 id=\"新的问题\"><a href=\"#新的问题\" class=\"headerlink\" title=\"新的问题\"></a>新的问题</h3><p>高速缓存解决了处理器与内存的速度矛盾，但却引入了一个新的问题-缓存不一致问题；多处理器系统中，每个处理器都有自己的高速缓存，而他们都共享同一个主内存，各自处理器计算完成后，需要将各自缓存的数据回写到主内存时，处理器之间缓存的数据不一致时就会导致不一致问题，java内存模型的出现即为解决这一问题</p>\n<h3 id=\"什么是java内存模型\"><a href=\"#什么是java内存模型\" class=\"headerlink\" title=\"什么是java内存模型\"></a>什么是java内存模型</h3><p>不同的硬件生产商和不同的操作系统下，内存的访问逻辑有一定的差异，结果就是当你的代码在某个系统环境下运行良好，并且线程安全，但是换了个系统就出现各种问题。Java内存模型，就是为了屏蔽系统和硬件的差异，让一套代码在不同平台下能到达相同的访问结果。JMM从java 5开始的JSR-133发布后，已经成熟和完善起来。</p>\n<h2 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h2><h3 id=\"内存划分\"><a href=\"#内存划分\" class=\"headerlink\" title=\"内存划分\"></a>内存划分</h3><p>JVM在设计时候考虑到，如果JAVA线程每次读取和写入变量都直接操作主内存，对性能影响比较大，所以每条线程拥有各自的工作内存，工作内存中的变量是主内存中的一份拷贝，线程对变量的读取和写入，直接在工作内存中操作，而不能直接去操作主内存中的变量。但是这样就会出现一个问题，当一个线程修改了自己工作内存中变量，对其他线程是不可见的，会导致线程不安全的问题。因为JMM制定了一套标准来保证开发者在编写多线程程序的时候，能够控制什么时候内存会被同步给其他线程。<br><img src=\"/source/images/jus/JMM1.png\" alt=\"alt\"></p>\n<h3 id=\"内存之间的交互操作\"><a href=\"#内存之间的交互操作\" class=\"headerlink\" title=\"内存之间的交互操作\"></a>内存之间的交互操作</h3><p>内存交互操作有8种，虚拟机实现必须保证每一个操作都是原子的，不可在分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许例外）</p>\n<ul>\n<li>lock     （锁定）：作用于主内存的变量，把一个变量标识为线程独占状态</li>\n<li>unlock （解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li>\n<li>read    （读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用</li>\n<li>load     （载入）：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中</li>\n<li>use      （使用）：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令</li>\n<li>assign  （赋值）：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中</li>\n<li>store    （存储）：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用</li>\n<li>write 　（写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中</li>\n</ul>\n<p>　　JMM对这八种指令的使用，制定了如下规则：</p>\n<ul>\n<li>不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write</li>\n<li>不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存</li>\n<li>不允许一个线程将没有assign的数据从工作内存同步回主内存</li>\n<li>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作</li>\n<li>一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁</li>\n<li>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值</li>\n<li>如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量</li>\n<li>对一个变量进行unlock操作之前，必须把此变量同步回主内存</li>\n</ul>\n<p>JMM对这八种操作规则和对volatile的一些特殊规则就能确定哪里操作是线程安全，哪些操作是线程不安全的了。但是这些规则实在复杂，很难在实践中直接分析。所以一般我们也不会通过上述规则进行分析。更多的时候，使用java的happen-before规则来进行分析。</p>\n<h2 id=\"Happen-Before（先行发生规则）\"><a href=\"#Happen-Before（先行发生规则）\" class=\"headerlink\" title=\"Happen-Before（先行发生规则）\"></a>Happen-Before（先行发生规则）</h2><p>　　在常规的开发中，如果我们通过上述规则来分析一个并发程序是否安全，估计脑壳会很疼。因为更多时候，我们是分析一个并发程序是否安全，其实都依赖Happen-Before原则进行分析。Happen-Before被翻译成先行发生原则，意思就是当A操作先行发生于B操作，则在发生B操作的时候，操作A产生的影响能被B观察到，“影响”包括修改了内存中的共享变量的值、发送了消息、调用了方法等。</p>\n<p>　　Happen-Before的规则有以下几条</p>\n<ul>\n<li>程序次序规则（Program Order Rule）：在一个线程内，程序的执行规则跟程序的书写规则是一致的，从上往下执行。</li>\n<li>管程锁定规则（Monitor Lock Rule）：一个Unlock的操作肯定先于下一次Lock的操作。这里必须是同一个锁。同理我们可以认为在synchronized同步同一个锁的时候，锁内先行执行的代码，对后续同步该锁的线程来说是完全可见的。</li>\n<li>volatile变量规则（volatile Variable Rule）：对同一个volatile的变量，先行发生的写操作，肯定早于后续发生的读操作</li>\n<li>线程启动规则（Thread Start Rule）：Thread对象的start()方法先行发生于此线程的没一个动作</li>\n<li>线程中止规则（Thread Termination Rule）：Thread对象的中止检测（如：Thread.join()，Thread.isAlive()等）操作，必行晚于线程中所有操作</li>\n<li>线程中断规则（Thread Interruption Rule）：对线程的interruption（）调用，先于被调用的线程检测中断事件(Thread.interrupted())的发生</li>\n<li>对象中止规则（Finalizer Rule）：一个对象的初始化方法先于一个方法执行Finalizer()方法</li>\n<li>传递性（Transitivity）：如果操作A先于操作B、操作B先于操作C,则操作A先于操作C</li>\n</ul>\n<p>　　以上就是Happen-Before中的规则。通过这些条件的判定，仍然很难判断一个线程是否能安全执行，毕竟在我们的时候线程安全多数依赖于工具类的安全性来保证。想提高自己对线程是否安全的判断能力，必然需要理解所使用的框架或者工具的实现，并积累线程安全的经验。</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"http://tutorials.jenkov.com/java-concurrency/java-memory-model.html\" target=\"_blank\" rel=\"noopener\">http://tutorials.jenkov.com/java-concurrency/java-memory-model.html</a></li>\n<li>深入理解java虚拟第12张</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>现代计算机存储设备与处理器的计算速度存在着几个数量级的差距，大量的时间花费在磁盘I/O或数据库访问上，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器速度的高速缓存来作为内存与处理器之间的缓中；将计算时需要使用的数据复制到缓存中，让计算速度快速进行，当计算结束后再从缓存同步到内存之中，这样处理器就无需等待缓慢的内存读写了。</p>\n<h3 id=\"新的问题\"><a href=\"#新的问题\" class=\"headerlink\" title=\"新的问题\"></a>新的问题</h3><p>高速缓存解决了处理器与内存的速度矛盾，但却引入了一个新的问题-缓存不一致问题；多处理器系统中，每个处理器都有自己的高速缓存，而他们都共享同一个主内存，各自处理器计算完成后，需要将各自缓存的数据回写到主内存时，处理器之间缓存的数据不一致时就会导致不一致问题，java内存模型的出现即为解决这一问题</p>\n<h3 id=\"什么是java内存模型\"><a href=\"#什么是java内存模型\" class=\"headerlink\" title=\"什么是java内存模型\"></a>什么是java内存模型</h3><p>不同的硬件生产商和不同的操作系统下，内存的访问逻辑有一定的差异，结果就是当你的代码在某个系统环境下运行良好，并且线程安全，但是换了个系统就出现各种问题。Java内存模型，就是为了屏蔽系统和硬件的差异，让一套代码在不同平台下能到达相同的访问结果。JMM从java 5开始的JSR-133发布后，已经成熟和完善起来。</p>\n<h2 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h2><h3 id=\"内存划分\"><a href=\"#内存划分\" class=\"headerlink\" title=\"内存划分\"></a>内存划分</h3><p>JVM在设计时候考虑到，如果JAVA线程每次读取和写入变量都直接操作主内存，对性能影响比较大，所以每条线程拥有各自的工作内存，工作内存中的变量是主内存中的一份拷贝，线程对变量的读取和写入，直接在工作内存中操作，而不能直接去操作主内存中的变量。但是这样就会出现一个问题，当一个线程修改了自己工作内存中变量，对其他线程是不可见的，会导致线程不安全的问题。因为JMM制定了一套标准来保证开发者在编写多线程程序的时候，能够控制什么时候内存会被同步给其他线程。<br><img src=\"/source/images/jus/JMM1.png\" alt=\"alt\"></p>\n<h3 id=\"内存之间的交互操作\"><a href=\"#内存之间的交互操作\" class=\"headerlink\" title=\"内存之间的交互操作\"></a>内存之间的交互操作</h3><p>内存交互操作有8种，虚拟机实现必须保证每一个操作都是原子的，不可在分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许例外）</p>\n<ul>\n<li>lock     （锁定）：作用于主内存的变量，把一个变量标识为线程独占状态</li>\n<li>unlock （解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li>\n<li>read    （读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用</li>\n<li>load     （载入）：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中</li>\n<li>use      （使用）：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令</li>\n<li>assign  （赋值）：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中</li>\n<li>store    （存储）：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用</li>\n<li>write 　（写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中</li>\n</ul>\n<p>　　JMM对这八种指令的使用，制定了如下规则：</p>\n<ul>\n<li>不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write</li>\n<li>不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存</li>\n<li>不允许一个线程将没有assign的数据从工作内存同步回主内存</li>\n<li>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作</li>\n<li>一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁</li>\n<li>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值</li>\n<li>如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量</li>\n<li>对一个变量进行unlock操作之前，必须把此变量同步回主内存</li>\n</ul>\n<p>JMM对这八种操作规则和对volatile的一些特殊规则就能确定哪里操作是线程安全，哪些操作是线程不安全的了。但是这些规则实在复杂，很难在实践中直接分析。所以一般我们也不会通过上述规则进行分析。更多的时候，使用java的happen-before规则来进行分析。</p>\n<h2 id=\"Happen-Before（先行发生规则）\"><a href=\"#Happen-Before（先行发生规则）\" class=\"headerlink\" title=\"Happen-Before（先行发生规则）\"></a>Happen-Before（先行发生规则）</h2><p>　　在常规的开发中，如果我们通过上述规则来分析一个并发程序是否安全，估计脑壳会很疼。因为更多时候，我们是分析一个并发程序是否安全，其实都依赖Happen-Before原则进行分析。Happen-Before被翻译成先行发生原则，意思就是当A操作先行发生于B操作，则在发生B操作的时候，操作A产生的影响能被B观察到，“影响”包括修改了内存中的共享变量的值、发送了消息、调用了方法等。</p>\n<p>　　Happen-Before的规则有以下几条</p>\n<ul>\n<li>程序次序规则（Program Order Rule）：在一个线程内，程序的执行规则跟程序的书写规则是一致的，从上往下执行。</li>\n<li>管程锁定规则（Monitor Lock Rule）：一个Unlock的操作肯定先于下一次Lock的操作。这里必须是同一个锁。同理我们可以认为在synchronized同步同一个锁的时候，锁内先行执行的代码，对后续同步该锁的线程来说是完全可见的。</li>\n<li>volatile变量规则（volatile Variable Rule）：对同一个volatile的变量，先行发生的写操作，肯定早于后续发生的读操作</li>\n<li>线程启动规则（Thread Start Rule）：Thread对象的start()方法先行发生于此线程的没一个动作</li>\n<li>线程中止规则（Thread Termination Rule）：Thread对象的中止检测（如：Thread.join()，Thread.isAlive()等）操作，必行晚于线程中所有操作</li>\n<li>线程中断规则（Thread Interruption Rule）：对线程的interruption（）调用，先于被调用的线程检测中断事件(Thread.interrupted())的发生</li>\n<li>对象中止规则（Finalizer Rule）：一个对象的初始化方法先于一个方法执行Finalizer()方法</li>\n<li>传递性（Transitivity）：如果操作A先于操作B、操作B先于操作C,则操作A先于操作C</li>\n</ul>\n<p>　　以上就是Happen-Before中的规则。通过这些条件的判定，仍然很难判断一个线程是否能安全执行，毕竟在我们的时候线程安全多数依赖于工具类的安全性来保证。想提高自己对线程是否安全的判断能力，必然需要理解所使用的框架或者工具的实现，并积累线程安全的经验。</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"http://tutorials.jenkov.com/java-concurrency/java-memory-model.html\" target=\"_blank\" rel=\"noopener\">http://tutorials.jenkov.com/java-concurrency/java-memory-model.html</a></li>\n<li>深入理解java虚拟第12张</li>\n</ul>\n"},{"title":"markdown简单语法","date":"2019-06-18T14:25:56.000Z","_content":"\n\n## markdown语法\n### 1. 斜体和粗体\n\n使用 * 和 ** 表示斜体和粗体。\n\n示例：\n\n这是 *斜体*，这是 **粗体**。\n\n### 2. 分级标题\n\n使用 === 表示一级标题，使用 --- 表示二级标题。\n\n示例：\n\n```\n这是一个一级标题\n============================\n\n这是一个二级标题\n--------------------------------------------------\n\n### 这是一个三级标题\n```\n\n你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ## H2, ### H3，#### H4。\n\n### 3. 外链接\n\n使用 \\[描述](链接地址) 为文字增加外链接。\n\n示例：[我的博客](http://www.wuxiantao123.cn)\n\n### 4. 无序列表\n\n使用 *，+，- 表示无序列表。\n\n示例：\n\n- 无序列表项 一\n- 无序列表项 二\n- 无序列表项 三\n\n\n### 5. 有序列表\n\n使用数字和点表示有序列表。\n\n示例：\n\n1. 有序列表项 一\n2. 有序列表项 二\n3. 有序列表项 三\n\n### 6. 文字引用\n\n使用 > 表示文字引用。\n\n示例：\n\n> 野火烧不尽，春风吹又生。\n\n### 7. 行内代码块\n\n使用 \\`代码` 表示行内代码块。\n\n示例：让我们聊聊 `html`。\n\n\n### 8.  插入图像\n\n使用 \\!\\[描述](图片链接地址) 插入图像。\n\n示例：\n\n![我的头像](https://www.zybuluo.com/static/img/my_head.jpg)\n\n","source":"_posts/markdown简单语法.md","raw":"---\ntitle: markdown简单语法\ndate: 2019-06-18 22:25:56\ncategories: markdown\ntags: 工具\n---\n\n\n## markdown语法\n### 1. 斜体和粗体\n\n使用 * 和 ** 表示斜体和粗体。\n\n示例：\n\n这是 *斜体*，这是 **粗体**。\n\n### 2. 分级标题\n\n使用 === 表示一级标题，使用 --- 表示二级标题。\n\n示例：\n\n```\n这是一个一级标题\n============================\n\n这是一个二级标题\n--------------------------------------------------\n\n### 这是一个三级标题\n```\n\n你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ## H2, ### H3，#### H4。\n\n### 3. 外链接\n\n使用 \\[描述](链接地址) 为文字增加外链接。\n\n示例：[我的博客](http://www.wuxiantao123.cn)\n\n### 4. 无序列表\n\n使用 *，+，- 表示无序列表。\n\n示例：\n\n- 无序列表项 一\n- 无序列表项 二\n- 无序列表项 三\n\n\n### 5. 有序列表\n\n使用数字和点表示有序列表。\n\n示例：\n\n1. 有序列表项 一\n2. 有序列表项 二\n3. 有序列表项 三\n\n### 6. 文字引用\n\n使用 > 表示文字引用。\n\n示例：\n\n> 野火烧不尽，春风吹又生。\n\n### 7. 行内代码块\n\n使用 \\`代码` 表示行内代码块。\n\n示例：让我们聊聊 `html`。\n\n\n### 8.  插入图像\n\n使用 \\!\\[描述](图片链接地址) 插入图像。\n\n示例：\n\n![我的头像](https://www.zybuluo.com/static/img/my_head.jpg)\n\n","slug":"markdown简单语法","published":1,"updated":"2019-07-02T11:21:32.690Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzjwwmf000zw4j93lc1erlq","content":"<h2 id=\"markdown语法\"><a href=\"#markdown语法\" class=\"headerlink\" title=\"markdown语法\"></a>markdown语法</h2><h3 id=\"1-斜体和粗体\"><a href=\"#1-斜体和粗体\" class=\"headerlink\" title=\"1. 斜体和粗体\"></a>1. 斜体和粗体</h3><p>使用 * 和 ** 表示斜体和粗体。</p>\n<p>示例：</p>\n<p>这是 <em>斜体</em>，这是 <strong>粗体</strong>。</p>\n<h3 id=\"2-分级标题\"><a href=\"#2-分级标题\" class=\"headerlink\" title=\"2. 分级标题\"></a>2. 分级标题</h3><p>使用 === 表示一级标题，使用 — 表示二级标题。</p>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这是一个一级标题</span><br><span class=\"line\">============================</span><br><span class=\"line\"></span><br><span class=\"line\">这是一个二级标题</span><br><span class=\"line\">--------------------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">### 这是一个三级标题</span><br></pre></td></tr></table></figure>\n\n<p>你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ## H2, ### H3，#### H4。</p>\n<h3 id=\"3-外链接\"><a href=\"#3-外链接\" class=\"headerlink\" title=\"3. 外链接\"></a>3. 外链接</h3><p>使用 [描述](链接地址) 为文字增加外链接。</p>\n<p>示例：<a href=\"http://www.wuxiantao123.cn\">我的博客</a></p>\n<h3 id=\"4-无序列表\"><a href=\"#4-无序列表\" class=\"headerlink\" title=\"4. 无序列表\"></a>4. 无序列表</h3><p>使用 *，+，- 表示无序列表。</p>\n<p>示例：</p>\n<ul>\n<li>无序列表项 一</li>\n<li>无序列表项 二</li>\n<li>无序列表项 三</li>\n</ul>\n<h3 id=\"5-有序列表\"><a href=\"#5-有序列表\" class=\"headerlink\" title=\"5. 有序列表\"></a>5. 有序列表</h3><p>使用数字和点表示有序列表。</p>\n<p>示例：</p>\n<ol>\n<li>有序列表项 一</li>\n<li>有序列表项 二</li>\n<li>有序列表项 三</li>\n</ol>\n<h3 id=\"6-文字引用\"><a href=\"#6-文字引用\" class=\"headerlink\" title=\"6. 文字引用\"></a>6. 文字引用</h3><p>使用 &gt; 表示文字引用。</p>\n<p>示例：</p>\n<blockquote>\n<p>野火烧不尽，春风吹又生。</p>\n</blockquote>\n<h3 id=\"7-行内代码块\"><a href=\"#7-行内代码块\" class=\"headerlink\" title=\"7. 行内代码块\"></a>7. 行内代码块</h3><p>使用 `代码` 表示行内代码块。</p>\n<p>示例：让我们聊聊 <code>html</code>。</p>\n<h3 id=\"8-插入图像\"><a href=\"#8-插入图像\" class=\"headerlink\" title=\"8.  插入图像\"></a>8.  插入图像</h3><p>使用 ![描述](图片链接地址) 插入图像。</p>\n<p>示例：</p>\n<p><img src=\"https://www.zybuluo.com/static/img/my_head.jpg\" alt=\"我的头像\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"markdown语法\"><a href=\"#markdown语法\" class=\"headerlink\" title=\"markdown语法\"></a>markdown语法</h2><h3 id=\"1-斜体和粗体\"><a href=\"#1-斜体和粗体\" class=\"headerlink\" title=\"1. 斜体和粗体\"></a>1. 斜体和粗体</h3><p>使用 * 和 ** 表示斜体和粗体。</p>\n<p>示例：</p>\n<p>这是 <em>斜体</em>，这是 <strong>粗体</strong>。</p>\n<h3 id=\"2-分级标题\"><a href=\"#2-分级标题\" class=\"headerlink\" title=\"2. 分级标题\"></a>2. 分级标题</h3><p>使用 === 表示一级标题，使用 — 表示二级标题。</p>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这是一个一级标题</span><br><span class=\"line\">============================</span><br><span class=\"line\"></span><br><span class=\"line\">这是一个二级标题</span><br><span class=\"line\">--------------------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">### 这是一个三级标题</span><br></pre></td></tr></table></figure>\n\n<p>你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ## H2, ### H3，#### H4。</p>\n<h3 id=\"3-外链接\"><a href=\"#3-外链接\" class=\"headerlink\" title=\"3. 外链接\"></a>3. 外链接</h3><p>使用 [描述](链接地址) 为文字增加外链接。</p>\n<p>示例：<a href=\"http://www.wuxiantao123.cn\">我的博客</a></p>\n<h3 id=\"4-无序列表\"><a href=\"#4-无序列表\" class=\"headerlink\" title=\"4. 无序列表\"></a>4. 无序列表</h3><p>使用 *，+，- 表示无序列表。</p>\n<p>示例：</p>\n<ul>\n<li>无序列表项 一</li>\n<li>无序列表项 二</li>\n<li>无序列表项 三</li>\n</ul>\n<h3 id=\"5-有序列表\"><a href=\"#5-有序列表\" class=\"headerlink\" title=\"5. 有序列表\"></a>5. 有序列表</h3><p>使用数字和点表示有序列表。</p>\n<p>示例：</p>\n<ol>\n<li>有序列表项 一</li>\n<li>有序列表项 二</li>\n<li>有序列表项 三</li>\n</ol>\n<h3 id=\"6-文字引用\"><a href=\"#6-文字引用\" class=\"headerlink\" title=\"6. 文字引用\"></a>6. 文字引用</h3><p>使用 &gt; 表示文字引用。</p>\n<p>示例：</p>\n<blockquote>\n<p>野火烧不尽，春风吹又生。</p>\n</blockquote>\n<h3 id=\"7-行内代码块\"><a href=\"#7-行内代码块\" class=\"headerlink\" title=\"7. 行内代码块\"></a>7. 行内代码块</h3><p>使用 `代码` 表示行内代码块。</p>\n<p>示例：让我们聊聊 <code>html</code>。</p>\n<h3 id=\"8-插入图像\"><a href=\"#8-插入图像\" class=\"headerlink\" title=\"8.  插入图像\"></a>8.  插入图像</h3><p>使用 ![描述](图片链接地址) 插入图像。</p>\n<p>示例：</p>\n<p><img src=\"https://www.zybuluo.com/static/img/my_head.jpg\" alt=\"我的头像\"></p>\n"},{"title":"markdown高阶语法","date":"2019-06-18T14:39:10.000Z","_content":"\n# Markdown 高阶语法手册\n\n### 1. 内容目录\n\n在段落中填写 `[TOC]` 以显示全文内容的目录结构。\n\n[TOC]\n\n### 2. 标签分类\n\n在编辑区任意行的列首位置输入以下代码给文稿标签：\n\n标签： 数学 英语 Markdown\n\n或者\n\nTags： 数学 英语 Markdown\n\n### 3. 删除线\n\n使用 ~~ 表示删除线。\n\n~~这是一段错误的文本。~~\n\n### 4. 注脚\n\n使用 [^keyword] 表示注脚。\n\n这是一个注脚[^footnote]的样例。\n\n这是第二个注脚[^footnote2]的样例。\n\n### 5. LaTeX 公式\n\n$ 表示行内公式： \n\n质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。\n\n$$ 表示整行公式：\n\n$$\\sum_{i=1}^n a_i=0$$\n\n$$f(x_1,x_x,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2 $$\n\n$$\\sum^{j-1}_{k=0}{\\widehat{\\gamma}_{kj} z_k}$$\n\n访问 [MathJax](http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference) 参考更多使用方法。\n\n### 6. 加强的代码块\n\n支持四十一种编程语言的语法高亮的显示，行号显示。\n\n非代码示例：\n\n```\n$ sudo apt-get install vim-gnome\n```\n\nPython 示例：\n\n```python\n@requires_authorization\ndef somefunc(param1='', param2=0):\n    '''A docstring'''\n    if param1 > param2: # interesting\n        print 'Greater'\n    return (param2 - param1 + 1) or None\n\nclass SomeClass:\n    pass\n\n>>> message = '''interpreter\n... prompt'''\n```\n\nJavaScript 示例：\n\n``` javascript\n/**\n* nth element in the fibonacci series.\n* @param n >= 0\n* @return the nth element, >= 0.\n*/\nfunction fib(n) {\n  var a = 1, b = 1;\n  var tmp;\n  while (--n >= 0) {\n    tmp = a;\n    a += b;\n    b = tmp;\n  }\n  return a;\n}\n\ndocument.write(fib(10));\n```\n\n### 7. 流程图\n\n#### 示例\n\n```flow\nst=>start: Start:>https://www.zybuluo.com\nio=>inputoutput: verification\nop=>operation: Your Operation\ncond=>condition: Yes or No?\nsub=>subroutine: Your Subroutine\ne=>end\n\nst->io->op->cond\ncond(yes)->e\ncond(no)->sub->io\n```\n\n#### 更多语法参考：[流程图语法参考](http://adrai.github.io/flowchart.js/)\n\n### 8. 序列图\n\n#### 示例 1\n\n```seq\nAlice->Bob: Hello Bob, how are you?\nNote right of Bob: Bob thinks\nBob-->Alice: I am good thanks!\n```\n\n#### 示例 2\n\n```seq\nTitle: Here is a title\nA->B: Normal line\nB-->C: Dashed line\nC->>D: Open arrow\nD-->>A: Dashed open arrow\n```\n\n#### 更多语法参考：[序列图语法参考](http://bramp.github.io/js-sequence-diagrams/)\n\n### 9. 甘特图\n\n甘特图内在思想简单。基本是一条线条图，横轴表示时间，纵轴表示活动（项目），线条表示在整个期间上计划和实际的活动完成情况。它直观地表明任务计划在什么时候进行，及实际进展与计划要求的对比。\n\n```gantt\n    title 项目开发流程\n    section 项目确定\n        需求分析       :a1, 2016-06-22, 3d\n        可行性报告     :after a1, 5d\n        概念验证       : 5d\n    section 项目实施\n        概要设计      :2016-07-05  , 5d\n        详细设计      :2016-07-08, 10d\n        编码          :2016-07-15, 10d\n        测试          :2016-07-22, 5d\n    section 发布验收\n        发布: 2d\n        验收: 3d\n```\n\n#### 更多语法参考：[甘特图语法参考](https://knsv.github.io/mermaid/#gant-diagrams)\n\n### 10. Mermaid 流程图\n\n```graphLR\n    A[Hard edge] -->|Link text| B(Round edge)\n    B --> C{Decision}\n    C -->|One| D[Result one]\n    C -->|Two| E[Result two]\n```\n\n#### 更多语法参考：[Mermaid 流程图语法参考](https://knsv.github.io/mermaid/#flowcharts-basic-syntax)\n\n### 11. Mermaid 序列图\n\n```sequence\n    Alice->John: Hello John, how are you?\n    loop every minute\n        John-->Alice: Great!\n    end\n```\n\n#### 更多语法参考：[Mermaid 序列图语法参考](https://knsv.github.io/mermaid/#sequence-diagrams)\n\n### 12. 表格支持\n\n| 项目        | 价格   |  数量  |\n| --------   | -----:  | :----:  |\n| 计算机     | \\$1600 |   5     |\n| 手机        |   \\$12   |   12   |\n| 管线        |    \\$1    |  234  |\n\n\n### 13. 定义型列表\n\n名词 1\n:   定义 1（左侧有一个可见的冒号和四个不可见的空格）\n\n代码块 2\n:   这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）\n\n        代码块（左侧有八个不可见的空格）\n\n### 14. Html 标签\n\n本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格：\n\n    <table>\n        <tr>\n            <th rowspan=\"2\">值班人员</th>\n            <th>星期一</th>\n            <th>星期二</th>\n            <th>星期三</th>\n        </tr>\n        <tr>\n            <td>李强</td>\n            <td>张明</td>\n            <td>王平</td>\n        </tr>\n    </table>\n\n\n<table>\n    <tr>\n        <th rowspan=\"2\">值班人员</th>\n        <th>星期一</th>\n        <th>星期二</th>\n        <th>星期三</th>\n    </tr>\n    <tr>\n        <td>李强</td>\n        <td>张明</td>\n        <td>王平</td>\n    </tr>\n</table>\n\n### 15. 内嵌图标\n\n本站的图标系统对外开放，在文档中输入\n\n    <i class=\"icon-weibo\"></i>\n\n即显示微博的图标： <i class=\"icon-weibo icon-2x\"></i>\n\n替换 上述 `i 标签` 内的 `icon-weibo` 以显示不同的图标，例如：\n\n    <i class=\"icon-renren\"></i>\n\n即显示人人的图标： <i class=\"icon-renren icon-2x\"></i>\n\n更多的图标和玩法可以参看 [font-awesome](http://fortawesome.github.io/Font-Awesome/3.2.1/icons/) 官方网站。\n\n### 16. 待办事宜 Todo 列表\n\n使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如：\n\n    - [ ] **Cmd Markdown 开发**\n        - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率\n        - [ ] 支持以 PDF 格式导出文稿\n        - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments)\n        - [x] 改进 LaTex 功能\n            - [x] 修复 LaTex 公式渲染问题\n            - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers)\n    - [ ] **七月旅行准备**\n        - [ ] 准备邮轮上需要携带的物品\n        - [ ] 浏览日本免税店的物品\n        - [x] 购买蓝宝石公主号七月一日的船票\n        \n对应显示如下待办事宜 Todo 列表：\n        \n- [ ] **Cmd Markdown 开发**\n    - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率\n    - [ ] 支持以 PDF 格式导出文稿\n    - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments)\n    - [x] 改进 LaTex 功能\n        - [x] 修复 LaTex 公式渲染问题\n        - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers)\n- [ ] **七月旅行准备**\n    - [ ] 准备邮轮上需要携带的物品\n    - [ ] 浏览日本免税店的物品\n    - [x] 购买蓝宝石公主号七月一日的船票\n        \n        \n[^footnote]: 这是一个 *注脚* 的 **文本**。\n\n[^footnote2]: 这是另一个 *注脚* 的 **文本**。","source":"_posts/markdown高阶语法.md","raw":"---\ntitle: markdown高阶语法\ndate: 2019-06-18 22:39:10\ncategories: markdown\ntags: 工具\n---\n\n# Markdown 高阶语法手册\n\n### 1. 内容目录\n\n在段落中填写 `[TOC]` 以显示全文内容的目录结构。\n\n[TOC]\n\n### 2. 标签分类\n\n在编辑区任意行的列首位置输入以下代码给文稿标签：\n\n标签： 数学 英语 Markdown\n\n或者\n\nTags： 数学 英语 Markdown\n\n### 3. 删除线\n\n使用 ~~ 表示删除线。\n\n~~这是一段错误的文本。~~\n\n### 4. 注脚\n\n使用 [^keyword] 表示注脚。\n\n这是一个注脚[^footnote]的样例。\n\n这是第二个注脚[^footnote2]的样例。\n\n### 5. LaTeX 公式\n\n$ 表示行内公式： \n\n质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。\n\n$$ 表示整行公式：\n\n$$\\sum_{i=1}^n a_i=0$$\n\n$$f(x_1,x_x,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2 $$\n\n$$\\sum^{j-1}_{k=0}{\\widehat{\\gamma}_{kj} z_k}$$\n\n访问 [MathJax](http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference) 参考更多使用方法。\n\n### 6. 加强的代码块\n\n支持四十一种编程语言的语法高亮的显示，行号显示。\n\n非代码示例：\n\n```\n$ sudo apt-get install vim-gnome\n```\n\nPython 示例：\n\n```python\n@requires_authorization\ndef somefunc(param1='', param2=0):\n    '''A docstring'''\n    if param1 > param2: # interesting\n        print 'Greater'\n    return (param2 - param1 + 1) or None\n\nclass SomeClass:\n    pass\n\n>>> message = '''interpreter\n... prompt'''\n```\n\nJavaScript 示例：\n\n``` javascript\n/**\n* nth element in the fibonacci series.\n* @param n >= 0\n* @return the nth element, >= 0.\n*/\nfunction fib(n) {\n  var a = 1, b = 1;\n  var tmp;\n  while (--n >= 0) {\n    tmp = a;\n    a += b;\n    b = tmp;\n  }\n  return a;\n}\n\ndocument.write(fib(10));\n```\n\n### 7. 流程图\n\n#### 示例\n\n```flow\nst=>start: Start:>https://www.zybuluo.com\nio=>inputoutput: verification\nop=>operation: Your Operation\ncond=>condition: Yes or No?\nsub=>subroutine: Your Subroutine\ne=>end\n\nst->io->op->cond\ncond(yes)->e\ncond(no)->sub->io\n```\n\n#### 更多语法参考：[流程图语法参考](http://adrai.github.io/flowchart.js/)\n\n### 8. 序列图\n\n#### 示例 1\n\n```seq\nAlice->Bob: Hello Bob, how are you?\nNote right of Bob: Bob thinks\nBob-->Alice: I am good thanks!\n```\n\n#### 示例 2\n\n```seq\nTitle: Here is a title\nA->B: Normal line\nB-->C: Dashed line\nC->>D: Open arrow\nD-->>A: Dashed open arrow\n```\n\n#### 更多语法参考：[序列图语法参考](http://bramp.github.io/js-sequence-diagrams/)\n\n### 9. 甘特图\n\n甘特图内在思想简单。基本是一条线条图，横轴表示时间，纵轴表示活动（项目），线条表示在整个期间上计划和实际的活动完成情况。它直观地表明任务计划在什么时候进行，及实际进展与计划要求的对比。\n\n```gantt\n    title 项目开发流程\n    section 项目确定\n        需求分析       :a1, 2016-06-22, 3d\n        可行性报告     :after a1, 5d\n        概念验证       : 5d\n    section 项目实施\n        概要设计      :2016-07-05  , 5d\n        详细设计      :2016-07-08, 10d\n        编码          :2016-07-15, 10d\n        测试          :2016-07-22, 5d\n    section 发布验收\n        发布: 2d\n        验收: 3d\n```\n\n#### 更多语法参考：[甘特图语法参考](https://knsv.github.io/mermaid/#gant-diagrams)\n\n### 10. Mermaid 流程图\n\n```graphLR\n    A[Hard edge] -->|Link text| B(Round edge)\n    B --> C{Decision}\n    C -->|One| D[Result one]\n    C -->|Two| E[Result two]\n```\n\n#### 更多语法参考：[Mermaid 流程图语法参考](https://knsv.github.io/mermaid/#flowcharts-basic-syntax)\n\n### 11. Mermaid 序列图\n\n```sequence\n    Alice->John: Hello John, how are you?\n    loop every minute\n        John-->Alice: Great!\n    end\n```\n\n#### 更多语法参考：[Mermaid 序列图语法参考](https://knsv.github.io/mermaid/#sequence-diagrams)\n\n### 12. 表格支持\n\n| 项目        | 价格   |  数量  |\n| --------   | -----:  | :----:  |\n| 计算机     | \\$1600 |   5     |\n| 手机        |   \\$12   |   12   |\n| 管线        |    \\$1    |  234  |\n\n\n### 13. 定义型列表\n\n名词 1\n:   定义 1（左侧有一个可见的冒号和四个不可见的空格）\n\n代码块 2\n:   这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）\n\n        代码块（左侧有八个不可见的空格）\n\n### 14. Html 标签\n\n本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格：\n\n    <table>\n        <tr>\n            <th rowspan=\"2\">值班人员</th>\n            <th>星期一</th>\n            <th>星期二</th>\n            <th>星期三</th>\n        </tr>\n        <tr>\n            <td>李强</td>\n            <td>张明</td>\n            <td>王平</td>\n        </tr>\n    </table>\n\n\n<table>\n    <tr>\n        <th rowspan=\"2\">值班人员</th>\n        <th>星期一</th>\n        <th>星期二</th>\n        <th>星期三</th>\n    </tr>\n    <tr>\n        <td>李强</td>\n        <td>张明</td>\n        <td>王平</td>\n    </tr>\n</table>\n\n### 15. 内嵌图标\n\n本站的图标系统对外开放，在文档中输入\n\n    <i class=\"icon-weibo\"></i>\n\n即显示微博的图标： <i class=\"icon-weibo icon-2x\"></i>\n\n替换 上述 `i 标签` 内的 `icon-weibo` 以显示不同的图标，例如：\n\n    <i class=\"icon-renren\"></i>\n\n即显示人人的图标： <i class=\"icon-renren icon-2x\"></i>\n\n更多的图标和玩法可以参看 [font-awesome](http://fortawesome.github.io/Font-Awesome/3.2.1/icons/) 官方网站。\n\n### 16. 待办事宜 Todo 列表\n\n使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如：\n\n    - [ ] **Cmd Markdown 开发**\n        - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率\n        - [ ] 支持以 PDF 格式导出文稿\n        - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments)\n        - [x] 改进 LaTex 功能\n            - [x] 修复 LaTex 公式渲染问题\n            - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers)\n    - [ ] **七月旅行准备**\n        - [ ] 准备邮轮上需要携带的物品\n        - [ ] 浏览日本免税店的物品\n        - [x] 购买蓝宝石公主号七月一日的船票\n        \n对应显示如下待办事宜 Todo 列表：\n        \n- [ ] **Cmd Markdown 开发**\n    - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率\n    - [ ] 支持以 PDF 格式导出文稿\n    - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments)\n    - [x] 改进 LaTex 功能\n        - [x] 修复 LaTex 公式渲染问题\n        - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers)\n- [ ] **七月旅行准备**\n    - [ ] 准备邮轮上需要携带的物品\n    - [ ] 浏览日本免税店的物品\n    - [x] 购买蓝宝石公主号七月一日的船票\n        \n        \n[^footnote]: 这是一个 *注脚* 的 **文本**。\n\n[^footnote2]: 这是另一个 *注脚* 的 **文本**。","slug":"markdown高阶语法","published":1,"updated":"2019-07-02T11:21:32.693Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzjwwmh0012w4j9lhkwinl6","content":"<h1 id=\"Markdown-高阶语法手册\"><a href=\"#Markdown-高阶语法手册\" class=\"headerlink\" title=\"Markdown 高阶语法手册\"></a>Markdown 高阶语法手册</h1><h3 id=\"1-内容目录\"><a href=\"#1-内容目录\" class=\"headerlink\" title=\"1. 内容目录\"></a>1. 内容目录</h3><p>在段落中填写 <code>[TOC]</code> 以显示全文内容的目录结构。</p>\n<p>[TOC]</p>\n<h3 id=\"2-标签分类\"><a href=\"#2-标签分类\" class=\"headerlink\" title=\"2. 标签分类\"></a>2. 标签分类</h3><p>在编辑区任意行的列首位置输入以下代码给文稿标签：</p>\n<p>标签： 数学 英语 Markdown</p>\n<p>或者</p>\n<p>Tags： 数学 英语 Markdown</p>\n<h3 id=\"3-删除线\"><a href=\"#3-删除线\" class=\"headerlink\" title=\"3. 删除线\"></a>3. 删除线</h3><p>使用 ~~ 表示删除线。</p>\n<p><del>这是一段错误的文本。</del></p>\n<h3 id=\"4-注脚\"><a href=\"#4-注脚\" class=\"headerlink\" title=\"4. 注脚\"></a>4. 注脚</h3><p>使用 [^keyword] 表示注脚。</p>\n<p>这是一个注脚[^footnote]的样例。</p>\n<p>这是第二个注脚[^footnote2]的样例。</p>\n<h3 id=\"5-LaTeX-公式\"><a href=\"#5-LaTeX-公式\" class=\"headerlink\" title=\"5. LaTeX 公式\"></a>5. LaTeX 公式</h3><p>$ 表示行内公式： </p>\n<p>质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。</p>\n<p>$$ 表示整行公式：</p>\n<p>$$\\sum_{i=1}^n a_i=0$$</p>\n<p>$$f(x_1,x_x,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2 $$</p>\n<p>$$\\sum^{j-1}<em>{k=0}{\\widehat{\\gamma}</em>{kj} z_k}$$</p>\n<p>访问 <a href=\"http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference\" target=\"_blank\" rel=\"noopener\">MathJax</a> 参考更多使用方法。</p>\n<h3 id=\"6-加强的代码块\"><a href=\"#6-加强的代码块\" class=\"headerlink\" title=\"6. 加强的代码块\"></a>6. 加强的代码块</h3><p>支持四十一种编程语言的语法高亮的显示，行号显示。</p>\n<p>非代码示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install vim-gnome</span><br></pre></td></tr></table></figure>\n\n<p>Python 示例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@requires_authorization</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">somefunc</span><span class=\"params\">(param1=<span class=\"string\">''</span>, param2=<span class=\"number\">0</span>)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">'''A docstring'''</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> param1 &gt; param2: <span class=\"comment\"># interesting</span></span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">'Greater'</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (param2 - param1 + <span class=\"number\">1</span>) <span class=\"keyword\">or</span> <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeClass</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>message = <span class=\"string\">'''interpreter</span></span><br><span class=\"line\"><span class=\"string\"><span class=\"meta\">... </span>prompt'''</span></span><br></pre></td></tr></table></figure>\n\n<p>JavaScript 示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* nth element in the fibonacci series.</span></span><br><span class=\"line\"><span class=\"comment\">* @param n &gt;= 0</span></span><br><span class=\"line\"><span class=\"comment\">* @return the nth element, &gt;= 0.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fib</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>, b = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> tmp;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (--n &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    tmp = a;</span><br><span class=\"line\">    a += b;</span><br><span class=\"line\">    b = tmp;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(fib(<span class=\"number\">10</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-流程图\"><a href=\"#7-流程图\" class=\"headerlink\" title=\"7. 流程图\"></a>7. 流程图</h3><h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">st=&gt;start: Start:&gt;https://www.zybuluo.com</span><br><span class=\"line\">io=&gt;inputoutput: verification</span><br><span class=\"line\">op=&gt;operation: Your Operation</span><br><span class=\"line\">cond=&gt;condition: Yes or No?</span><br><span class=\"line\">sub=&gt;subroutine: Your Subroutine</span><br><span class=\"line\">e=&gt;end</span><br><span class=\"line\"></span><br><span class=\"line\">st-&gt;io-&gt;op-&gt;cond</span><br><span class=\"line\">cond(yes)-&gt;e</span><br><span class=\"line\">cond(no)-&gt;sub-&gt;io</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"更多语法参考：流程图语法参考\"><a href=\"#更多语法参考：流程图语法参考\" class=\"headerlink\" title=\"更多语法参考：流程图语法参考\"></a>更多语法参考：<a href=\"http://adrai.github.io/flowchart.js/\" target=\"_blank\" rel=\"noopener\">流程图语法参考</a></h4><h3 id=\"8-序列图\"><a href=\"#8-序列图\" class=\"headerlink\" title=\"8. 序列图\"></a>8. 序列图</h3><h4 id=\"示例-1\"><a href=\"#示例-1\" class=\"headerlink\" title=\"示例 1\"></a>示例 1</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Alice-&gt;Bob: Hello Bob, how are you?</span><br><span class=\"line\">Note right of Bob: Bob thinks</span><br><span class=\"line\">Bob--&gt;Alice: I am good thanks!</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"示例-2\"><a href=\"#示例-2\" class=\"headerlink\" title=\"示例 2\"></a>示例 2</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Title: Here is a title</span><br><span class=\"line\">A-&gt;B: Normal line</span><br><span class=\"line\">B--&gt;C: Dashed line</span><br><span class=\"line\">C-&gt;&gt;D: Open arrow</span><br><span class=\"line\">D--&gt;&gt;A: Dashed open arrow</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"更多语法参考：序列图语法参考\"><a href=\"#更多语法参考：序列图语法参考\" class=\"headerlink\" title=\"更多语法参考：序列图语法参考\"></a>更多语法参考：<a href=\"http://bramp.github.io/js-sequence-diagrams/\" target=\"_blank\" rel=\"noopener\">序列图语法参考</a></h4><h3 id=\"9-甘特图\"><a href=\"#9-甘特图\" class=\"headerlink\" title=\"9. 甘特图\"></a>9. 甘特图</h3><p>甘特图内在思想简单。基本是一条线条图，横轴表示时间，纵轴表示活动（项目），线条表示在整个期间上计划和实际的活动完成情况。它直观地表明任务计划在什么时候进行，及实际进展与计划要求的对比。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title 项目开发流程</span><br><span class=\"line\">section 项目确定</span><br><span class=\"line\">    需求分析       :a1, 2016-06-22, 3d</span><br><span class=\"line\">    可行性报告     :after a1, 5d</span><br><span class=\"line\">    概念验证       : 5d</span><br><span class=\"line\">section 项目实施</span><br><span class=\"line\">    概要设计      :2016-07-05  , 5d</span><br><span class=\"line\">    详细设计      :2016-07-08, 10d</span><br><span class=\"line\">    编码          :2016-07-15, 10d</span><br><span class=\"line\">    测试          :2016-07-22, 5d</span><br><span class=\"line\">section 发布验收</span><br><span class=\"line\">    发布: 2d</span><br><span class=\"line\">    验收: 3d</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"更多语法参考：甘特图语法参考\"><a href=\"#更多语法参考：甘特图语法参考\" class=\"headerlink\" title=\"更多语法参考：甘特图语法参考\"></a>更多语法参考：<a href=\"https://knsv.github.io/mermaid/#gant-diagrams\" target=\"_blank\" rel=\"noopener\">甘特图语法参考</a></h4><h3 id=\"10-Mermaid-流程图\"><a href=\"#10-Mermaid-流程图\" class=\"headerlink\" title=\"10. Mermaid 流程图\"></a>10. Mermaid 流程图</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A[Hard edge] --&gt;|Link text| B(Round edge)</span><br><span class=\"line\">B --&gt; C&#123;Decision&#125;</span><br><span class=\"line\">C --&gt;|One| D[Result one]</span><br><span class=\"line\">C --&gt;|Two| E[Result two]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"更多语法参考：Mermaid-流程图语法参考\"><a href=\"#更多语法参考：Mermaid-流程图语法参考\" class=\"headerlink\" title=\"更多语法参考：Mermaid 流程图语法参考\"></a>更多语法参考：<a href=\"https://knsv.github.io/mermaid/#flowcharts-basic-syntax\" target=\"_blank\" rel=\"noopener\">Mermaid 流程图语法参考</a></h4><h3 id=\"11-Mermaid-序列图\"><a href=\"#11-Mermaid-序列图\" class=\"headerlink\" title=\"11. Mermaid 序列图\"></a>11. Mermaid 序列图</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Alice-&gt;John: Hello John, how are you?</span><br><span class=\"line\">loop every minute</span><br><span class=\"line\">    John--&gt;Alice: Great!</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"更多语法参考：Mermaid-序列图语法参考\"><a href=\"#更多语法参考：Mermaid-序列图语法参考\" class=\"headerlink\" title=\"更多语法参考：Mermaid 序列图语法参考\"></a>更多语法参考：<a href=\"https://knsv.github.io/mermaid/#sequence-diagrams\" target=\"_blank\" rel=\"noopener\">Mermaid 序列图语法参考</a></h4><h3 id=\"12-表格支持\"><a href=\"#12-表格支持\" class=\"headerlink\" title=\"12. 表格支持\"></a>12. 表格支持</h3><table>\n<thead>\n<tr>\n<th>项目</th>\n<th align=\"right\">价格</th>\n<th align=\"center\">数量</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>计算机</td>\n<td align=\"right\">$1600</td>\n<td align=\"center\">5</td>\n</tr>\n<tr>\n<td>手机</td>\n<td align=\"right\">$12</td>\n<td align=\"center\">12</td>\n</tr>\n<tr>\n<td>管线</td>\n<td align=\"right\">$1</td>\n<td align=\"center\">234</td>\n</tr>\n</tbody></table>\n<h3 id=\"13-定义型列表\"><a href=\"#13-定义型列表\" class=\"headerlink\" title=\"13. 定义型列表\"></a>13. 定义型列表</h3><dl><dt>名词 1</dt><dd>定义 1（左侧有一个可见的冒号和四个不可见的空格）</dd></dl><dl><dt>代码块 2</dt><dd>这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）</dd></dl><pre><code>代码块（左侧有八个不可见的空格）</code></pre><h3 id=\"14-Html-标签\"><a href=\"#14-Html-标签\" class=\"headerlink\" title=\"14. Html 标签\"></a>14. Html 标签</h3><p>本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格：</p>\n<pre><code>&lt;table&gt;\n    &lt;tr&gt;\n        &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt;\n        &lt;th&gt;星期一&lt;/th&gt;\n        &lt;th&gt;星期二&lt;/th&gt;\n        &lt;th&gt;星期三&lt;/th&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n        &lt;td&gt;李强&lt;/td&gt;\n        &lt;td&gt;张明&lt;/td&gt;\n        &lt;td&gt;王平&lt;/td&gt;\n    &lt;/tr&gt;\n&lt;/table&gt;</code></pre><table>\n    <tr>\n        <th rowspan=\"2\">值班人员</th>\n        <th>星期一</th>\n        <th>星期二</th>\n        <th>星期三</th>\n    </tr>\n    <tr>\n        <td>李强</td>\n        <td>张明</td>\n        <td>王平</td>\n    </tr>\n</table>\n\n<h3 id=\"15-内嵌图标\"><a href=\"#15-内嵌图标\" class=\"headerlink\" title=\"15. 内嵌图标\"></a>15. 内嵌图标</h3><p>本站的图标系统对外开放，在文档中输入</p>\n<pre><code>&lt;i class=&quot;icon-weibo&quot;&gt;&lt;/i&gt;</code></pre><p>即显示微博的图标： <i class=\"icon-weibo icon-2x\"></i></p>\n<p>替换 上述 <code>i 标签</code> 内的 <code>icon-weibo</code> 以显示不同的图标，例如：</p>\n<pre><code>&lt;i class=&quot;icon-renren&quot;&gt;&lt;/i&gt;</code></pre><p>即显示人人的图标： <i class=\"icon-renren icon-2x\"></i></p>\n<p>更多的图标和玩法可以参看 <a href=\"http://fortawesome.github.io/Font-Awesome/3.2.1/icons/\" target=\"_blank\" rel=\"noopener\">font-awesome</a> 官方网站。</p>\n<h3 id=\"16-待办事宜-Todo-列表\"><a href=\"#16-待办事宜-Todo-列表\" class=\"headerlink\" title=\"16. 待办事宜 Todo 列表\"></a>16. 待办事宜 Todo 列表</h3><p>使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如：</p>\n<pre><code>- [ ] **Cmd Markdown 开发**\n    - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率\n    - [ ] 支持以 PDF 格式导出文稿\n    - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments)\n    - [x] 改进 LaTex 功能\n        - [x] 修复 LaTex 公式渲染问题\n        - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers)\n- [ ] **七月旅行准备**\n    - [ ] 准备邮轮上需要携带的物品\n    - [ ] 浏览日本免税店的物品\n    - [x] 购买蓝宝石公主号七月一日的船票</code></pre><p>对应显示如下待办事宜 Todo 列表：</p>\n<ul>\n<li><input disabled type=\"checkbox\"> <strong>Cmd Markdown 开发</strong><ul>\n<li><input disabled type=\"checkbox\"> 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li>\n<li><input disabled type=\"checkbox\"> 支持以 PDF 格式导出文稿</li>\n<li><input checked disabled type=\"checkbox\"> 新增Todo列表功能 <a href=\"https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments\" target=\"_blank\" rel=\"noopener\">语法参考</a></li>\n<li><input checked disabled type=\"checkbox\"> 改进 LaTex 功能<ul>\n<li><input checked disabled type=\"checkbox\"> 修复 LaTex 公式渲染问题</li>\n<li><input checked disabled type=\"checkbox\"> 新增 LaTex 公式编号功能 <a href=\"http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers\" target=\"_blank\" rel=\"noopener\">语法参考</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><input disabled type=\"checkbox\"> <strong>七月旅行准备</strong><ul>\n<li><input disabled type=\"checkbox\"> 准备邮轮上需要携带的物品</li>\n<li><input disabled type=\"checkbox\"> 浏览日本免税店的物品</li>\n<li><input checked disabled type=\"checkbox\"> 购买蓝宝石公主号七月一日的船票</li>\n</ul>\n</li>\n</ul>\n<p>[^footnote]: 这是一个 <em>注脚</em> 的 <strong>文本</strong>。</p>\n<p>[^footnote2]: 这是另一个 <em>注脚</em> 的 <strong>文本</strong>。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Markdown-高阶语法手册\"><a href=\"#Markdown-高阶语法手册\" class=\"headerlink\" title=\"Markdown 高阶语法手册\"></a>Markdown 高阶语法手册</h1><h3 id=\"1-内容目录\"><a href=\"#1-内容目录\" class=\"headerlink\" title=\"1. 内容目录\"></a>1. 内容目录</h3><p>在段落中填写 <code>[TOC]</code> 以显示全文内容的目录结构。</p>\n<p>[TOC]</p>\n<h3 id=\"2-标签分类\"><a href=\"#2-标签分类\" class=\"headerlink\" title=\"2. 标签分类\"></a>2. 标签分类</h3><p>在编辑区任意行的列首位置输入以下代码给文稿标签：</p>\n<p>标签： 数学 英语 Markdown</p>\n<p>或者</p>\n<p>Tags： 数学 英语 Markdown</p>\n<h3 id=\"3-删除线\"><a href=\"#3-删除线\" class=\"headerlink\" title=\"3. 删除线\"></a>3. 删除线</h3><p>使用 ~~ 表示删除线。</p>\n<p><del>这是一段错误的文本。</del></p>\n<h3 id=\"4-注脚\"><a href=\"#4-注脚\" class=\"headerlink\" title=\"4. 注脚\"></a>4. 注脚</h3><p>使用 [^keyword] 表示注脚。</p>\n<p>这是一个注脚[^footnote]的样例。</p>\n<p>这是第二个注脚[^footnote2]的样例。</p>\n<h3 id=\"5-LaTeX-公式\"><a href=\"#5-LaTeX-公式\" class=\"headerlink\" title=\"5. LaTeX 公式\"></a>5. LaTeX 公式</h3><p>$ 表示行内公式： </p>\n<p>质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。</p>\n<p>$$ 表示整行公式：</p>\n<p>$$\\sum_{i=1}^n a_i=0$$</p>\n<p>$$f(x_1,x_x,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2 $$</p>\n<p>$$\\sum^{j-1}<em>{k=0}{\\widehat{\\gamma}</em>{kj} z_k}$$</p>\n<p>访问 <a href=\"http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference\" target=\"_blank\" rel=\"noopener\">MathJax</a> 参考更多使用方法。</p>\n<h3 id=\"6-加强的代码块\"><a href=\"#6-加强的代码块\" class=\"headerlink\" title=\"6. 加强的代码块\"></a>6. 加强的代码块</h3><p>支持四十一种编程语言的语法高亮的显示，行号显示。</p>\n<p>非代码示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo apt-get install vim-gnome</span><br></pre></td></tr></table></figure>\n\n<p>Python 示例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@requires_authorization</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">somefunc</span><span class=\"params\">(param1=<span class=\"string\">''</span>, param2=<span class=\"number\">0</span>)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">'''A docstring'''</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> param1 &gt; param2: <span class=\"comment\"># interesting</span></span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">'Greater'</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (param2 - param1 + <span class=\"number\">1</span>) <span class=\"keyword\">or</span> <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeClass</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>message = <span class=\"string\">'''interpreter</span></span><br><span class=\"line\"><span class=\"string\"><span class=\"meta\">... </span>prompt'''</span></span><br></pre></td></tr></table></figure>\n\n<p>JavaScript 示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* nth element in the fibonacci series.</span></span><br><span class=\"line\"><span class=\"comment\">* @param n &gt;= 0</span></span><br><span class=\"line\"><span class=\"comment\">* @return the nth element, &gt;= 0.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fib</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>, b = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> tmp;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (--n &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    tmp = a;</span><br><span class=\"line\">    a += b;</span><br><span class=\"line\">    b = tmp;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">document</span>.write(fib(<span class=\"number\">10</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-流程图\"><a href=\"#7-流程图\" class=\"headerlink\" title=\"7. 流程图\"></a>7. 流程图</h3><h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">st=&gt;start: Start:&gt;https://www.zybuluo.com</span><br><span class=\"line\">io=&gt;inputoutput: verification</span><br><span class=\"line\">op=&gt;operation: Your Operation</span><br><span class=\"line\">cond=&gt;condition: Yes or No?</span><br><span class=\"line\">sub=&gt;subroutine: Your Subroutine</span><br><span class=\"line\">e=&gt;end</span><br><span class=\"line\"></span><br><span class=\"line\">st-&gt;io-&gt;op-&gt;cond</span><br><span class=\"line\">cond(yes)-&gt;e</span><br><span class=\"line\">cond(no)-&gt;sub-&gt;io</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"更多语法参考：流程图语法参考\"><a href=\"#更多语法参考：流程图语法参考\" class=\"headerlink\" title=\"更多语法参考：流程图语法参考\"></a>更多语法参考：<a href=\"http://adrai.github.io/flowchart.js/\" target=\"_blank\" rel=\"noopener\">流程图语法参考</a></h4><h3 id=\"8-序列图\"><a href=\"#8-序列图\" class=\"headerlink\" title=\"8. 序列图\"></a>8. 序列图</h3><h4 id=\"示例-1\"><a href=\"#示例-1\" class=\"headerlink\" title=\"示例 1\"></a>示例 1</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Alice-&gt;Bob: Hello Bob, how are you?</span><br><span class=\"line\">Note right of Bob: Bob thinks</span><br><span class=\"line\">Bob--&gt;Alice: I am good thanks!</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"示例-2\"><a href=\"#示例-2\" class=\"headerlink\" title=\"示例 2\"></a>示例 2</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Title: Here is a title</span><br><span class=\"line\">A-&gt;B: Normal line</span><br><span class=\"line\">B--&gt;C: Dashed line</span><br><span class=\"line\">C-&gt;&gt;D: Open arrow</span><br><span class=\"line\">D--&gt;&gt;A: Dashed open arrow</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"更多语法参考：序列图语法参考\"><a href=\"#更多语法参考：序列图语法参考\" class=\"headerlink\" title=\"更多语法参考：序列图语法参考\"></a>更多语法参考：<a href=\"http://bramp.github.io/js-sequence-diagrams/\" target=\"_blank\" rel=\"noopener\">序列图语法参考</a></h4><h3 id=\"9-甘特图\"><a href=\"#9-甘特图\" class=\"headerlink\" title=\"9. 甘特图\"></a>9. 甘特图</h3><p>甘特图内在思想简单。基本是一条线条图，横轴表示时间，纵轴表示活动（项目），线条表示在整个期间上计划和实际的活动完成情况。它直观地表明任务计划在什么时候进行，及实际进展与计划要求的对比。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title 项目开发流程</span><br><span class=\"line\">section 项目确定</span><br><span class=\"line\">    需求分析       :a1, 2016-06-22, 3d</span><br><span class=\"line\">    可行性报告     :after a1, 5d</span><br><span class=\"line\">    概念验证       : 5d</span><br><span class=\"line\">section 项目实施</span><br><span class=\"line\">    概要设计      :2016-07-05  , 5d</span><br><span class=\"line\">    详细设计      :2016-07-08, 10d</span><br><span class=\"line\">    编码          :2016-07-15, 10d</span><br><span class=\"line\">    测试          :2016-07-22, 5d</span><br><span class=\"line\">section 发布验收</span><br><span class=\"line\">    发布: 2d</span><br><span class=\"line\">    验收: 3d</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"更多语法参考：甘特图语法参考\"><a href=\"#更多语法参考：甘特图语法参考\" class=\"headerlink\" title=\"更多语法参考：甘特图语法参考\"></a>更多语法参考：<a href=\"https://knsv.github.io/mermaid/#gant-diagrams\" target=\"_blank\" rel=\"noopener\">甘特图语法参考</a></h4><h3 id=\"10-Mermaid-流程图\"><a href=\"#10-Mermaid-流程图\" class=\"headerlink\" title=\"10. Mermaid 流程图\"></a>10. Mermaid 流程图</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A[Hard edge] --&gt;|Link text| B(Round edge)</span><br><span class=\"line\">B --&gt; C&#123;Decision&#125;</span><br><span class=\"line\">C --&gt;|One| D[Result one]</span><br><span class=\"line\">C --&gt;|Two| E[Result two]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"更多语法参考：Mermaid-流程图语法参考\"><a href=\"#更多语法参考：Mermaid-流程图语法参考\" class=\"headerlink\" title=\"更多语法参考：Mermaid 流程图语法参考\"></a>更多语法参考：<a href=\"https://knsv.github.io/mermaid/#flowcharts-basic-syntax\" target=\"_blank\" rel=\"noopener\">Mermaid 流程图语法参考</a></h4><h3 id=\"11-Mermaid-序列图\"><a href=\"#11-Mermaid-序列图\" class=\"headerlink\" title=\"11. Mermaid 序列图\"></a>11. Mermaid 序列图</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Alice-&gt;John: Hello John, how are you?</span><br><span class=\"line\">loop every minute</span><br><span class=\"line\">    John--&gt;Alice: Great!</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"更多语法参考：Mermaid-序列图语法参考\"><a href=\"#更多语法参考：Mermaid-序列图语法参考\" class=\"headerlink\" title=\"更多语法参考：Mermaid 序列图语法参考\"></a>更多语法参考：<a href=\"https://knsv.github.io/mermaid/#sequence-diagrams\" target=\"_blank\" rel=\"noopener\">Mermaid 序列图语法参考</a></h4><h3 id=\"12-表格支持\"><a href=\"#12-表格支持\" class=\"headerlink\" title=\"12. 表格支持\"></a>12. 表格支持</h3><table>\n<thead>\n<tr>\n<th>项目</th>\n<th align=\"right\">价格</th>\n<th align=\"center\">数量</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>计算机</td>\n<td align=\"right\">$1600</td>\n<td align=\"center\">5</td>\n</tr>\n<tr>\n<td>手机</td>\n<td align=\"right\">$12</td>\n<td align=\"center\">12</td>\n</tr>\n<tr>\n<td>管线</td>\n<td align=\"right\">$1</td>\n<td align=\"center\">234</td>\n</tr>\n</tbody></table>\n<h3 id=\"13-定义型列表\"><a href=\"#13-定义型列表\" class=\"headerlink\" title=\"13. 定义型列表\"></a>13. 定义型列表</h3><dl><dt>名词 1</dt><dd>定义 1（左侧有一个可见的冒号和四个不可见的空格）</dd></dl><dl><dt>代码块 2</dt><dd>这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）</dd></dl><pre><code>代码块（左侧有八个不可见的空格）</code></pre><h3 id=\"14-Html-标签\"><a href=\"#14-Html-标签\" class=\"headerlink\" title=\"14. Html 标签\"></a>14. Html 标签</h3><p>本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格：</p>\n<pre><code>&lt;table&gt;\n    &lt;tr&gt;\n        &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt;\n        &lt;th&gt;星期一&lt;/th&gt;\n        &lt;th&gt;星期二&lt;/th&gt;\n        &lt;th&gt;星期三&lt;/th&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n        &lt;td&gt;李强&lt;/td&gt;\n        &lt;td&gt;张明&lt;/td&gt;\n        &lt;td&gt;王平&lt;/td&gt;\n    &lt;/tr&gt;\n&lt;/table&gt;</code></pre><table>\n    <tr>\n        <th rowspan=\"2\">值班人员</th>\n        <th>星期一</th>\n        <th>星期二</th>\n        <th>星期三</th>\n    </tr>\n    <tr>\n        <td>李强</td>\n        <td>张明</td>\n        <td>王平</td>\n    </tr>\n</table>\n\n<h3 id=\"15-内嵌图标\"><a href=\"#15-内嵌图标\" class=\"headerlink\" title=\"15. 内嵌图标\"></a>15. 内嵌图标</h3><p>本站的图标系统对外开放，在文档中输入</p>\n<pre><code>&lt;i class=&quot;icon-weibo&quot;&gt;&lt;/i&gt;</code></pre><p>即显示微博的图标： <i class=\"icon-weibo icon-2x\"></i></p>\n<p>替换 上述 <code>i 标签</code> 内的 <code>icon-weibo</code> 以显示不同的图标，例如：</p>\n<pre><code>&lt;i class=&quot;icon-renren&quot;&gt;&lt;/i&gt;</code></pre><p>即显示人人的图标： <i class=\"icon-renren icon-2x\"></i></p>\n<p>更多的图标和玩法可以参看 <a href=\"http://fortawesome.github.io/Font-Awesome/3.2.1/icons/\" target=\"_blank\" rel=\"noopener\">font-awesome</a> 官方网站。</p>\n<h3 id=\"16-待办事宜-Todo-列表\"><a href=\"#16-待办事宜-Todo-列表\" class=\"headerlink\" title=\"16. 待办事宜 Todo 列表\"></a>16. 待办事宜 Todo 列表</h3><p>使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如：</p>\n<pre><code>- [ ] **Cmd Markdown 开发**\n    - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率\n    - [ ] 支持以 PDF 格式导出文稿\n    - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments)\n    - [x] 改进 LaTex 功能\n        - [x] 修复 LaTex 公式渲染问题\n        - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers)\n- [ ] **七月旅行准备**\n    - [ ] 准备邮轮上需要携带的物品\n    - [ ] 浏览日本免税店的物品\n    - [x] 购买蓝宝石公主号七月一日的船票</code></pre><p>对应显示如下待办事宜 Todo 列表：</p>\n<ul>\n<li><input disabled type=\"checkbox\"> <strong>Cmd Markdown 开发</strong><ul>\n<li><input disabled type=\"checkbox\"> 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li>\n<li><input disabled type=\"checkbox\"> 支持以 PDF 格式导出文稿</li>\n<li><input checked disabled type=\"checkbox\"> 新增Todo列表功能 <a href=\"https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments\" target=\"_blank\" rel=\"noopener\">语法参考</a></li>\n<li><input checked disabled type=\"checkbox\"> 改进 LaTex 功能<ul>\n<li><input checked disabled type=\"checkbox\"> 修复 LaTex 公式渲染问题</li>\n<li><input checked disabled type=\"checkbox\"> 新增 LaTex 公式编号功能 <a href=\"http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers\" target=\"_blank\" rel=\"noopener\">语法参考</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><input disabled type=\"checkbox\"> <strong>七月旅行准备</strong><ul>\n<li><input disabled type=\"checkbox\"> 准备邮轮上需要携带的物品</li>\n<li><input disabled type=\"checkbox\"> 浏览日本免税店的物品</li>\n<li><input checked disabled type=\"checkbox\"> 购买蓝宝石公主号七月一日的船票</li>\n</ul>\n</li>\n</ul>\n<p>[^footnote]: 这是一个 <em>注脚</em> 的 <strong>文本</strong>。</p>\n<p>[^footnote2]: 这是另一个 <em>注脚</em> 的 <strong>文本</strong>。</p>\n"},{"title":"spring常用接口之InitializingBean","date":"2019-06-18T08:54:55.000Z","_content":"\n## spring常用接口简介\n\n### InitializingBean接口\n\n- 作用：实现InitializingBean接口的bean,在初始化bean时都会执行afterPropertiesSet方法\nafterPropertiesSe\n \n- InitializingBean接口源码如下：\n``` \npublic interface InitializingBean {\n    void afterPropertiesSet() throws Exception;\n}\n```\n- 使用实例：策略模式+InitializingBean\n- 业务场景：调用登录接口后，需要根据接口返回的不同的错误码，做出不同响应\n- 实现思路：将错误码和场景实现类的映射关系，在bean初始化时通过afterPropertiesSet初试化至Map中（仿照spring初始化beandefinition），调用时通过调用接口返回的错误码get到相应的实现类，InitializingBean在此场景中起到初始化map的作用\n\n```\n/**\n * 登录场景抽象类\n *\n * @author xiantao.wu\n * @create 2019/5/1711:32\n **/\npublic abstract class AbstractScene implements InitializingBean {\n    private static final Map<Integer, AbstractScene> SCENE_MAP = new ConcurrentHashMap<>();\n    //初始化Map\n    protected void register(Integer sceneType, AbstractScene scene) {\n        SCENE_MAP.put(sceneType, scene);\n    }\n\n\n    public static AbstractScene getScene(Integer sceneType) {\n        if (sceneType == null) {\n            throw 业务异常\n        }\n        return SCENE_MAP.get(sceneType);\n    }\n\n\n    //调用统一入口\n    public static AppLoginResponse checkLoginResponse(LoginResponse response) {\n        Integer sceneType=response.getCode;\n        AbstractScene scene = getScene(sceneType);\n        if (scene == null) {\n           throw 业务异常\n        }\n\n        return scene.check(apiResponse);\n    }\n\n    //登录check项抽象方法\n    public abstract AppLoginResponse check(ApiResponse<TokenPersonLoginResult> apiResponse);\n\n}\n```\n具体实现类：\n\n```\n/**\n * 场景一:账号存在风险\n *\n * @author xiantao.wu\n * @create 2019/5/1711:35\n **/\n@Service\npublic class RiskAccountScene extends AbstractScene {\n    @Autowired\n    private PersonService personService;\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        register(Errors.RISK_ACCOUNT.getErrorCode(), this);\n    }\n\n    @Override\n    public AppLoginResponse check(ApiResponse<TokenPersonLoginResult> apiResponse) {\n        //TODO 具体实现逻辑\n    }\n}\n\n/**\n * 场景二:需要验证手机\n *\n * @author xiantao.wu\n * @create 2019/5/1711:35\n **/\n@Service\npublic class NeedVerifyMobileScene extends AbstractScene {\n    @Autowired\n    private PersonService personService;\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        register(Errors.NEED_VERIFY_MOBILE.getErrorCode(), this);\n    }\n\n    @Override\n    public AppLoginResponse check(ApiResponse<TokenPersonLoginResult> apiResponse) {\n        //TODO 具体实现逻辑\n    }\n}\n\n\n登录调用\n\n /**\n     * 登录\n     */\n    @ApiOperation(value = \"登录\", tags = \"PASSPORT\")\n    @PostMapping(value = \"/login\")\n    public ApiResponse<AppLoginResponse> login(@RequestBody AppLoginRequest appLoginRequest) {\n        LoginResponse response = loginService.login(appLoginRequest);\n        return ApiResponse.success(AbstractScene.checkLoginResponse(response));\n    }\n\n```\n\n\n\n\n\n\n\n","source":"_posts/spring常用接口之InitializingBean.md","raw":"---\ntitle: spring常用接口之InitializingBean\ndate: 2019-06-18 16:54:55\ncategories: spring框架\ntags: spring\n---\n\n## spring常用接口简介\n\n### InitializingBean接口\n\n- 作用：实现InitializingBean接口的bean,在初始化bean时都会执行afterPropertiesSet方法\nafterPropertiesSe\n \n- InitializingBean接口源码如下：\n``` \npublic interface InitializingBean {\n    void afterPropertiesSet() throws Exception;\n}\n```\n- 使用实例：策略模式+InitializingBean\n- 业务场景：调用登录接口后，需要根据接口返回的不同的错误码，做出不同响应\n- 实现思路：将错误码和场景实现类的映射关系，在bean初始化时通过afterPropertiesSet初试化至Map中（仿照spring初始化beandefinition），调用时通过调用接口返回的错误码get到相应的实现类，InitializingBean在此场景中起到初始化map的作用\n\n```\n/**\n * 登录场景抽象类\n *\n * @author xiantao.wu\n * @create 2019/5/1711:32\n **/\npublic abstract class AbstractScene implements InitializingBean {\n    private static final Map<Integer, AbstractScene> SCENE_MAP = new ConcurrentHashMap<>();\n    //初始化Map\n    protected void register(Integer sceneType, AbstractScene scene) {\n        SCENE_MAP.put(sceneType, scene);\n    }\n\n\n    public static AbstractScene getScene(Integer sceneType) {\n        if (sceneType == null) {\n            throw 业务异常\n        }\n        return SCENE_MAP.get(sceneType);\n    }\n\n\n    //调用统一入口\n    public static AppLoginResponse checkLoginResponse(LoginResponse response) {\n        Integer sceneType=response.getCode;\n        AbstractScene scene = getScene(sceneType);\n        if (scene == null) {\n           throw 业务异常\n        }\n\n        return scene.check(apiResponse);\n    }\n\n    //登录check项抽象方法\n    public abstract AppLoginResponse check(ApiResponse<TokenPersonLoginResult> apiResponse);\n\n}\n```\n具体实现类：\n\n```\n/**\n * 场景一:账号存在风险\n *\n * @author xiantao.wu\n * @create 2019/5/1711:35\n **/\n@Service\npublic class RiskAccountScene extends AbstractScene {\n    @Autowired\n    private PersonService personService;\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        register(Errors.RISK_ACCOUNT.getErrorCode(), this);\n    }\n\n    @Override\n    public AppLoginResponse check(ApiResponse<TokenPersonLoginResult> apiResponse) {\n        //TODO 具体实现逻辑\n    }\n}\n\n/**\n * 场景二:需要验证手机\n *\n * @author xiantao.wu\n * @create 2019/5/1711:35\n **/\n@Service\npublic class NeedVerifyMobileScene extends AbstractScene {\n    @Autowired\n    private PersonService personService;\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        register(Errors.NEED_VERIFY_MOBILE.getErrorCode(), this);\n    }\n\n    @Override\n    public AppLoginResponse check(ApiResponse<TokenPersonLoginResult> apiResponse) {\n        //TODO 具体实现逻辑\n    }\n}\n\n\n登录调用\n\n /**\n     * 登录\n     */\n    @ApiOperation(value = \"登录\", tags = \"PASSPORT\")\n    @PostMapping(value = \"/login\")\n    public ApiResponse<AppLoginResponse> login(@RequestBody AppLoginRequest appLoginRequest) {\n        LoginResponse response = loginService.login(appLoginRequest);\n        return ApiResponse.success(AbstractScene.checkLoginResponse(response));\n    }\n\n```\n\n\n\n\n\n\n\n","slug":"spring常用接口之InitializingBean","published":1,"updated":"2019-07-02T11:21:32.699Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzjwwmj0015w4j9r3sbkmlp","content":"<h2 id=\"spring常用接口简介\"><a href=\"#spring常用接口简介\" class=\"headerlink\" title=\"spring常用接口简介\"></a>spring常用接口简介</h2><h3 id=\"InitializingBean接口\"><a href=\"#InitializingBean接口\" class=\"headerlink\" title=\"InitializingBean接口\"></a>InitializingBean接口</h3><ul>\n<li><p>作用：实现InitializingBean接口的bean,在初始化bean时都会执行afterPropertiesSet方法<br>afterPropertiesSe</p>\n</li>\n<li><p>InitializingBean接口源码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface InitializingBean &#123;</span><br><span class=\"line\">    void afterPropertiesSet() throws Exception;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用实例：策略模式+InitializingBean</p>\n</li>\n<li><p>业务场景：调用登录接口后，需要根据接口返回的不同的错误码，做出不同响应</p>\n</li>\n<li><p>实现思路：将错误码和场景实现类的映射关系，在bean初始化时通过afterPropertiesSet初试化至Map中（仿照spring初始化beandefinition），调用时通过调用接口返回的错误码get到相应的实现类，InitializingBean在此场景中起到初始化map的作用</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 登录场景抽象类</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author xiantao.wu</span><br><span class=\"line\"> * @create 2019/5/1711:32</span><br><span class=\"line\"> **/</span><br><span class=\"line\">public abstract class AbstractScene implements InitializingBean &#123;</span><br><span class=\"line\">    private static final Map&lt;Integer, AbstractScene&gt; SCENE_MAP = new ConcurrentHashMap&lt;&gt;();</span><br><span class=\"line\">    //初始化Map</span><br><span class=\"line\">    protected void register(Integer sceneType, AbstractScene scene) &#123;</span><br><span class=\"line\">        SCENE_MAP.put(sceneType, scene);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    public static AbstractScene getScene(Integer sceneType) &#123;</span><br><span class=\"line\">        if (sceneType == null) &#123;</span><br><span class=\"line\">            throw 业务异常</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return SCENE_MAP.get(sceneType);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    //调用统一入口</span><br><span class=\"line\">    public static AppLoginResponse checkLoginResponse(LoginResponse response) &#123;</span><br><span class=\"line\">        Integer sceneType=response.getCode;</span><br><span class=\"line\">        AbstractScene scene = getScene(sceneType);</span><br><span class=\"line\">        if (scene == null) &#123;</span><br><span class=\"line\">           throw 业务异常</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return scene.check(apiResponse);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //登录check项抽象方法</span><br><span class=\"line\">    public abstract AppLoginResponse check(ApiResponse&lt;TokenPersonLoginResult&gt; apiResponse);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>具体实现类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 场景一:账号存在风险</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author xiantao.wu</span><br><span class=\"line\"> * @create 2019/5/1711:35</span><br><span class=\"line\"> **/</span><br><span class=\"line\">@Service</span><br><span class=\"line\">public class RiskAccountScene extends AbstractScene &#123;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private PersonService personService;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void afterPropertiesSet() throws Exception &#123;</span><br><span class=\"line\">        register(Errors.RISK_ACCOUNT.getErrorCode(), this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public AppLoginResponse check(ApiResponse&lt;TokenPersonLoginResult&gt; apiResponse) &#123;</span><br><span class=\"line\">        //TODO 具体实现逻辑</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 场景二:需要验证手机</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author xiantao.wu</span><br><span class=\"line\"> * @create 2019/5/1711:35</span><br><span class=\"line\"> **/</span><br><span class=\"line\">@Service</span><br><span class=\"line\">public class NeedVerifyMobileScene extends AbstractScene &#123;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private PersonService personService;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void afterPropertiesSet() throws Exception &#123;</span><br><span class=\"line\">        register(Errors.NEED_VERIFY_MOBILE.getErrorCode(), this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public AppLoginResponse check(ApiResponse&lt;TokenPersonLoginResult&gt; apiResponse) &#123;</span><br><span class=\"line\">        //TODO 具体实现逻辑</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">登录调用</span><br><span class=\"line\"></span><br><span class=\"line\"> /**</span><br><span class=\"line\">     * 登录</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @ApiOperation(value = &quot;登录&quot;, tags = &quot;PASSPORT&quot;)</span><br><span class=\"line\">    @PostMapping(value = &quot;/login&quot;)</span><br><span class=\"line\">    public ApiResponse&lt;AppLoginResponse&gt; login(@RequestBody AppLoginRequest appLoginRequest) &#123;</span><br><span class=\"line\">        LoginResponse response = loginService.login(appLoginRequest);</span><br><span class=\"line\">        return ApiResponse.success(AbstractScene.checkLoginResponse(response));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"spring常用接口简介\"><a href=\"#spring常用接口简介\" class=\"headerlink\" title=\"spring常用接口简介\"></a>spring常用接口简介</h2><h3 id=\"InitializingBean接口\"><a href=\"#InitializingBean接口\" class=\"headerlink\" title=\"InitializingBean接口\"></a>InitializingBean接口</h3><ul>\n<li><p>作用：实现InitializingBean接口的bean,在初始化bean时都会执行afterPropertiesSet方法<br>afterPropertiesSe</p>\n</li>\n<li><p>InitializingBean接口源码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public interface InitializingBean &#123;</span><br><span class=\"line\">    void afterPropertiesSet() throws Exception;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用实例：策略模式+InitializingBean</p>\n</li>\n<li><p>业务场景：调用登录接口后，需要根据接口返回的不同的错误码，做出不同响应</p>\n</li>\n<li><p>实现思路：将错误码和场景实现类的映射关系，在bean初始化时通过afterPropertiesSet初试化至Map中（仿照spring初始化beandefinition），调用时通过调用接口返回的错误码get到相应的实现类，InitializingBean在此场景中起到初始化map的作用</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 登录场景抽象类</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author xiantao.wu</span><br><span class=\"line\"> * @create 2019/5/1711:32</span><br><span class=\"line\"> **/</span><br><span class=\"line\">public abstract class AbstractScene implements InitializingBean &#123;</span><br><span class=\"line\">    private static final Map&lt;Integer, AbstractScene&gt; SCENE_MAP = new ConcurrentHashMap&lt;&gt;();</span><br><span class=\"line\">    //初始化Map</span><br><span class=\"line\">    protected void register(Integer sceneType, AbstractScene scene) &#123;</span><br><span class=\"line\">        SCENE_MAP.put(sceneType, scene);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    public static AbstractScene getScene(Integer sceneType) &#123;</span><br><span class=\"line\">        if (sceneType == null) &#123;</span><br><span class=\"line\">            throw 业务异常</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return SCENE_MAP.get(sceneType);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    //调用统一入口</span><br><span class=\"line\">    public static AppLoginResponse checkLoginResponse(LoginResponse response) &#123;</span><br><span class=\"line\">        Integer sceneType=response.getCode;</span><br><span class=\"line\">        AbstractScene scene = getScene(sceneType);</span><br><span class=\"line\">        if (scene == null) &#123;</span><br><span class=\"line\">           throw 业务异常</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return scene.check(apiResponse);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //登录check项抽象方法</span><br><span class=\"line\">    public abstract AppLoginResponse check(ApiResponse&lt;TokenPersonLoginResult&gt; apiResponse);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>具体实现类：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 场景一:账号存在风险</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author xiantao.wu</span><br><span class=\"line\"> * @create 2019/5/1711:35</span><br><span class=\"line\"> **/</span><br><span class=\"line\">@Service</span><br><span class=\"line\">public class RiskAccountScene extends AbstractScene &#123;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private PersonService personService;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void afterPropertiesSet() throws Exception &#123;</span><br><span class=\"line\">        register(Errors.RISK_ACCOUNT.getErrorCode(), this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public AppLoginResponse check(ApiResponse&lt;TokenPersonLoginResult&gt; apiResponse) &#123;</span><br><span class=\"line\">        //TODO 具体实现逻辑</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 场景二:需要验证手机</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author xiantao.wu</span><br><span class=\"line\"> * @create 2019/5/1711:35</span><br><span class=\"line\"> **/</span><br><span class=\"line\">@Service</span><br><span class=\"line\">public class NeedVerifyMobileScene extends AbstractScene &#123;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    private PersonService personService;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void afterPropertiesSet() throws Exception &#123;</span><br><span class=\"line\">        register(Errors.NEED_VERIFY_MOBILE.getErrorCode(), this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public AppLoginResponse check(ApiResponse&lt;TokenPersonLoginResult&gt; apiResponse) &#123;</span><br><span class=\"line\">        //TODO 具体实现逻辑</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">登录调用</span><br><span class=\"line\"></span><br><span class=\"line\"> /**</span><br><span class=\"line\">     * 登录</span><br><span class=\"line\">     */</span><br><span class=\"line\">    @ApiOperation(value = &quot;登录&quot;, tags = &quot;PASSPORT&quot;)</span><br><span class=\"line\">    @PostMapping(value = &quot;/login&quot;)</span><br><span class=\"line\">    public ApiResponse&lt;AppLoginResponse&gt; login(@RequestBody AppLoginRequest appLoginRequest) &#123;</span><br><span class=\"line\">        LoginResponse response = loginService.login(appLoginRequest);</span><br><span class=\"line\">        return ApiResponse.success(AbstractScene.checkLoginResponse(response));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"记一次线上事故总结","date":"2019-06-19T14:40:45.000Z","_content":"\n### 事故起因\n发布预发布环境时，修改配置中心redis连接配置，连接密码错误，导致线上一个接口出现4000余个500请求\n\n### 事故经过\n当发布到预发布环境时，控制台立刻发现了错误日志，经排查发现是由于线上环境连接redis没有配置密码导致的。才想起本次上线引用了新开发的redis sdk，同时这个改造是由另外一个同事完成的。当时那位同事已经不再公司，于是就找架构师要了对应redis的连接密码，问题就发生在在这里了\n```\n配置一（线上使用的配置）\nhost=redis.servers.test.jx\nport=6379\npassword=\ndatabase=9\nclientName=giveapp-rest\n\n配置二（新sdk使用的配置）\nspring.redis.host=redis.servers.test.jx\nspring.redis.port=6379\nspring.redis.password=\nspring.redis.database=14\n```\n线上代码使用的是配置一，上线代码使用的是配置二，我将上述配置截图给架构师后，他将密码发给我，我拿到密码看到配置也在疑惑是使用哪一个配置（注释说明当时没有），\n于是想当然的加到了两个配置上，自己在app上马上测试了一下，发现没有报错就没有在管了。大概过了几分钟同事告诉我说线上出问题了，我在自己的手机上上试了一下，果然redis相关接口报错，我迅速反应过来，马上把配置还原，问题解决。后来发现线上使用的配置一是可以需要密码的，架构师发给我的密码是配置二节点的密码，配置一和配置二的节点不一同一个，使用同一个密码，线上就会出现redis连接异常，这才是问题所在。另外一个问题，为什么自己修改完redis密码后，自己app没有异常，现在看来可能是客户端本地缓存，当然这个已经不重要，本身这种验证凡是也是及其愚蠢的。\n### 事故反思\n解决完后，自己也是自责不已，懊恼自己竟会做出如此草率的决定。回到家后，决定深入剖析一下当时自己的心路历程。回想起当时修改完后，自己验证\"没问题后\"，就被另一件事给耽搁住了，知道同事报障才反应过来。很多时候还是都是存在侥幸心理，以为会没问题。这让我想起了“墨菲定律”，任何小概率事假，看似几乎不能发生，当基数足够足够大时，它将会是必然时间。为什么会出现这次愚蠢的错误，究其原因还是因为自己之前也经常这么干，对有可能影响到线上的改动缺乏足够评估。综合来看，最近公司事故频发，大多数事故发生的场景都较为极端，甚至无法验证出来。但问题在于，这些代码问题或者不规范操作是长期存在的。当出现的次数不断增多时，事故的发生将会是一个必然事件。所以某种程度上，养成一个好的工作习惯是要胜过掌握一项新技术的。线上无小事，每一次关系到线上正常生产的改动，都需要再三保证其绝对正确，养成好的习惯。","source":"_posts/记一次线上事故总结.md","raw":"---\ntitle: 记一次线上事故总结\ndate: 2019-06-19 22:40:45\ncategories: 代码之外\ntags: 随笔\n---\n\n### 事故起因\n发布预发布环境时，修改配置中心redis连接配置，连接密码错误，导致线上一个接口出现4000余个500请求\n\n### 事故经过\n当发布到预发布环境时，控制台立刻发现了错误日志，经排查发现是由于线上环境连接redis没有配置密码导致的。才想起本次上线引用了新开发的redis sdk，同时这个改造是由另外一个同事完成的。当时那位同事已经不再公司，于是就找架构师要了对应redis的连接密码，问题就发生在在这里了\n```\n配置一（线上使用的配置）\nhost=redis.servers.test.jx\nport=6379\npassword=\ndatabase=9\nclientName=giveapp-rest\n\n配置二（新sdk使用的配置）\nspring.redis.host=redis.servers.test.jx\nspring.redis.port=6379\nspring.redis.password=\nspring.redis.database=14\n```\n线上代码使用的是配置一，上线代码使用的是配置二，我将上述配置截图给架构师后，他将密码发给我，我拿到密码看到配置也在疑惑是使用哪一个配置（注释说明当时没有），\n于是想当然的加到了两个配置上，自己在app上马上测试了一下，发现没有报错就没有在管了。大概过了几分钟同事告诉我说线上出问题了，我在自己的手机上上试了一下，果然redis相关接口报错，我迅速反应过来，马上把配置还原，问题解决。后来发现线上使用的配置一是可以需要密码的，架构师发给我的密码是配置二节点的密码，配置一和配置二的节点不一同一个，使用同一个密码，线上就会出现redis连接异常，这才是问题所在。另外一个问题，为什么自己修改完redis密码后，自己app没有异常，现在看来可能是客户端本地缓存，当然这个已经不重要，本身这种验证凡是也是及其愚蠢的。\n### 事故反思\n解决完后，自己也是自责不已，懊恼自己竟会做出如此草率的决定。回到家后，决定深入剖析一下当时自己的心路历程。回想起当时修改完后，自己验证\"没问题后\"，就被另一件事给耽搁住了，知道同事报障才反应过来。很多时候还是都是存在侥幸心理，以为会没问题。这让我想起了“墨菲定律”，任何小概率事假，看似几乎不能发生，当基数足够足够大时，它将会是必然时间。为什么会出现这次愚蠢的错误，究其原因还是因为自己之前也经常这么干，对有可能影响到线上的改动缺乏足够评估。综合来看，最近公司事故频发，大多数事故发生的场景都较为极端，甚至无法验证出来。但问题在于，这些代码问题或者不规范操作是长期存在的。当出现的次数不断增多时，事故的发生将会是一个必然事件。所以某种程度上，养成一个好的工作习惯是要胜过掌握一项新技术的。线上无小事，每一次关系到线上正常生产的改动，都需要再三保证其绝对正确，养成好的习惯。","slug":"记一次线上事故总结","published":1,"updated":"2019-07-02T11:21:32.709Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzjwwmm0019w4j9wgsjalv4","content":"<h3 id=\"事故起因\"><a href=\"#事故起因\" class=\"headerlink\" title=\"事故起因\"></a>事故起因</h3><p>发布预发布环境时，修改配置中心redis连接配置，连接密码错误，导致线上一个接口出现4000余个500请求</p>\n<h3 id=\"事故经过\"><a href=\"#事故经过\" class=\"headerlink\" title=\"事故经过\"></a>事故经过</h3><p>当发布到预发布环境时，控制台立刻发现了错误日志，经排查发现是由于线上环境连接redis没有配置密码导致的。才想起本次上线引用了新开发的redis sdk，同时这个改造是由另外一个同事完成的。当时那位同事已经不再公司，于是就找架构师要了对应redis的连接密码，问题就发生在在这里了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">配置一（线上使用的配置）</span><br><span class=\"line\">host=redis.servers.test.jx</span><br><span class=\"line\">port=6379</span><br><span class=\"line\">password=</span><br><span class=\"line\">database=9</span><br><span class=\"line\">clientName=giveapp-rest</span><br><span class=\"line\"></span><br><span class=\"line\">配置二（新sdk使用的配置）</span><br><span class=\"line\">spring.redis.host=redis.servers.test.jx</span><br><span class=\"line\">spring.redis.port=6379</span><br><span class=\"line\">spring.redis.password=</span><br><span class=\"line\">spring.redis.database=14</span><br></pre></td></tr></table></figure>\n\n<p>线上代码使用的是配置一，上线代码使用的是配置二，我将上述配置截图给架构师后，他将密码发给我，我拿到密码看到配置也在疑惑是使用哪一个配置（注释说明当时没有），<br>于是想当然的加到了两个配置上，自己在app上马上测试了一下，发现没有报错就没有在管了。大概过了几分钟同事告诉我说线上出问题了，我在自己的手机上上试了一下，果然redis相关接口报错，我迅速反应过来，马上把配置还原，问题解决。后来发现线上使用的配置一是可以需要密码的，架构师发给我的密码是配置二节点的密码，配置一和配置二的节点不一同一个，使用同一个密码，线上就会出现redis连接异常，这才是问题所在。另外一个问题，为什么自己修改完redis密码后，自己app没有异常，现在看来可能是客户端本地缓存，当然这个已经不重要，本身这种验证凡是也是及其愚蠢的。</p>\n<h3 id=\"事故反思\"><a href=\"#事故反思\" class=\"headerlink\" title=\"事故反思\"></a>事故反思</h3><p>解决完后，自己也是自责不已，懊恼自己竟会做出如此草率的决定。回到家后，决定深入剖析一下当时自己的心路历程。回想起当时修改完后，自己验证”没问题后”，就被另一件事给耽搁住了，知道同事报障才反应过来。很多时候还是都是存在侥幸心理，以为会没问题。这让我想起了“墨菲定律”，任何小概率事假，看似几乎不能发生，当基数足够足够大时，它将会是必然时间。为什么会出现这次愚蠢的错误，究其原因还是因为自己之前也经常这么干，对有可能影响到线上的改动缺乏足够评估。综合来看，最近公司事故频发，大多数事故发生的场景都较为极端，甚至无法验证出来。但问题在于，这些代码问题或者不规范操作是长期存在的。当出现的次数不断增多时，事故的发生将会是一个必然事件。所以某种程度上，养成一个好的工作习惯是要胜过掌握一项新技术的。线上无小事，每一次关系到线上正常生产的改动，都需要再三保证其绝对正确，养成好的习惯。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"事故起因\"><a href=\"#事故起因\" class=\"headerlink\" title=\"事故起因\"></a>事故起因</h3><p>发布预发布环境时，修改配置中心redis连接配置，连接密码错误，导致线上一个接口出现4000余个500请求</p>\n<h3 id=\"事故经过\"><a href=\"#事故经过\" class=\"headerlink\" title=\"事故经过\"></a>事故经过</h3><p>当发布到预发布环境时，控制台立刻发现了错误日志，经排查发现是由于线上环境连接redis没有配置密码导致的。才想起本次上线引用了新开发的redis sdk，同时这个改造是由另外一个同事完成的。当时那位同事已经不再公司，于是就找架构师要了对应redis的连接密码，问题就发生在在这里了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">配置一（线上使用的配置）</span><br><span class=\"line\">host=redis.servers.test.jx</span><br><span class=\"line\">port=6379</span><br><span class=\"line\">password=</span><br><span class=\"line\">database=9</span><br><span class=\"line\">clientName=giveapp-rest</span><br><span class=\"line\"></span><br><span class=\"line\">配置二（新sdk使用的配置）</span><br><span class=\"line\">spring.redis.host=redis.servers.test.jx</span><br><span class=\"line\">spring.redis.port=6379</span><br><span class=\"line\">spring.redis.password=</span><br><span class=\"line\">spring.redis.database=14</span><br></pre></td></tr></table></figure>\n\n<p>线上代码使用的是配置一，上线代码使用的是配置二，我将上述配置截图给架构师后，他将密码发给我，我拿到密码看到配置也在疑惑是使用哪一个配置（注释说明当时没有），<br>于是想当然的加到了两个配置上，自己在app上马上测试了一下，发现没有报错就没有在管了。大概过了几分钟同事告诉我说线上出问题了，我在自己的手机上上试了一下，果然redis相关接口报错，我迅速反应过来，马上把配置还原，问题解决。后来发现线上使用的配置一是可以需要密码的，架构师发给我的密码是配置二节点的密码，配置一和配置二的节点不一同一个，使用同一个密码，线上就会出现redis连接异常，这才是问题所在。另外一个问题，为什么自己修改完redis密码后，自己app没有异常，现在看来可能是客户端本地缓存，当然这个已经不重要，本身这种验证凡是也是及其愚蠢的。</p>\n<h3 id=\"事故反思\"><a href=\"#事故反思\" class=\"headerlink\" title=\"事故反思\"></a>事故反思</h3><p>解决完后，自己也是自责不已，懊恼自己竟会做出如此草率的决定。回到家后，决定深入剖析一下当时自己的心路历程。回想起当时修改完后，自己验证”没问题后”，就被另一件事给耽搁住了，知道同事报障才反应过来。很多时候还是都是存在侥幸心理，以为会没问题。这让我想起了“墨菲定律”，任何小概率事假，看似几乎不能发生，当基数足够足够大时，它将会是必然时间。为什么会出现这次愚蠢的错误，究其原因还是因为自己之前也经常这么干，对有可能影响到线上的改动缺乏足够评估。综合来看，最近公司事故频发，大多数事故发生的场景都较为极端，甚至无法验证出来。但问题在于，这些代码问题或者不规范操作是长期存在的。当出现的次数不断增多时，事故的发生将会是一个必然事件。所以某种程度上，养成一个好的工作习惯是要胜过掌握一项新技术的。线上无小事，每一次关系到线上正常生产的改动，都需要再三保证其绝对正确，养成好的习惯。</p>\n"},{"title":"关于提升工作效率的一点思考","date":"2019-06-18T08:52:25.000Z","_content":"\n最近参加了一个由TGO鲲鹏会组织线上技术交流活动，主办方邀请了一些大牛做技术分享，其中有个议题就是如何提高工作效率。听完各路大神的分享，然后刚好最近自己负责的项目出了一点问题，平时工作经常也会出现疲于应付的问题，根据高效这个议题，然后结合自己的工作经历，深刻反思了一下，就像总结一点东西，督促自己。\n#### 一、能高效的工作，首先要有良好的精神状态\n相信这一点，大家都知道，就不用多说了。最简单也最普遍方式就是保证睡眠（早睡，午睡），锻炼。没有头发的程序员是失败的程序员，，保持良好的作息，健康的生活习惯，才能有良好的精神状态。\n#### 二、良好的工作习惯\n\n1. 关于时间\n- 时间分片，做好计划：每段时间只做一件事，才能保持专注度，专注度才能保证效率，例如：不要同时解决测试提的bug,同时写代码或者写文档，思维中断后再连接是需要时间回顾之前的思路的。\n- 如何分片，如何排序：第一个问题顺序：要事第一，其后可按照优先级排序，第二个问题：分片的粒度，在开启新项目或新需求时，任务都会做拆分，可按照任务的粒度来执行，当然中间不免有一些会议，可以一天预留出一到两个小时作为临时会议或者沟通时间。\n- 避免情绪波动：与产品测试沟通过程中，难免有一些意见不合，比如针对不合理需求，可寻求开发leader或领导介入，尽力去沟通，争取自己的最大化利益，如果最终无法改变，就妥协。比如：加需求，顶头上次都说时间不能顺延，那就只能加班了（如果长期如此，也可以走人了）。\n\n2. 关于需求\n- 有备而来，带着疑问沟通：需求评审前，仔细精读需求文档。\n- 明确现状，评估可行性：回顾每一个需求改动点的业务现状及其现有实现逻辑，明确新需求期望与现状的差距，做好开发时间评估和可行性评估，方便在会上提出需求不可行原因以及可能存在的风险。\n- 记录结果，防止纠纷：记下需求中的模糊点，在会上沟通好确定好细节，并以文字的形式记录下疑问点的沟通结果，要求产品经理将疑问点写入公开的需求文档。\n- 正确理解，至关重要：任何时候对需求有疑问，必须找产品沟通确认，正确实现需求才是最重要的，切不可没时间把事情做对，却又时间返工。\n\n3. 关于会议\n- 不参加不需要我说话的会：我不需要说话，基本会议与我无关，纯属浪费时间。\n- 参加了就要高效： 凡是会议必有主题；凡是主题必有议程；凡是议程必有决议；凡是决议必有跟踪；凡是跟踪必有结果；凡是结果必有责任；凡是责任必有奖惩；凡是奖惩必须透明。最后一次会议达成共识，比面反复耗费时间。\n\n4. 关于反馈\n- 定时反馈进度：阶段性向leader或者PMO反馈开发进度，树立良好的做事风格，同时也可减少因为询问而被打断思路。\n- 主动反馈，不要做反馈黑洞：遇到技术难点，及时与leader讨论解决方案；\n\n5. 关于工作中被打断\n- 来自项目经理的打断：同时是询问开发进度，定期反馈，主动反馈。\n- 来自来自产品的打断：在审批阶段解决掉疑问，正式开发后只专注开发。\n- 来自测试的打断：文档写详细，避免被询问打断，将他人带到自己的工作习惯中，避免被牵着走。\n\n6. 关于面子\n- 需求沟通过程中，有疑问就要问，切记因为不好意思，而不沟通，需求的正确执行是第一要务，不懂就要问，爱面子只会阻碍你的进步。\n\n7. 关于工具\n- 熟练掌握常用工具：快捷键，代码不全功能（如idea的live template可定制代码生成），减少鼠标键盘切换，保持连贯的思维\n- 重复工作脚本化：autohotkey,windows批处理文件\n- 熟悉常用工具包：比如：Apache common,google guawa。\n\n\n#### 三、具体小习惯总结\n1. 每日总结，下班总结工作内容，整理次日需完成的内容。\n2. 早到半小时，安排工作计划，对一天进行规划\n3. 在提测前，花一天时间整体review代码，对比master与develop,整体评估风险点，并优化代码。\n\n\n\n\n\n","source":"_posts/关于提升工作效率的一点思考.md","raw":"---\ntitle: 关于提升工作效率的一点思考\ndate: 2019-06-18 16:52:25\ncategories: 代码之外\ntags: 随笔\n---\n\n最近参加了一个由TGO鲲鹏会组织线上技术交流活动，主办方邀请了一些大牛做技术分享，其中有个议题就是如何提高工作效率。听完各路大神的分享，然后刚好最近自己负责的项目出了一点问题，平时工作经常也会出现疲于应付的问题，根据高效这个议题，然后结合自己的工作经历，深刻反思了一下，就像总结一点东西，督促自己。\n#### 一、能高效的工作，首先要有良好的精神状态\n相信这一点，大家都知道，就不用多说了。最简单也最普遍方式就是保证睡眠（早睡，午睡），锻炼。没有头发的程序员是失败的程序员，，保持良好的作息，健康的生活习惯，才能有良好的精神状态。\n#### 二、良好的工作习惯\n\n1. 关于时间\n- 时间分片，做好计划：每段时间只做一件事，才能保持专注度，专注度才能保证效率，例如：不要同时解决测试提的bug,同时写代码或者写文档，思维中断后再连接是需要时间回顾之前的思路的。\n- 如何分片，如何排序：第一个问题顺序：要事第一，其后可按照优先级排序，第二个问题：分片的粒度，在开启新项目或新需求时，任务都会做拆分，可按照任务的粒度来执行，当然中间不免有一些会议，可以一天预留出一到两个小时作为临时会议或者沟通时间。\n- 避免情绪波动：与产品测试沟通过程中，难免有一些意见不合，比如针对不合理需求，可寻求开发leader或领导介入，尽力去沟通，争取自己的最大化利益，如果最终无法改变，就妥协。比如：加需求，顶头上次都说时间不能顺延，那就只能加班了（如果长期如此，也可以走人了）。\n\n2. 关于需求\n- 有备而来，带着疑问沟通：需求评审前，仔细精读需求文档。\n- 明确现状，评估可行性：回顾每一个需求改动点的业务现状及其现有实现逻辑，明确新需求期望与现状的差距，做好开发时间评估和可行性评估，方便在会上提出需求不可行原因以及可能存在的风险。\n- 记录结果，防止纠纷：记下需求中的模糊点，在会上沟通好确定好细节，并以文字的形式记录下疑问点的沟通结果，要求产品经理将疑问点写入公开的需求文档。\n- 正确理解，至关重要：任何时候对需求有疑问，必须找产品沟通确认，正确实现需求才是最重要的，切不可没时间把事情做对，却又时间返工。\n\n3. 关于会议\n- 不参加不需要我说话的会：我不需要说话，基本会议与我无关，纯属浪费时间。\n- 参加了就要高效： 凡是会议必有主题；凡是主题必有议程；凡是议程必有决议；凡是决议必有跟踪；凡是跟踪必有结果；凡是结果必有责任；凡是责任必有奖惩；凡是奖惩必须透明。最后一次会议达成共识，比面反复耗费时间。\n\n4. 关于反馈\n- 定时反馈进度：阶段性向leader或者PMO反馈开发进度，树立良好的做事风格，同时也可减少因为询问而被打断思路。\n- 主动反馈，不要做反馈黑洞：遇到技术难点，及时与leader讨论解决方案；\n\n5. 关于工作中被打断\n- 来自项目经理的打断：同时是询问开发进度，定期反馈，主动反馈。\n- 来自来自产品的打断：在审批阶段解决掉疑问，正式开发后只专注开发。\n- 来自测试的打断：文档写详细，避免被询问打断，将他人带到自己的工作习惯中，避免被牵着走。\n\n6. 关于面子\n- 需求沟通过程中，有疑问就要问，切记因为不好意思，而不沟通，需求的正确执行是第一要务，不懂就要问，爱面子只会阻碍你的进步。\n\n7. 关于工具\n- 熟练掌握常用工具：快捷键，代码不全功能（如idea的live template可定制代码生成），减少鼠标键盘切换，保持连贯的思维\n- 重复工作脚本化：autohotkey,windows批处理文件\n- 熟悉常用工具包：比如：Apache common,google guawa。\n\n\n#### 三、具体小习惯总结\n1. 每日总结，下班总结工作内容，整理次日需完成的内容。\n2. 早到半小时，安排工作计划，对一天进行规划\n3. 在提测前，花一天时间整体review代码，对比master与develop,整体评估风险点，并优化代码。\n\n\n\n\n\n","slug":"关于提升工作效率的一点思考","published":1,"updated":"2019-07-02T11:21:32.702Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzjwwmo001bw4j9m40wqvtp","content":"<p>最近参加了一个由TGO鲲鹏会组织线上技术交流活动，主办方邀请了一些大牛做技术分享，其中有个议题就是如何提高工作效率。听完各路大神的分享，然后刚好最近自己负责的项目出了一点问题，平时工作经常也会出现疲于应付的问题，根据高效这个议题，然后结合自己的工作经历，深刻反思了一下，就像总结一点东西，督促自己。</p>\n<h4 id=\"一、能高效的工作，首先要有良好的精神状态\"><a href=\"#一、能高效的工作，首先要有良好的精神状态\" class=\"headerlink\" title=\"一、能高效的工作，首先要有良好的精神状态\"></a>一、能高效的工作，首先要有良好的精神状态</h4><p>相信这一点，大家都知道，就不用多说了。最简单也最普遍方式就是保证睡眠（早睡，午睡），锻炼。没有头发的程序员是失败的程序员，，保持良好的作息，健康的生活习惯，才能有良好的精神状态。</p>\n<h4 id=\"二、良好的工作习惯\"><a href=\"#二、良好的工作习惯\" class=\"headerlink\" title=\"二、良好的工作习惯\"></a>二、良好的工作习惯</h4><ol>\n<li>关于时间</li>\n</ol>\n<ul>\n<li>时间分片，做好计划：每段时间只做一件事，才能保持专注度，专注度才能保证效率，例如：不要同时解决测试提的bug,同时写代码或者写文档，思维中断后再连接是需要时间回顾之前的思路的。</li>\n<li>如何分片，如何排序：第一个问题顺序：要事第一，其后可按照优先级排序，第二个问题：分片的粒度，在开启新项目或新需求时，任务都会做拆分，可按照任务的粒度来执行，当然中间不免有一些会议，可以一天预留出一到两个小时作为临时会议或者沟通时间。</li>\n<li>避免情绪波动：与产品测试沟通过程中，难免有一些意见不合，比如针对不合理需求，可寻求开发leader或领导介入，尽力去沟通，争取自己的最大化利益，如果最终无法改变，就妥协。比如：加需求，顶头上次都说时间不能顺延，那就只能加班了（如果长期如此，也可以走人了）。</li>\n</ul>\n<ol start=\"2\">\n<li>关于需求</li>\n</ol>\n<ul>\n<li>有备而来，带着疑问沟通：需求评审前，仔细精读需求文档。</li>\n<li>明确现状，评估可行性：回顾每一个需求改动点的业务现状及其现有实现逻辑，明确新需求期望与现状的差距，做好开发时间评估和可行性评估，方便在会上提出需求不可行原因以及可能存在的风险。</li>\n<li>记录结果，防止纠纷：记下需求中的模糊点，在会上沟通好确定好细节，并以文字的形式记录下疑问点的沟通结果，要求产品经理将疑问点写入公开的需求文档。</li>\n<li>正确理解，至关重要：任何时候对需求有疑问，必须找产品沟通确认，正确实现需求才是最重要的，切不可没时间把事情做对，却又时间返工。</li>\n</ul>\n<ol start=\"3\">\n<li>关于会议</li>\n</ol>\n<ul>\n<li>不参加不需要我说话的会：我不需要说话，基本会议与我无关，纯属浪费时间。</li>\n<li>参加了就要高效： 凡是会议必有主题；凡是主题必有议程；凡是议程必有决议；凡是决议必有跟踪；凡是跟踪必有结果；凡是结果必有责任；凡是责任必有奖惩；凡是奖惩必须透明。最后一次会议达成共识，比面反复耗费时间。</li>\n</ul>\n<ol start=\"4\">\n<li>关于反馈</li>\n</ol>\n<ul>\n<li>定时反馈进度：阶段性向leader或者PMO反馈开发进度，树立良好的做事风格，同时也可减少因为询问而被打断思路。</li>\n<li>主动反馈，不要做反馈黑洞：遇到技术难点，及时与leader讨论解决方案；</li>\n</ul>\n<ol start=\"5\">\n<li>关于工作中被打断</li>\n</ol>\n<ul>\n<li>来自项目经理的打断：同时是询问开发进度，定期反馈，主动反馈。</li>\n<li>来自来自产品的打断：在审批阶段解决掉疑问，正式开发后只专注开发。</li>\n<li>来自测试的打断：文档写详细，避免被询问打断，将他人带到自己的工作习惯中，避免被牵着走。</li>\n</ul>\n<ol start=\"6\">\n<li>关于面子</li>\n</ol>\n<ul>\n<li>需求沟通过程中，有疑问就要问，切记因为不好意思，而不沟通，需求的正确执行是第一要务，不懂就要问，爱面子只会阻碍你的进步。</li>\n</ul>\n<ol start=\"7\">\n<li>关于工具</li>\n</ol>\n<ul>\n<li>熟练掌握常用工具：快捷键，代码不全功能（如idea的live template可定制代码生成），减少鼠标键盘切换，保持连贯的思维</li>\n<li>重复工作脚本化：autohotkey,windows批处理文件</li>\n<li>熟悉常用工具包：比如：Apache common,google guawa。</li>\n</ul>\n<h4 id=\"三、具体小习惯总结\"><a href=\"#三、具体小习惯总结\" class=\"headerlink\" title=\"三、具体小习惯总结\"></a>三、具体小习惯总结</h4><ol>\n<li>每日总结，下班总结工作内容，整理次日需完成的内容。</li>\n<li>早到半小时，安排工作计划，对一天进行规划</li>\n<li>在提测前，花一天时间整体review代码，对比master与develop,整体评估风险点，并优化代码。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>最近参加了一个由TGO鲲鹏会组织线上技术交流活动，主办方邀请了一些大牛做技术分享，其中有个议题就是如何提高工作效率。听完各路大神的分享，然后刚好最近自己负责的项目出了一点问题，平时工作经常也会出现疲于应付的问题，根据高效这个议题，然后结合自己的工作经历，深刻反思了一下，就像总结一点东西，督促自己。</p>\n<h4 id=\"一、能高效的工作，首先要有良好的精神状态\"><a href=\"#一、能高效的工作，首先要有良好的精神状态\" class=\"headerlink\" title=\"一、能高效的工作，首先要有良好的精神状态\"></a>一、能高效的工作，首先要有良好的精神状态</h4><p>相信这一点，大家都知道，就不用多说了。最简单也最普遍方式就是保证睡眠（早睡，午睡），锻炼。没有头发的程序员是失败的程序员，，保持良好的作息，健康的生活习惯，才能有良好的精神状态。</p>\n<h4 id=\"二、良好的工作习惯\"><a href=\"#二、良好的工作习惯\" class=\"headerlink\" title=\"二、良好的工作习惯\"></a>二、良好的工作习惯</h4><ol>\n<li>关于时间</li>\n</ol>\n<ul>\n<li>时间分片，做好计划：每段时间只做一件事，才能保持专注度，专注度才能保证效率，例如：不要同时解决测试提的bug,同时写代码或者写文档，思维中断后再连接是需要时间回顾之前的思路的。</li>\n<li>如何分片，如何排序：第一个问题顺序：要事第一，其后可按照优先级排序，第二个问题：分片的粒度，在开启新项目或新需求时，任务都会做拆分，可按照任务的粒度来执行，当然中间不免有一些会议，可以一天预留出一到两个小时作为临时会议或者沟通时间。</li>\n<li>避免情绪波动：与产品测试沟通过程中，难免有一些意见不合，比如针对不合理需求，可寻求开发leader或领导介入，尽力去沟通，争取自己的最大化利益，如果最终无法改变，就妥协。比如：加需求，顶头上次都说时间不能顺延，那就只能加班了（如果长期如此，也可以走人了）。</li>\n</ul>\n<ol start=\"2\">\n<li>关于需求</li>\n</ol>\n<ul>\n<li>有备而来，带着疑问沟通：需求评审前，仔细精读需求文档。</li>\n<li>明确现状，评估可行性：回顾每一个需求改动点的业务现状及其现有实现逻辑，明确新需求期望与现状的差距，做好开发时间评估和可行性评估，方便在会上提出需求不可行原因以及可能存在的风险。</li>\n<li>记录结果，防止纠纷：记下需求中的模糊点，在会上沟通好确定好细节，并以文字的形式记录下疑问点的沟通结果，要求产品经理将疑问点写入公开的需求文档。</li>\n<li>正确理解，至关重要：任何时候对需求有疑问，必须找产品沟通确认，正确实现需求才是最重要的，切不可没时间把事情做对，却又时间返工。</li>\n</ul>\n<ol start=\"3\">\n<li>关于会议</li>\n</ol>\n<ul>\n<li>不参加不需要我说话的会：我不需要说话，基本会议与我无关，纯属浪费时间。</li>\n<li>参加了就要高效： 凡是会议必有主题；凡是主题必有议程；凡是议程必有决议；凡是决议必有跟踪；凡是跟踪必有结果；凡是结果必有责任；凡是责任必有奖惩；凡是奖惩必须透明。最后一次会议达成共识，比面反复耗费时间。</li>\n</ul>\n<ol start=\"4\">\n<li>关于反馈</li>\n</ol>\n<ul>\n<li>定时反馈进度：阶段性向leader或者PMO反馈开发进度，树立良好的做事风格，同时也可减少因为询问而被打断思路。</li>\n<li>主动反馈，不要做反馈黑洞：遇到技术难点，及时与leader讨论解决方案；</li>\n</ul>\n<ol start=\"5\">\n<li>关于工作中被打断</li>\n</ol>\n<ul>\n<li>来自项目经理的打断：同时是询问开发进度，定期反馈，主动反馈。</li>\n<li>来自来自产品的打断：在审批阶段解决掉疑问，正式开发后只专注开发。</li>\n<li>来自测试的打断：文档写详细，避免被询问打断，将他人带到自己的工作习惯中，避免被牵着走。</li>\n</ul>\n<ol start=\"6\">\n<li>关于面子</li>\n</ol>\n<ul>\n<li>需求沟通过程中，有疑问就要问，切记因为不好意思，而不沟通，需求的正确执行是第一要务，不懂就要问，爱面子只会阻碍你的进步。</li>\n</ul>\n<ol start=\"7\">\n<li>关于工具</li>\n</ol>\n<ul>\n<li>熟练掌握常用工具：快捷键，代码不全功能（如idea的live template可定制代码生成），减少鼠标键盘切换，保持连贯的思维</li>\n<li>重复工作脚本化：autohotkey,windows批处理文件</li>\n<li>熟悉常用工具包：比如：Apache common,google guawa。</li>\n</ul>\n<h4 id=\"三、具体小习惯总结\"><a href=\"#三、具体小习惯总结\" class=\"headerlink\" title=\"三、具体小习惯总结\"></a>三、具体小习惯总结</h4><ol>\n<li>每日总结，下班总结工作内容，整理次日需完成的内容。</li>\n<li>早到半小时，安排工作计划，对一天进行规划</li>\n<li>在提测前，花一天时间整体review代码，对比master与develop,整体评估风险点，并优化代码。</li>\n</ol>\n"},{"title":"spring常用接口之BeanpostProccesser","date":"2019-06-18T08:54:06.000Z","_content":"\n## springBean生命周期\n\n作用：BeanPostProcessor在bean初始化前后做自定义处理\n\n场景：需要自定义swagger,使所有请求显示固定的请求头参数(自定义Docket类)，但是swagger被架构组封装到sdk中，所以在BeanPostProcessor中对Docket的bean做处理\n\n\n```\n/**\n * 自定义swagger\n *\n * @author xiantao.wu\n * @create 2019/3/269:51\n **/\n@Component\npublic class GiveAppBeanPostProcessor implements BeanPostProcessor {\n    //bean初始化之前的操作\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n        return bean;\n    }\n\n    //bean初始化之后的操作\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n        //swagger统一增加请求头\n        if (\"docket\".equals(beanName)) {\n            return builderHeader((Docket) bean);\n        }\n        return bean;\n    }\n\n    private Docket builderHeader(Docket docket) {\n        List<Parameter> pars = new TreeList();\n        pars.add(new ParameterBuilder().name(\"x-os-name\").description(\"系统类型\").defaultValue(\"iOS\")\n                .modelRef(new ModelRef(\"string\")).parameterType(\"header\").required(true).build());\n\n        pars.add(new ParameterBuilder().name(\"x-os-version\").description(\"系统版本\").defaultValue(\"10.3.3\")\n                .modelRef(new ModelRef(\"string\")).parameterType(\"header\").required(true).build());\n\n        return docket.globalOperationParameters(pars);\n    }\n}\n\n```\n\n\n","source":"_posts/spring常用接口之BeanpostProccesser.md","raw":"---\ntitle: spring常用接口之BeanpostProccesser\ndate: 2019-06-18 16:54:06\ncategories: spring框架\ntags: spring\n---\n\n## springBean生命周期\n\n作用：BeanPostProcessor在bean初始化前后做自定义处理\n\n场景：需要自定义swagger,使所有请求显示固定的请求头参数(自定义Docket类)，但是swagger被架构组封装到sdk中，所以在BeanPostProcessor中对Docket的bean做处理\n\n\n```\n/**\n * 自定义swagger\n *\n * @author xiantao.wu\n * @create 2019/3/269:51\n **/\n@Component\npublic class GiveAppBeanPostProcessor implements BeanPostProcessor {\n    //bean初始化之前的操作\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n        return bean;\n    }\n\n    //bean初始化之后的操作\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n        //swagger统一增加请求头\n        if (\"docket\".equals(beanName)) {\n            return builderHeader((Docket) bean);\n        }\n        return bean;\n    }\n\n    private Docket builderHeader(Docket docket) {\n        List<Parameter> pars = new TreeList();\n        pars.add(new ParameterBuilder().name(\"x-os-name\").description(\"系统类型\").defaultValue(\"iOS\")\n                .modelRef(new ModelRef(\"string\")).parameterType(\"header\").required(true).build());\n\n        pars.add(new ParameterBuilder().name(\"x-os-version\").description(\"系统版本\").defaultValue(\"10.3.3\")\n                .modelRef(new ModelRef(\"string\")).parameterType(\"header\").required(true).build());\n\n        return docket.globalOperationParameters(pars);\n    }\n}\n\n```\n\n\n","slug":"spring常用接口之BeanpostProccesser","published":1,"updated":"2019-07-02T11:21:32.696Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzjwwmq001gw4j94adtpzsi","content":"<h2 id=\"springBean生命周期\"><a href=\"#springBean生命周期\" class=\"headerlink\" title=\"springBean生命周期\"></a>springBean生命周期</h2><p>作用：BeanPostProcessor在bean初始化前后做自定义处理</p>\n<p>场景：需要自定义swagger,使所有请求显示固定的请求头参数(自定义Docket类)，但是swagger被架构组封装到sdk中，所以在BeanPostProcessor中对Docket的bean做处理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 自定义swagger</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author xiantao.wu</span><br><span class=\"line\"> * @create 2019/3/269:51</span><br><span class=\"line\"> **/</span><br><span class=\"line\">@Component</span><br><span class=\"line\">public class GiveAppBeanPostProcessor implements BeanPostProcessor &#123;</span><br><span class=\"line\">    //bean初始化之前的操作</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class=\"line\">        return bean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //bean初始化之后的操作</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class=\"line\">        //swagger统一增加请求头</span><br><span class=\"line\">        if (&quot;docket&quot;.equals(beanName)) &#123;</span><br><span class=\"line\">            return builderHeader((Docket) bean);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return bean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Docket builderHeader(Docket docket) &#123;</span><br><span class=\"line\">        List&lt;Parameter&gt; pars = new TreeList();</span><br><span class=\"line\">        pars.add(new ParameterBuilder().name(&quot;x-os-name&quot;).description(&quot;系统类型&quot;).defaultValue(&quot;iOS&quot;)</span><br><span class=\"line\">                .modelRef(new ModelRef(&quot;string&quot;)).parameterType(&quot;header&quot;).required(true).build());</span><br><span class=\"line\"></span><br><span class=\"line\">        pars.add(new ParameterBuilder().name(&quot;x-os-version&quot;).description(&quot;系统版本&quot;).defaultValue(&quot;10.3.3&quot;)</span><br><span class=\"line\">                .modelRef(new ModelRef(&quot;string&quot;)).parameterType(&quot;header&quot;).required(true).build());</span><br><span class=\"line\"></span><br><span class=\"line\">        return docket.globalOperationParameters(pars);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"springBean生命周期\"><a href=\"#springBean生命周期\" class=\"headerlink\" title=\"springBean生命周期\"></a>springBean生命周期</h2><p>作用：BeanPostProcessor在bean初始化前后做自定义处理</p>\n<p>场景：需要自定义swagger,使所有请求显示固定的请求头参数(自定义Docket类)，但是swagger被架构组封装到sdk中，所以在BeanPostProcessor中对Docket的bean做处理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 自定义swagger</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @author xiantao.wu</span><br><span class=\"line\"> * @create 2019/3/269:51</span><br><span class=\"line\"> **/</span><br><span class=\"line\">@Component</span><br><span class=\"line\">public class GiveAppBeanPostProcessor implements BeanPostProcessor &#123;</span><br><span class=\"line\">    //bean初始化之前的操作</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class=\"line\">        return bean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //bean初始化之后的操作</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class=\"line\">        //swagger统一增加请求头</span><br><span class=\"line\">        if (&quot;docket&quot;.equals(beanName)) &#123;</span><br><span class=\"line\">            return builderHeader((Docket) bean);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return bean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private Docket builderHeader(Docket docket) &#123;</span><br><span class=\"line\">        List&lt;Parameter&gt; pars = new TreeList();</span><br><span class=\"line\">        pars.add(new ParameterBuilder().name(&quot;x-os-name&quot;).description(&quot;系统类型&quot;).defaultValue(&quot;iOS&quot;)</span><br><span class=\"line\">                .modelRef(new ModelRef(&quot;string&quot;)).parameterType(&quot;header&quot;).required(true).build());</span><br><span class=\"line\"></span><br><span class=\"line\">        pars.add(new ParameterBuilder().name(&quot;x-os-version&quot;).description(&quot;系统版本&quot;).defaultValue(&quot;10.3.3&quot;)</span><br><span class=\"line\">                .modelRef(new ModelRef(&quot;string&quot;)).parameterType(&quot;header&quot;).required(true).build());</span><br><span class=\"line\"></span><br><span class=\"line\">        return docket.globalOperationParameters(pars);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"设计模式之策略模式","date":"2019-06-18T08:48:43.000Z","_content":"\n### 一、业务场景\n一个接口需要根据前段传入的资产类型（assetType），调用不同的业务类中的资产明细方法（dealList），最初的做法就是最常见的switch case或者if/else调用不同的service。相信每个程序员看到代码中大段的判断逻辑代码都会很头疼，刚好之前看过《重构既有代码》这本Java届的经典书，里面就明确指出switch case违反开闭原则，可以用策略模式改写。\n\n### 二、实现逻辑\n\n1.定义统一资产接口，每种资产实现此接口，代码如下：\n```java\npublic interface AssetService {\n    Integer assetType();\n\n    DealListResponse queryDealList(Integer assetId, Integer status, Integer sinceId, Integer count);\n}\n```\n2.资产service实现接口，并重写assetType()和queryDealList()方法，代码如下：\n\n```java\n@Service\npublic class CashService implements AssetService {\n    @Autowired\n    private CashDetailService cashDetailService;\n\n    @Override\n    public Integer assetType() {\n        return AssetType.CASH.getId();\n    }\n\t @Override\n    public DealListResponse queryDealList(Integer assetId, Integer status, Integer sinceId, Integer count) {\n\t\t   \n\t }\n    \n```\n3.统一分发路由类，根据assetType调用对应的service,代码如下：\n```java\n@Service\npublic class AssetServiceRoute {\n    @Resource\n    private AssetService[] assetServices;\n\n\n    public AssetService route(Integer assetType) {\n        for (AssetService assetService : assetServices) {\n            if (Objects.equals(assetType, assetService.assetType())) {\n                return assetService;\n            }\n        }\n        throw new BusinessRuntimeException(GiveErrorCode.CHECK_PARAM_FAILED);\n    }\n\n}\n```\n4.调用，代码如下；\n```java\n public DealListResponse dealList(Integer assetType, Integer assetId, Integer status, Integer sinceId, Integer count) {\n        AssetService assetService = assetServiceRoute.route(assetType);\n        if (assetService == null) {\n            throw new BusinessRuntimeException(GiveErrorCode.INVALID_PARAMS);\n        }\n        return assetService.queryDealList(assetId, status, sinceId, count);\n    }\n```\n### 三、代码分析\n意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。\n主要解决：在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护（违反开闭原则）。\n何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。\n如何解决：将这些算法封装成一个一个的类，任意地替换。\n关键代码：实现同一个接口。","source":"_posts/设计模式之策略模式.md","raw":"---\ntitle: 设计模式之策略模式\ndate: 2019-06-18 16:48:43\ncategories: 设计模式\ntags: java\n---\n\n### 一、业务场景\n一个接口需要根据前段传入的资产类型（assetType），调用不同的业务类中的资产明细方法（dealList），最初的做法就是最常见的switch case或者if/else调用不同的service。相信每个程序员看到代码中大段的判断逻辑代码都会很头疼，刚好之前看过《重构既有代码》这本Java届的经典书，里面就明确指出switch case违反开闭原则，可以用策略模式改写。\n\n### 二、实现逻辑\n\n1.定义统一资产接口，每种资产实现此接口，代码如下：\n```java\npublic interface AssetService {\n    Integer assetType();\n\n    DealListResponse queryDealList(Integer assetId, Integer status, Integer sinceId, Integer count);\n}\n```\n2.资产service实现接口，并重写assetType()和queryDealList()方法，代码如下：\n\n```java\n@Service\npublic class CashService implements AssetService {\n    @Autowired\n    private CashDetailService cashDetailService;\n\n    @Override\n    public Integer assetType() {\n        return AssetType.CASH.getId();\n    }\n\t @Override\n    public DealListResponse queryDealList(Integer assetId, Integer status, Integer sinceId, Integer count) {\n\t\t   \n\t }\n    \n```\n3.统一分发路由类，根据assetType调用对应的service,代码如下：\n```java\n@Service\npublic class AssetServiceRoute {\n    @Resource\n    private AssetService[] assetServices;\n\n\n    public AssetService route(Integer assetType) {\n        for (AssetService assetService : assetServices) {\n            if (Objects.equals(assetType, assetService.assetType())) {\n                return assetService;\n            }\n        }\n        throw new BusinessRuntimeException(GiveErrorCode.CHECK_PARAM_FAILED);\n    }\n\n}\n```\n4.调用，代码如下；\n```java\n public DealListResponse dealList(Integer assetType, Integer assetId, Integer status, Integer sinceId, Integer count) {\n        AssetService assetService = assetServiceRoute.route(assetType);\n        if (assetService == null) {\n            throw new BusinessRuntimeException(GiveErrorCode.INVALID_PARAMS);\n        }\n        return assetService.queryDealList(assetId, status, sinceId, count);\n    }\n```\n### 三、代码分析\n意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。\n主要解决：在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护（违反开闭原则）。\n何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。\n如何解决：将这些算法封装成一个一个的类，任意地替换。\n关键代码：实现同一个接口。","slug":"设计模式之策略模式","published":1,"updated":"2019-07-02T11:21:32.712Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzjwwms001hw4j9pldexq1w","content":"<h3 id=\"一、业务场景\"><a href=\"#一、业务场景\" class=\"headerlink\" title=\"一、业务场景\"></a>一、业务场景</h3><p>一个接口需要根据前段传入的资产类型（assetType），调用不同的业务类中的资产明细方法（dealList），最初的做法就是最常见的switch case或者if/else调用不同的service。相信每个程序员看到代码中大段的判断逻辑代码都会很头疼，刚好之前看过《重构既有代码》这本Java届的经典书，里面就明确指出switch case违反开闭原则，可以用策略模式改写。</p>\n<h3 id=\"二、实现逻辑\"><a href=\"#二、实现逻辑\" class=\"headerlink\" title=\"二、实现逻辑\"></a>二、实现逻辑</h3><p>1.定义统一资产接口，每种资产实现此接口，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">AssetService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Integer <span class=\"title\">assetType</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">DealListResponse <span class=\"title\">queryDealList</span><span class=\"params\">(Integer assetId, Integer status, Integer sinceId, Integer count)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2.资产service实现接口，并重写assetType()和queryDealList()方法，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CashService</span> <span class=\"keyword\">implements</span> <span class=\"title\">AssetService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> CashDetailService cashDetailService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">assetType</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> AssetType.CASH.getId();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DealListResponse <span class=\"title\">queryDealList</span><span class=\"params\">(Integer assetId, Integer status, Integer sinceId, Integer count)</span> </span>&#123;</span><br><span class=\"line\">\t\t   </span><br><span class=\"line\">\t &#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.统一分发路由类，根据assetType调用对应的service,代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AssetServiceRoute</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AssetService[] assetServices;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> AssetService <span class=\"title\">route</span><span class=\"params\">(Integer assetType)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (AssetService assetService : assetServices) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Objects.equals(assetType, assetService.assetType())) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> assetService;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BusinessRuntimeException(GiveErrorCode.CHECK_PARAM_FAILED);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4.调用，代码如下；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> DealListResponse <span class=\"title\">dealList</span><span class=\"params\">(Integer assetType, Integer assetId, Integer status, Integer sinceId, Integer count)</span> </span>&#123;</span><br><span class=\"line\">       AssetService assetService = assetServiceRoute.route(assetType);</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (assetService == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BusinessRuntimeException(GiveErrorCode.INVALID_PARAMS);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> assetService.queryDealList(assetId, status, sinceId, count);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"三、代码分析\"><a href=\"#三、代码分析\" class=\"headerlink\" title=\"三、代码分析\"></a>三、代码分析</h3><p>意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。<br>主要解决：在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护（违反开闭原则）。<br>何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。<br>如何解决：将这些算法封装成一个一个的类，任意地替换。<br>关键代码：实现同一个接口。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、业务场景\"><a href=\"#一、业务场景\" class=\"headerlink\" title=\"一、业务场景\"></a>一、业务场景</h3><p>一个接口需要根据前段传入的资产类型（assetType），调用不同的业务类中的资产明细方法（dealList），最初的做法就是最常见的switch case或者if/else调用不同的service。相信每个程序员看到代码中大段的判断逻辑代码都会很头疼，刚好之前看过《重构既有代码》这本Java届的经典书，里面就明确指出switch case违反开闭原则，可以用策略模式改写。</p>\n<h3 id=\"二、实现逻辑\"><a href=\"#二、实现逻辑\" class=\"headerlink\" title=\"二、实现逻辑\"></a>二、实现逻辑</h3><p>1.定义统一资产接口，每种资产实现此接口，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">AssetService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Integer <span class=\"title\">assetType</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">DealListResponse <span class=\"title\">queryDealList</span><span class=\"params\">(Integer assetId, Integer status, Integer sinceId, Integer count)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>2.资产service实现接口，并重写assetType()和queryDealList()方法，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CashService</span> <span class=\"keyword\">implements</span> <span class=\"title\">AssetService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> CashDetailService cashDetailService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">assetType</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> AssetType.CASH.getId();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DealListResponse <span class=\"title\">queryDealList</span><span class=\"params\">(Integer assetId, Integer status, Integer sinceId, Integer count)</span> </span>&#123;</span><br><span class=\"line\">\t\t   </span><br><span class=\"line\">\t &#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.统一分发路由类，根据assetType调用对应的service,代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AssetServiceRoute</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AssetService[] assetServices;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> AssetService <span class=\"title\">route</span><span class=\"params\">(Integer assetType)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (AssetService assetService : assetServices) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (Objects.equals(assetType, assetService.assetType())) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> assetService;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BusinessRuntimeException(GiveErrorCode.CHECK_PARAM_FAILED);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4.调用，代码如下；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> DealListResponse <span class=\"title\">dealList</span><span class=\"params\">(Integer assetType, Integer assetId, Integer status, Integer sinceId, Integer count)</span> </span>&#123;</span><br><span class=\"line\">       AssetService assetService = assetServiceRoute.route(assetType);</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (assetService == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BusinessRuntimeException(GiveErrorCode.INVALID_PARAMS);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> assetService.queryDealList(assetId, status, sinceId, count);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"三、代码分析\"><a href=\"#三、代码分析\" class=\"headerlink\" title=\"三、代码分析\"></a>三、代码分析</h3><p>意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。<br>主要解决：在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护（违反开闭原则）。<br>何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。<br>如何解决：将这些算法封装成一个一个的类，任意地替换。<br>关键代码：实现同一个接口。</p>\n"},{"title":"java多线程之并发工具类","date":"2019-06-22T12:41:00.000Z","_content":"\n## CountDownLatch\n\n- CountDownLatch的作用：允许一个或多个线程，等待其他线程达到触发条件时（触发条件即CountDownLatch对象计数器减为0时）才开始执行\n- 主要方法\n    1. CountDownLatch构造函数：CountDownLatch的构造函数接收一个int类型的参数作为计数器，如果你想等待N个点完\n成，这里就传入N\n    2. countDown：当我们调用CountDownLatch的countDown方法时，N就会减1\n    3. await:CountDownLatch的await方法\n会阻塞当前线程，直到N变成零,当前线程才会执行；await（long time，TimeUnit unit）这个方法等待特定时\n间后，就会不再阻塞当前线程\n- 示例代码：\n```\n**\n * @Description: TODO\n * @Auther: ThomasWu\n * @Date: 2019/6/22 20:53\n * @Email:1414924381@qq.com\n */\npublic class CountDownLatchTest {\n\n    private static class WorkTask extends Thread {\n        private CountDownLatch countDownLatch;\n\n        public WorkTask(String name, CountDownLatch countDownLatch) {\n            super(name);\n            this.countDownLatch = countDownLatch;\n        }\n\n        @Override\n        public void run() {\n            try {\n                System.out.println(this.getName() + \"启动了\"+System.currentTimeMillis());\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                System.out.println(this.getName() + \"执行完了\"+System.currentTimeMillis());\n                countDownLatch.countDown();\n            }\n        }\n    }\n\n    private static class DoneTask extends Thread {\n        private CountDownLatch countDownLatch;\n\n        public DoneTask(String name, CountDownLatch countDownLatch) {\n            super(name);\n            this.countDownLatch = countDownLatch;\n        }\n\n        @Override\n        public void run() {\n            try {\n                System.out.println(this.getName() + \"开始等待\"+System.currentTimeMillis());\n                countDownLatch.await();\n                System.out.println(this.getName() + \"执行完了\"+System.currentTimeMillis());\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n\n    public static void main(String[] args) {\n        CountDownLatch countDownLatch=new CountDownLatch(3);\n        ExecutorService service=Executors.newFixedThreadPool(5);\n        service.submit(new DoneTask(\"DonwTask1\",countDownLatch));\n        service.submit(new DoneTask(\"DoneTask2\",countDownLatch));\n        service.submit(new WorkTask(\"workTask1\",countDownLatch));\n        service.submit(new WorkTask(\"workTask2\",countDownLatch));\n        service.submit(new WorkTask(\"workTask3\",countDownLatch));\n    }\n}\n\nconsole result\nDonwTask1开始等待1561210606078\nDoneTask2开始等待1561210606078\nworkTask2启动了1561210606079\nworkTask1启动了1561210606079\nworkTask3启动了1561210606079\nworkTask3执行完了1561210607079\nworkTask2执行完了1561210607079\nworkTask1执行完了1561210607079\nDonwTask1执行完了1561210607079\nDoneTask2执行完了1561210607079\n```\n\n## CyclicBarrier(同步屏障或栅栏)\n\n- CyclicBarrier作用:让一\n组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会\n开门，所有被屏障拦截的线程才会继续运行\n- 主要方法\n    1. 构造函数CyclicBarrier（int parties，Runnable barrierAction）:用于在线程到达屏障时，优先执行barrierAction\n    2. 默认构造函数CyclicBarrier（int parties）：屏障拦截的线程数\n量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞\n    3. await:调用该方法的线程会被阻塞\n- 注意：线程池中使用CyclicBarrier ，要考虑线程被阻塞问题，\n\n- 示例代码\n```\n/**\n * @Description: 多任务结算银行流水\n * @Auther: ThomasWu\n * @Date: 2019/6/22 22:32\n * @Email:1414924381@qq.com\n */\npublic class CyclicBarrierTest {\n    static class BankWaterTask implements Runnable {\n        private ConcurrentHashMap<String, Integer> sheetBankWaterCount = new ConcurrentHashMap<String, Integer>();\n        private CyclicBarrier c = new CyclicBarrier(4, this);\n        private Executor executor = Executors.newFixedThreadPool(4);\n\n        private void count() {\n            System.out.println(\"count 开始\" + System.currentTimeMillis());\n            for (int i = 0; i < 4; i++) {\n                executor.execute(() -> {\n                    sheetBankWaterCount.put(Thread.currentThread().getName(), 1);\n                    try {\n                        c.await();\n                    } catch (InterruptedException | BrokenBarrierException e) {\n                        e.printStackTrace();\n                    }\n                });\n            }\n            System.out.println(\"count 结束\" + System.currentTimeMillis());\n        }\n\n        @Override\n        public void run() {\n            System.out.println(\"run\" + System.currentTimeMillis());\n            int result = 0;\n            for (Map.Entry<String, Integer> sheet : sheetBankWaterCount.entrySet()) {\n                result += sheet.getValue();\n            }\n            sheetBankWaterCount.put(\"result\", result);\n            System.out.println(result);\n        }\n\n    }\n\n   public static void main(String[] args) {\n        BankWaterTask task = new BankWaterTask();\n        task.count();\n    }\n```\n\n### CyclicBarrier和CountDownLatch的区别\n- CountDownLatch：调用countDown的线程（A线程），调用了await的线程（B线程），A线程先执行，B线程阻塞，满足条件（计数器为0时）B线程开始执行，没有被阻塞；\n- CyclicBarrier：构造函数传入barrierAction线程（A线程） ，调用了await的线程（B线程），A线程先阻塞，B线程也阻塞，满足条件（B线程都调用都调用await后），A线程开始执行完后，B线程开始执行\n- CyclicBarrier：barrierAction只能指定一个线程\n- CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置\n- CyclicBarrier还提供其他有用的方法\n    1. getNumberWaiting方法可以获得Cyclic-Barrier阻塞的线程数量\n    2. isBroken()方法用来了解阻塞的线程是否被中断\n\n ## Semaphore \n\n- Semaphore的作用：用来控制同时访问特定资源的线程数量，它通过协调各个线程，以\n保证合理的使用公共资源\n- 使用场景： Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。假\n如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程\n并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这\n时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连\n接。这个时候，就可以使用Semaphore来做流量控制\n- 主要方法：\n    1. Semaphore（int permits）：接受一个整型的数字，表示可用的许可证数量\n    2. void acquire()：获取一个许可证，如果当前信号量大于0，则当前信号量的计数减1，该方法直接返回；如果当前信号量等于0，则当前线程会被放入AQS阻塞队列\n    3. void release():将当前信号量加1\n\n示例代码：\n```\n\n/**\n * @Description: TODO\n * @Auther: ThomasWu\n * @Date: 2019/6/23 15:19\n * @Email:1414924381@qq.com\n */\npublic class SemaphoreTest {\n    private static final int THREAD_COUNT = 10;\n    private static ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);\n    private static Semaphore s = new Semaphore(5);\n\n    public static void main(String[] args) {\n        for (int i = 0; i < THREAD_COUNT; i++) {\n            threadPool.execute(() -> {\n                try {\n                    s.acquire();\n                    System.out.println(Thread.currentThread().getName()+\"获得了信号量\"+\"---当前信号量:\"+s.availablePermits()+\"---等待信号量的线程数:\"+s.getQueueLength()+\"---\"+System.currentTimeMillis());\n                    Thread.sleep(2000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }finally {\n                    s.release();\n                    System.out.println(Thread.currentThread().getName()+\"释放了信号量------\"+\"---当前信号量:\"+s.availablePermits()+\"---等待信号量的线程数:\"+s.getQueueLength()+System.currentTimeMillis());\n                }\n            });\n        }\n        threadPool.shutdown();\n    }\n}\n\nconsole result\npool-1-thread-2获得了信号量---当前信号量:4---等待信号量的线程数:0---1561275554694\npool-1-thread-1获得了信号量---当前信号量:3---等待信号量的线程数:0---1561275554694\npool-1-thread-4获得了信号量---当前信号量:2---等待信号量的线程数:0---1561275554694\npool-1-thread-3获得了信号量---当前信号量:1---等待信号量的线程数:0---1561275554694\npool-1-thread-5获得了信号量---当前信号量:0---等待信号量的线程数:0---1561275554694\npool-1-thread-6获得了信号量---当前信号量:0---等待信号量的线程数:4---1561275556695\npool-1-thread-7获得了信号量---当前信号量:0---等待信号量的线程数:3---1561275556695\npool-1-thread-4释放了信号量---------当前信号量:0---等待信号量的线程数:31561275556695\npool-1-thread-1释放了信号量---------当前信号量:0---等待信号量的线程数:31561275556695\npool-1-thread-8获得了信号量---当前信号量:0---等待信号量的线程数:2---1561275556695\npool-1-thread-2释放了信号量---------当前信号量:0---等待信号量的线程数:21561275556695\npool-1-thread-9获得了信号量---当前信号量:1---等待信号量的线程数:0---1561275556696\npool-1-thread-3释放了信号量---------当前信号量:0---等待信号量的线程数:01561275556696\npool-1-thread-5释放了信号量---------当前信号量:1---等待信号量的线程数:01561275556696\npool-1-thread-10获得了信号量---当前信号量:0---等待信号量的线程数:0---1561275556696\npool-1-thread-6释放了信号量---------当前信号量:1---等待信号量的线程数:01561275558695\npool-1-thread-8释放了信号量---------当前信号量:3---等待信号量的线程数:01561275558695\npool-1-thread-7释放了信号量---------当前信号量:2---等待信号量的线程数:01561275558695\npool-1-thread-10释放了信号量---------当前信号量:5---等待信号量的线程数:01561275558696\npool-1-thread-9释放了信号量---------当前信号量:5---等待信号量的线程数:01561275558696\n```\n\n\n\n ## Exchanger\n\n - Exchanger作用：用于进行线程间的数据交\n换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过\nexchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也\n执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产\n出来的数据传递给对方。\n- 注意：如果两个线程有一个没有执行exchange()方法，则会一直等待，如果担心有特殊情况发\n生，避免一直等待，可以使用exchange（V x，longtimeout，TimeUnit unit）设置最大等待时长\n\n\n\n 示例代码：\n ```\n/**\n * @Description: TODO\n * @Auther: ThomasWu\n * @Date: 2019/6/23 15:53\n * @Email:1414924381@qq.com\n */\npublic class ExchangerTest {\n\n    private static final Exchanger<String> exchanger = new Exchanger<String>();\n    private static ExecutorService threadPool = Executors.newFixedThreadPool(2);\n\n    public static void main(String[] args) {\n        threadPool.execute(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    // A录入银行流水数据\n                    String str = \"银行流水A\";\n                    System.out.println(Thread.currentThread().getName() + str);\n                    str = exchanger.exchange(str);\n                    System.out.println(Thread.currentThread().getName() + str);\n                } catch (InterruptedException e) {\n                }\n            }\n        });\n        threadPool.execute(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    String str = \"银行流水B\";\n                    System.out.println(Thread.currentThread().getName() + str);\n                    str = exchanger.exchange(str);\n                    System.out.println(Thread.currentThread().getName() + str);\n\n                } catch (InterruptedException e) {\n                }\n            }\n        });\n        threadPool.shutdown();\n    }\n}\n\n ```","source":"_posts/java多线程之并发工具类.md","raw":"---\ntitle: java多线程之并发工具类\ndate: 2019-06-22 20:41:00\ncategories: java多线程\ntags: java\n---\n\n## CountDownLatch\n\n- CountDownLatch的作用：允许一个或多个线程，等待其他线程达到触发条件时（触发条件即CountDownLatch对象计数器减为0时）才开始执行\n- 主要方法\n    1. CountDownLatch构造函数：CountDownLatch的构造函数接收一个int类型的参数作为计数器，如果你想等待N个点完\n成，这里就传入N\n    2. countDown：当我们调用CountDownLatch的countDown方法时，N就会减1\n    3. await:CountDownLatch的await方法\n会阻塞当前线程，直到N变成零,当前线程才会执行；await（long time，TimeUnit unit）这个方法等待特定时\n间后，就会不再阻塞当前线程\n- 示例代码：\n```\n**\n * @Description: TODO\n * @Auther: ThomasWu\n * @Date: 2019/6/22 20:53\n * @Email:1414924381@qq.com\n */\npublic class CountDownLatchTest {\n\n    private static class WorkTask extends Thread {\n        private CountDownLatch countDownLatch;\n\n        public WorkTask(String name, CountDownLatch countDownLatch) {\n            super(name);\n            this.countDownLatch = countDownLatch;\n        }\n\n        @Override\n        public void run() {\n            try {\n                System.out.println(this.getName() + \"启动了\"+System.currentTimeMillis());\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                System.out.println(this.getName() + \"执行完了\"+System.currentTimeMillis());\n                countDownLatch.countDown();\n            }\n        }\n    }\n\n    private static class DoneTask extends Thread {\n        private CountDownLatch countDownLatch;\n\n        public DoneTask(String name, CountDownLatch countDownLatch) {\n            super(name);\n            this.countDownLatch = countDownLatch;\n        }\n\n        @Override\n        public void run() {\n            try {\n                System.out.println(this.getName() + \"开始等待\"+System.currentTimeMillis());\n                countDownLatch.await();\n                System.out.println(this.getName() + \"执行完了\"+System.currentTimeMillis());\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n\n    public static void main(String[] args) {\n        CountDownLatch countDownLatch=new CountDownLatch(3);\n        ExecutorService service=Executors.newFixedThreadPool(5);\n        service.submit(new DoneTask(\"DonwTask1\",countDownLatch));\n        service.submit(new DoneTask(\"DoneTask2\",countDownLatch));\n        service.submit(new WorkTask(\"workTask1\",countDownLatch));\n        service.submit(new WorkTask(\"workTask2\",countDownLatch));\n        service.submit(new WorkTask(\"workTask3\",countDownLatch));\n    }\n}\n\nconsole result\nDonwTask1开始等待1561210606078\nDoneTask2开始等待1561210606078\nworkTask2启动了1561210606079\nworkTask1启动了1561210606079\nworkTask3启动了1561210606079\nworkTask3执行完了1561210607079\nworkTask2执行完了1561210607079\nworkTask1执行完了1561210607079\nDonwTask1执行完了1561210607079\nDoneTask2执行完了1561210607079\n```\n\n## CyclicBarrier(同步屏障或栅栏)\n\n- CyclicBarrier作用:让一\n组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会\n开门，所有被屏障拦截的线程才会继续运行\n- 主要方法\n    1. 构造函数CyclicBarrier（int parties，Runnable barrierAction）:用于在线程到达屏障时，优先执行barrierAction\n    2. 默认构造函数CyclicBarrier（int parties）：屏障拦截的线程数\n量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞\n    3. await:调用该方法的线程会被阻塞\n- 注意：线程池中使用CyclicBarrier ，要考虑线程被阻塞问题，\n\n- 示例代码\n```\n/**\n * @Description: 多任务结算银行流水\n * @Auther: ThomasWu\n * @Date: 2019/6/22 22:32\n * @Email:1414924381@qq.com\n */\npublic class CyclicBarrierTest {\n    static class BankWaterTask implements Runnable {\n        private ConcurrentHashMap<String, Integer> sheetBankWaterCount = new ConcurrentHashMap<String, Integer>();\n        private CyclicBarrier c = new CyclicBarrier(4, this);\n        private Executor executor = Executors.newFixedThreadPool(4);\n\n        private void count() {\n            System.out.println(\"count 开始\" + System.currentTimeMillis());\n            for (int i = 0; i < 4; i++) {\n                executor.execute(() -> {\n                    sheetBankWaterCount.put(Thread.currentThread().getName(), 1);\n                    try {\n                        c.await();\n                    } catch (InterruptedException | BrokenBarrierException e) {\n                        e.printStackTrace();\n                    }\n                });\n            }\n            System.out.println(\"count 结束\" + System.currentTimeMillis());\n        }\n\n        @Override\n        public void run() {\n            System.out.println(\"run\" + System.currentTimeMillis());\n            int result = 0;\n            for (Map.Entry<String, Integer> sheet : sheetBankWaterCount.entrySet()) {\n                result += sheet.getValue();\n            }\n            sheetBankWaterCount.put(\"result\", result);\n            System.out.println(result);\n        }\n\n    }\n\n   public static void main(String[] args) {\n        BankWaterTask task = new BankWaterTask();\n        task.count();\n    }\n```\n\n### CyclicBarrier和CountDownLatch的区别\n- CountDownLatch：调用countDown的线程（A线程），调用了await的线程（B线程），A线程先执行，B线程阻塞，满足条件（计数器为0时）B线程开始执行，没有被阻塞；\n- CyclicBarrier：构造函数传入barrierAction线程（A线程） ，调用了await的线程（B线程），A线程先阻塞，B线程也阻塞，满足条件（B线程都调用都调用await后），A线程开始执行完后，B线程开始执行\n- CyclicBarrier：barrierAction只能指定一个线程\n- CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置\n- CyclicBarrier还提供其他有用的方法\n    1. getNumberWaiting方法可以获得Cyclic-Barrier阻塞的线程数量\n    2. isBroken()方法用来了解阻塞的线程是否被中断\n\n ## Semaphore \n\n- Semaphore的作用：用来控制同时访问特定资源的线程数量，它通过协调各个线程，以\n保证合理的使用公共资源\n- 使用场景： Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。假\n如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程\n并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这\n时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连\n接。这个时候，就可以使用Semaphore来做流量控制\n- 主要方法：\n    1. Semaphore（int permits）：接受一个整型的数字，表示可用的许可证数量\n    2. void acquire()：获取一个许可证，如果当前信号量大于0，则当前信号量的计数减1，该方法直接返回；如果当前信号量等于0，则当前线程会被放入AQS阻塞队列\n    3. void release():将当前信号量加1\n\n示例代码：\n```\n\n/**\n * @Description: TODO\n * @Auther: ThomasWu\n * @Date: 2019/6/23 15:19\n * @Email:1414924381@qq.com\n */\npublic class SemaphoreTest {\n    private static final int THREAD_COUNT = 10;\n    private static ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);\n    private static Semaphore s = new Semaphore(5);\n\n    public static void main(String[] args) {\n        for (int i = 0; i < THREAD_COUNT; i++) {\n            threadPool.execute(() -> {\n                try {\n                    s.acquire();\n                    System.out.println(Thread.currentThread().getName()+\"获得了信号量\"+\"---当前信号量:\"+s.availablePermits()+\"---等待信号量的线程数:\"+s.getQueueLength()+\"---\"+System.currentTimeMillis());\n                    Thread.sleep(2000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }finally {\n                    s.release();\n                    System.out.println(Thread.currentThread().getName()+\"释放了信号量------\"+\"---当前信号量:\"+s.availablePermits()+\"---等待信号量的线程数:\"+s.getQueueLength()+System.currentTimeMillis());\n                }\n            });\n        }\n        threadPool.shutdown();\n    }\n}\n\nconsole result\npool-1-thread-2获得了信号量---当前信号量:4---等待信号量的线程数:0---1561275554694\npool-1-thread-1获得了信号量---当前信号量:3---等待信号量的线程数:0---1561275554694\npool-1-thread-4获得了信号量---当前信号量:2---等待信号量的线程数:0---1561275554694\npool-1-thread-3获得了信号量---当前信号量:1---等待信号量的线程数:0---1561275554694\npool-1-thread-5获得了信号量---当前信号量:0---等待信号量的线程数:0---1561275554694\npool-1-thread-6获得了信号量---当前信号量:0---等待信号量的线程数:4---1561275556695\npool-1-thread-7获得了信号量---当前信号量:0---等待信号量的线程数:3---1561275556695\npool-1-thread-4释放了信号量---------当前信号量:0---等待信号量的线程数:31561275556695\npool-1-thread-1释放了信号量---------当前信号量:0---等待信号量的线程数:31561275556695\npool-1-thread-8获得了信号量---当前信号量:0---等待信号量的线程数:2---1561275556695\npool-1-thread-2释放了信号量---------当前信号量:0---等待信号量的线程数:21561275556695\npool-1-thread-9获得了信号量---当前信号量:1---等待信号量的线程数:0---1561275556696\npool-1-thread-3释放了信号量---------当前信号量:0---等待信号量的线程数:01561275556696\npool-1-thread-5释放了信号量---------当前信号量:1---等待信号量的线程数:01561275556696\npool-1-thread-10获得了信号量---当前信号量:0---等待信号量的线程数:0---1561275556696\npool-1-thread-6释放了信号量---------当前信号量:1---等待信号量的线程数:01561275558695\npool-1-thread-8释放了信号量---------当前信号量:3---等待信号量的线程数:01561275558695\npool-1-thread-7释放了信号量---------当前信号量:2---等待信号量的线程数:01561275558695\npool-1-thread-10释放了信号量---------当前信号量:5---等待信号量的线程数:01561275558696\npool-1-thread-9释放了信号量---------当前信号量:5---等待信号量的线程数:01561275558696\n```\n\n\n\n ## Exchanger\n\n - Exchanger作用：用于进行线程间的数据交\n换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过\nexchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也\n执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产\n出来的数据传递给对方。\n- 注意：如果两个线程有一个没有执行exchange()方法，则会一直等待，如果担心有特殊情况发\n生，避免一直等待，可以使用exchange（V x，longtimeout，TimeUnit unit）设置最大等待时长\n\n\n\n 示例代码：\n ```\n/**\n * @Description: TODO\n * @Auther: ThomasWu\n * @Date: 2019/6/23 15:53\n * @Email:1414924381@qq.com\n */\npublic class ExchangerTest {\n\n    private static final Exchanger<String> exchanger = new Exchanger<String>();\n    private static ExecutorService threadPool = Executors.newFixedThreadPool(2);\n\n    public static void main(String[] args) {\n        threadPool.execute(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    // A录入银行流水数据\n                    String str = \"银行流水A\";\n                    System.out.println(Thread.currentThread().getName() + str);\n                    str = exchanger.exchange(str);\n                    System.out.println(Thread.currentThread().getName() + str);\n                } catch (InterruptedException e) {\n                }\n            }\n        });\n        threadPool.execute(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    String str = \"银行流水B\";\n                    System.out.println(Thread.currentThread().getName() + str);\n                    str = exchanger.exchange(str);\n                    System.out.println(Thread.currentThread().getName() + str);\n\n                } catch (InterruptedException e) {\n                }\n            }\n        });\n        threadPool.shutdown();\n    }\n}\n\n ```","slug":"java多线程之并发工具类","published":1,"updated":"2019-07-02T11:21:32.687Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzjwwni0026w4j940d4li4o","content":"<h2 id=\"CountDownLatch\"><a href=\"#CountDownLatch\" class=\"headerlink\" title=\"CountDownLatch\"></a>CountDownLatch</h2><ul>\n<li>CountDownLatch的作用：允许一个或多个线程，等待其他线程达到触发条件时（触发条件即CountDownLatch对象计数器减为0时）才开始执行</li>\n<li>主要方法<ol>\n<li>CountDownLatch构造函数：CountDownLatch的构造函数接收一个int类型的参数作为计数器，如果你想等待N个点完<br>成，这里就传入N</li>\n<li>countDown：当我们调用CountDownLatch的countDown方法时，N就会减1</li>\n<li>await:CountDownLatch的await方法<br>会阻塞当前线程，直到N变成零,当前线程才会执行；await（long time，TimeUnit unit）这个方法等待特定时<br>间后，就会不再阻塞当前线程</li>\n</ol>\n</li>\n<li>示例代码：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">**</span><br><span class=\"line\"> * @Description: TODO</span><br><span class=\"line\"> * @Auther: ThomasWu</span><br><span class=\"line\"> * @Date: 2019/6/22 20:53</span><br><span class=\"line\"> * @Email:1414924381@qq.com</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class CountDownLatchTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static class WorkTask extends Thread &#123;</span><br><span class=\"line\">        private CountDownLatch countDownLatch;</span><br><span class=\"line\"></span><br><span class=\"line\">        public WorkTask(String name, CountDownLatch countDownLatch) &#123;</span><br><span class=\"line\">            super(name);</span><br><span class=\"line\">            this.countDownLatch = countDownLatch;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                System.out.println(this.getName() + &quot;启动了&quot;+System.currentTimeMillis());</span><br><span class=\"line\">                Thread.sleep(1000);</span><br><span class=\"line\">            &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125; finally &#123;</span><br><span class=\"line\">                System.out.println(this.getName() + &quot;执行完了&quot;+System.currentTimeMillis());</span><br><span class=\"line\">                countDownLatch.countDown();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static class DoneTask extends Thread &#123;</span><br><span class=\"line\">        private CountDownLatch countDownLatch;</span><br><span class=\"line\"></span><br><span class=\"line\">        public DoneTask(String name, CountDownLatch countDownLatch) &#123;</span><br><span class=\"line\">            super(name);</span><br><span class=\"line\">            this.countDownLatch = countDownLatch;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                System.out.println(this.getName() + &quot;开始等待&quot;+System.currentTimeMillis());</span><br><span class=\"line\">                countDownLatch.await();</span><br><span class=\"line\">                System.out.println(this.getName() + &quot;执行完了&quot;+System.currentTimeMillis());</span><br><span class=\"line\">            &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        CountDownLatch countDownLatch=new CountDownLatch(3);</span><br><span class=\"line\">        ExecutorService service=Executors.newFixedThreadPool(5);</span><br><span class=\"line\">        service.submit(new DoneTask(&quot;DonwTask1&quot;,countDownLatch));</span><br><span class=\"line\">        service.submit(new DoneTask(&quot;DoneTask2&quot;,countDownLatch));</span><br><span class=\"line\">        service.submit(new WorkTask(&quot;workTask1&quot;,countDownLatch));</span><br><span class=\"line\">        service.submit(new WorkTask(&quot;workTask2&quot;,countDownLatch));</span><br><span class=\"line\">        service.submit(new WorkTask(&quot;workTask3&quot;,countDownLatch));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console result</span><br><span class=\"line\">DonwTask1开始等待1561210606078</span><br><span class=\"line\">DoneTask2开始等待1561210606078</span><br><span class=\"line\">workTask2启动了1561210606079</span><br><span class=\"line\">workTask1启动了1561210606079</span><br><span class=\"line\">workTask3启动了1561210606079</span><br><span class=\"line\">workTask3执行完了1561210607079</span><br><span class=\"line\">workTask2执行完了1561210607079</span><br><span class=\"line\">workTask1执行完了1561210607079</span><br><span class=\"line\">DonwTask1执行完了1561210607079</span><br><span class=\"line\">DoneTask2执行完了1561210607079</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"CyclicBarrier-同步屏障或栅栏\"><a href=\"#CyclicBarrier-同步屏障或栅栏\" class=\"headerlink\" title=\"CyclicBarrier(同步屏障或栅栏)\"></a>CyclicBarrier(同步屏障或栅栏)</h2><ul>\n<li><p>CyclicBarrier作用:让一<br>组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会<br>开门，所有被屏障拦截的线程才会继续运行</p>\n</li>\n<li><p>主要方法</p>\n<ol>\n<li>构造函数CyclicBarrier（int parties，Runnable barrierAction）:用于在线程到达屏障时，优先执行barrierAction</li>\n<li>默认构造函数CyclicBarrier（int parties）：屏障拦截的线程数<br>量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞</li>\n<li>await:调用该方法的线程会被阻塞</li>\n</ol>\n</li>\n<li><p>注意：线程池中使用CyclicBarrier ，要考虑线程被阻塞问题，</p>\n</li>\n<li><p>示例代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @Description: 多任务结算银行流水</span><br><span class=\"line\"> * @Auther: ThomasWu</span><br><span class=\"line\"> * @Date: 2019/6/22 22:32</span><br><span class=\"line\"> * @Email:1414924381@qq.com</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class CyclicBarrierTest &#123;</span><br><span class=\"line\">    static class BankWaterTask implements Runnable &#123;</span><br><span class=\"line\">        private ConcurrentHashMap&lt;String, Integer&gt; sheetBankWaterCount = new ConcurrentHashMap&lt;String, Integer&gt;();</span><br><span class=\"line\">        private CyclicBarrier c = new CyclicBarrier(4, this);</span><br><span class=\"line\">        private Executor executor = Executors.newFixedThreadPool(4);</span><br><span class=\"line\"></span><br><span class=\"line\">        private void count() &#123;</span><br><span class=\"line\">            System.out.println(&quot;count 开始&quot; + System.currentTimeMillis());</span><br><span class=\"line\">            for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class=\"line\">                executor.execute(() -&gt; &#123;</span><br><span class=\"line\">                    sheetBankWaterCount.put(Thread.currentThread().getName(), 1);</span><br><span class=\"line\">                    try &#123;</span><br><span class=\"line\">                        c.await();</span><br><span class=\"line\">                    &#125; catch (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(&quot;count 结束&quot; + System.currentTimeMillis());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            System.out.println(&quot;run&quot; + System.currentTimeMillis());</span><br><span class=\"line\">            int result = 0;</span><br><span class=\"line\">            for (Map.Entry&lt;String, Integer&gt; sheet : sheetBankWaterCount.entrySet()) &#123;</span><br><span class=\"line\">                result += sheet.getValue();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            sheetBankWaterCount.put(&quot;result&quot;, result);</span><br><span class=\"line\">            System.out.println(result);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   public static void main(String[] args) &#123;</span><br><span class=\"line\">        BankWaterTask task = new BankWaterTask();</span><br><span class=\"line\">        task.count();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"CyclicBarrier和CountDownLatch的区别\"><a href=\"#CyclicBarrier和CountDownLatch的区别\" class=\"headerlink\" title=\"CyclicBarrier和CountDownLatch的区别\"></a>CyclicBarrier和CountDownLatch的区别</h3><ul>\n<li><p>CountDownLatch：调用countDown的线程（A线程），调用了await的线程（B线程），A线程先执行，B线程阻塞，满足条件（计数器为0时）B线程开始执行，没有被阻塞；</p>\n</li>\n<li><p>CyclicBarrier：构造函数传入barrierAction线程（A线程） ，调用了await的线程（B线程），A线程先阻塞，B线程也阻塞，满足条件（B线程都调用都调用await后），A线程开始执行完后，B线程开始执行</p>\n</li>\n<li><p>CyclicBarrier：barrierAction只能指定一个线程</p>\n</li>\n<li><p>CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置</p>\n</li>\n<li><p>CyclicBarrier还提供其他有用的方法</p>\n<ol>\n<li>getNumberWaiting方法可以获得Cyclic-Barrier阻塞的线程数量</li>\n<li>isBroken()方法用来了解阻塞的线程是否被中断</li>\n</ol>\n<h2 id=\"Semaphore\"><a href=\"#Semaphore\" class=\"headerlink\" title=\"Semaphore\"></a>Semaphore</h2></li>\n<li><p>Semaphore的作用：用来控制同时访问特定资源的线程数量，它通过协调各个线程，以<br>保证合理的使用公共资源</p>\n</li>\n<li><p>使用场景： Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。假<br>如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程<br>并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这<br>时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连<br>接。这个时候，就可以使用Semaphore来做流量控制</p>\n</li>\n<li><p>主要方法：</p>\n<ol>\n<li>Semaphore（int permits）：接受一个整型的数字，表示可用的许可证数量</li>\n<li>void acquire()：获取一个许可证，如果当前信号量大于0，则当前信号量的计数减1，该方法直接返回；如果当前信号量等于0，则当前线程会被放入AQS阻塞队列</li>\n<li>void release():将当前信号量加1</li>\n</ol>\n</li>\n</ul>\n<p>示例代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @Description: TODO</span><br><span class=\"line\"> * @Auther: ThomasWu</span><br><span class=\"line\"> * @Date: 2019/6/23 15:19</span><br><span class=\"line\"> * @Email:1414924381@qq.com</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class SemaphoreTest &#123;</span><br><span class=\"line\">    private static final int THREAD_COUNT = 10;</span><br><span class=\"line\">    private static ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);</span><br><span class=\"line\">    private static Semaphore s = new Semaphore(5);</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; THREAD_COUNT; i++) &#123;</span><br><span class=\"line\">            threadPool.execute(() -&gt; &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    s.acquire();</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName()+&quot;获得了信号量&quot;+&quot;---当前信号量:&quot;+s.availablePermits()+&quot;---等待信号量的线程数:&quot;+s.getQueueLength()+&quot;---&quot;+System.currentTimeMillis());</span><br><span class=\"line\">                    Thread.sleep(2000);</span><br><span class=\"line\">                &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;finally &#123;</span><br><span class=\"line\">                    s.release();</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName()+&quot;释放了信号量------&quot;+&quot;---当前信号量:&quot;+s.availablePermits()+&quot;---等待信号量的线程数:&quot;+s.getQueueLength()+System.currentTimeMillis());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        threadPool.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console result</span><br><span class=\"line\">pool-1-thread-2获得了信号量---当前信号量:4---等待信号量的线程数:0---1561275554694</span><br><span class=\"line\">pool-1-thread-1获得了信号量---当前信号量:3---等待信号量的线程数:0---1561275554694</span><br><span class=\"line\">pool-1-thread-4获得了信号量---当前信号量:2---等待信号量的线程数:0---1561275554694</span><br><span class=\"line\">pool-1-thread-3获得了信号量---当前信号量:1---等待信号量的线程数:0---1561275554694</span><br><span class=\"line\">pool-1-thread-5获得了信号量---当前信号量:0---等待信号量的线程数:0---1561275554694</span><br><span class=\"line\">pool-1-thread-6获得了信号量---当前信号量:0---等待信号量的线程数:4---1561275556695</span><br><span class=\"line\">pool-1-thread-7获得了信号量---当前信号量:0---等待信号量的线程数:3---1561275556695</span><br><span class=\"line\">pool-1-thread-4释放了信号量---------当前信号量:0---等待信号量的线程数:31561275556695</span><br><span class=\"line\">pool-1-thread-1释放了信号量---------当前信号量:0---等待信号量的线程数:31561275556695</span><br><span class=\"line\">pool-1-thread-8获得了信号量---当前信号量:0---等待信号量的线程数:2---1561275556695</span><br><span class=\"line\">pool-1-thread-2释放了信号量---------当前信号量:0---等待信号量的线程数:21561275556695</span><br><span class=\"line\">pool-1-thread-9获得了信号量---当前信号量:1---等待信号量的线程数:0---1561275556696</span><br><span class=\"line\">pool-1-thread-3释放了信号量---------当前信号量:0---等待信号量的线程数:01561275556696</span><br><span class=\"line\">pool-1-thread-5释放了信号量---------当前信号量:1---等待信号量的线程数:01561275556696</span><br><span class=\"line\">pool-1-thread-10获得了信号量---当前信号量:0---等待信号量的线程数:0---1561275556696</span><br><span class=\"line\">pool-1-thread-6释放了信号量---------当前信号量:1---等待信号量的线程数:01561275558695</span><br><span class=\"line\">pool-1-thread-8释放了信号量---------当前信号量:3---等待信号量的线程数:01561275558695</span><br><span class=\"line\">pool-1-thread-7释放了信号量---------当前信号量:2---等待信号量的线程数:01561275558695</span><br><span class=\"line\">pool-1-thread-10释放了信号量---------当前信号量:5---等待信号量的线程数:01561275558696</span><br><span class=\"line\">pool-1-thread-9释放了信号量---------当前信号量:5---等待信号量的线程数:01561275558696</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Exchanger\"><a href=\"#Exchanger\" class=\"headerlink\" title=\"Exchanger\"></a>Exchanger</h2><ul>\n<li>Exchanger作用：用于进行线程间的数据交<br>换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过<br>exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也<br>执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产<br>出来的数据传递给对方。<ul>\n<li>注意：如果两个线程有一个没有执行exchange()方法，则会一直等待，如果担心有特殊情况发<br>生，避免一直等待，可以使用exchange（V x，longtimeout，TimeUnit unit）设置最大等待时长</li>\n</ul>\n</li>\n</ul>\n<p> 示例代码：<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @Description: TODO</span><br><span class=\"line\"> * @Auther: ThomasWu</span><br><span class=\"line\"> * @Date: 2019/6/23 15:53</span><br><span class=\"line\"> * @Email:1414924381@qq.com</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class ExchangerTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static final Exchanger&lt;String&gt; exchanger = new Exchanger&lt;String&gt;();</span><br><span class=\"line\">    private static ExecutorService threadPool = Executors.newFixedThreadPool(2);</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        threadPool.execute(new Runnable() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void run() &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    // A录入银行流水数据</span><br><span class=\"line\">                    String str = &quot;银行流水A&quot;;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + str);</span><br><span class=\"line\">                    str = exchanger.exchange(str);</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + str);</span><br><span class=\"line\">                &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        threadPool.execute(new Runnable() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void run() &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    String str = &quot;银行流水B&quot;;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + str);</span><br><span class=\"line\">                    str = exchanger.exchange(str);</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + str);</span><br><span class=\"line\"></span><br><span class=\"line\">                &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        threadPool.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"CountDownLatch\"><a href=\"#CountDownLatch\" class=\"headerlink\" title=\"CountDownLatch\"></a>CountDownLatch</h2><ul>\n<li>CountDownLatch的作用：允许一个或多个线程，等待其他线程达到触发条件时（触发条件即CountDownLatch对象计数器减为0时）才开始执行</li>\n<li>主要方法<ol>\n<li>CountDownLatch构造函数：CountDownLatch的构造函数接收一个int类型的参数作为计数器，如果你想等待N个点完<br>成，这里就传入N</li>\n<li>countDown：当我们调用CountDownLatch的countDown方法时，N就会减1</li>\n<li>await:CountDownLatch的await方法<br>会阻塞当前线程，直到N变成零,当前线程才会执行；await（long time，TimeUnit unit）这个方法等待特定时<br>间后，就会不再阻塞当前线程</li>\n</ol>\n</li>\n<li>示例代码：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">**</span><br><span class=\"line\"> * @Description: TODO</span><br><span class=\"line\"> * @Auther: ThomasWu</span><br><span class=\"line\"> * @Date: 2019/6/22 20:53</span><br><span class=\"line\"> * @Email:1414924381@qq.com</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class CountDownLatchTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static class WorkTask extends Thread &#123;</span><br><span class=\"line\">        private CountDownLatch countDownLatch;</span><br><span class=\"line\"></span><br><span class=\"line\">        public WorkTask(String name, CountDownLatch countDownLatch) &#123;</span><br><span class=\"line\">            super(name);</span><br><span class=\"line\">            this.countDownLatch = countDownLatch;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                System.out.println(this.getName() + &quot;启动了&quot;+System.currentTimeMillis());</span><br><span class=\"line\">                Thread.sleep(1000);</span><br><span class=\"line\">            &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125; finally &#123;</span><br><span class=\"line\">                System.out.println(this.getName() + &quot;执行完了&quot;+System.currentTimeMillis());</span><br><span class=\"line\">                countDownLatch.countDown();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static class DoneTask extends Thread &#123;</span><br><span class=\"line\">        private CountDownLatch countDownLatch;</span><br><span class=\"line\"></span><br><span class=\"line\">        public DoneTask(String name, CountDownLatch countDownLatch) &#123;</span><br><span class=\"line\">            super(name);</span><br><span class=\"line\">            this.countDownLatch = countDownLatch;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                System.out.println(this.getName() + &quot;开始等待&quot;+System.currentTimeMillis());</span><br><span class=\"line\">                countDownLatch.await();</span><br><span class=\"line\">                System.out.println(this.getName() + &quot;执行完了&quot;+System.currentTimeMillis());</span><br><span class=\"line\">            &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        CountDownLatch countDownLatch=new CountDownLatch(3);</span><br><span class=\"line\">        ExecutorService service=Executors.newFixedThreadPool(5);</span><br><span class=\"line\">        service.submit(new DoneTask(&quot;DonwTask1&quot;,countDownLatch));</span><br><span class=\"line\">        service.submit(new DoneTask(&quot;DoneTask2&quot;,countDownLatch));</span><br><span class=\"line\">        service.submit(new WorkTask(&quot;workTask1&quot;,countDownLatch));</span><br><span class=\"line\">        service.submit(new WorkTask(&quot;workTask2&quot;,countDownLatch));</span><br><span class=\"line\">        service.submit(new WorkTask(&quot;workTask3&quot;,countDownLatch));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console result</span><br><span class=\"line\">DonwTask1开始等待1561210606078</span><br><span class=\"line\">DoneTask2开始等待1561210606078</span><br><span class=\"line\">workTask2启动了1561210606079</span><br><span class=\"line\">workTask1启动了1561210606079</span><br><span class=\"line\">workTask3启动了1561210606079</span><br><span class=\"line\">workTask3执行完了1561210607079</span><br><span class=\"line\">workTask2执行完了1561210607079</span><br><span class=\"line\">workTask1执行完了1561210607079</span><br><span class=\"line\">DonwTask1执行完了1561210607079</span><br><span class=\"line\">DoneTask2执行完了1561210607079</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"CyclicBarrier-同步屏障或栅栏\"><a href=\"#CyclicBarrier-同步屏障或栅栏\" class=\"headerlink\" title=\"CyclicBarrier(同步屏障或栅栏)\"></a>CyclicBarrier(同步屏障或栅栏)</h2><ul>\n<li><p>CyclicBarrier作用:让一<br>组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会<br>开门，所有被屏障拦截的线程才会继续运行</p>\n</li>\n<li><p>主要方法</p>\n<ol>\n<li>构造函数CyclicBarrier（int parties，Runnable barrierAction）:用于在线程到达屏障时，优先执行barrierAction</li>\n<li>默认构造函数CyclicBarrier（int parties）：屏障拦截的线程数<br>量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞</li>\n<li>await:调用该方法的线程会被阻塞</li>\n</ol>\n</li>\n<li><p>注意：线程池中使用CyclicBarrier ，要考虑线程被阻塞问题，</p>\n</li>\n<li><p>示例代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @Description: 多任务结算银行流水</span><br><span class=\"line\"> * @Auther: ThomasWu</span><br><span class=\"line\"> * @Date: 2019/6/22 22:32</span><br><span class=\"line\"> * @Email:1414924381@qq.com</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class CyclicBarrierTest &#123;</span><br><span class=\"line\">    static class BankWaterTask implements Runnable &#123;</span><br><span class=\"line\">        private ConcurrentHashMap&lt;String, Integer&gt; sheetBankWaterCount = new ConcurrentHashMap&lt;String, Integer&gt;();</span><br><span class=\"line\">        private CyclicBarrier c = new CyclicBarrier(4, this);</span><br><span class=\"line\">        private Executor executor = Executors.newFixedThreadPool(4);</span><br><span class=\"line\"></span><br><span class=\"line\">        private void count() &#123;</span><br><span class=\"line\">            System.out.println(&quot;count 开始&quot; + System.currentTimeMillis());</span><br><span class=\"line\">            for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class=\"line\">                executor.execute(() -&gt; &#123;</span><br><span class=\"line\">                    sheetBankWaterCount.put(Thread.currentThread().getName(), 1);</span><br><span class=\"line\">                    try &#123;</span><br><span class=\"line\">                        c.await();</span><br><span class=\"line\">                    &#125; catch (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class=\"line\">                        e.printStackTrace();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(&quot;count 结束&quot; + System.currentTimeMillis());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @Override</span><br><span class=\"line\">        public void run() &#123;</span><br><span class=\"line\">            System.out.println(&quot;run&quot; + System.currentTimeMillis());</span><br><span class=\"line\">            int result = 0;</span><br><span class=\"line\">            for (Map.Entry&lt;String, Integer&gt; sheet : sheetBankWaterCount.entrySet()) &#123;</span><br><span class=\"line\">                result += sheet.getValue();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            sheetBankWaterCount.put(&quot;result&quot;, result);</span><br><span class=\"line\">            System.out.println(result);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   public static void main(String[] args) &#123;</span><br><span class=\"line\">        BankWaterTask task = new BankWaterTask();</span><br><span class=\"line\">        task.count();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"CyclicBarrier和CountDownLatch的区别\"><a href=\"#CyclicBarrier和CountDownLatch的区别\" class=\"headerlink\" title=\"CyclicBarrier和CountDownLatch的区别\"></a>CyclicBarrier和CountDownLatch的区别</h3><ul>\n<li><p>CountDownLatch：调用countDown的线程（A线程），调用了await的线程（B线程），A线程先执行，B线程阻塞，满足条件（计数器为0时）B线程开始执行，没有被阻塞；</p>\n</li>\n<li><p>CyclicBarrier：构造函数传入barrierAction线程（A线程） ，调用了await的线程（B线程），A线程先阻塞，B线程也阻塞，满足条件（B线程都调用都调用await后），A线程开始执行完后，B线程开始执行</p>\n</li>\n<li><p>CyclicBarrier：barrierAction只能指定一个线程</p>\n</li>\n<li><p>CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置</p>\n</li>\n<li><p>CyclicBarrier还提供其他有用的方法</p>\n<ol>\n<li>getNumberWaiting方法可以获得Cyclic-Barrier阻塞的线程数量</li>\n<li>isBroken()方法用来了解阻塞的线程是否被中断</li>\n</ol>\n<h2 id=\"Semaphore\"><a href=\"#Semaphore\" class=\"headerlink\" title=\"Semaphore\"></a>Semaphore</h2></li>\n<li><p>Semaphore的作用：用来控制同时访问特定资源的线程数量，它通过协调各个线程，以<br>保证合理的使用公共资源</p>\n</li>\n<li><p>使用场景： Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。假<br>如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程<br>并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这<br>时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连<br>接。这个时候，就可以使用Semaphore来做流量控制</p>\n</li>\n<li><p>主要方法：</p>\n<ol>\n<li>Semaphore（int permits）：接受一个整型的数字，表示可用的许可证数量</li>\n<li>void acquire()：获取一个许可证，如果当前信号量大于0，则当前信号量的计数减1，该方法直接返回；如果当前信号量等于0，则当前线程会被放入AQS阻塞队列</li>\n<li>void release():将当前信号量加1</li>\n</ol>\n</li>\n</ul>\n<p>示例代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @Description: TODO</span><br><span class=\"line\"> * @Auther: ThomasWu</span><br><span class=\"line\"> * @Date: 2019/6/23 15:19</span><br><span class=\"line\"> * @Email:1414924381@qq.com</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class SemaphoreTest &#123;</span><br><span class=\"line\">    private static final int THREAD_COUNT = 10;</span><br><span class=\"line\">    private static ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);</span><br><span class=\"line\">    private static Semaphore s = new Semaphore(5);</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; THREAD_COUNT; i++) &#123;</span><br><span class=\"line\">            threadPool.execute(() -&gt; &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    s.acquire();</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName()+&quot;获得了信号量&quot;+&quot;---当前信号量:&quot;+s.availablePermits()+&quot;---等待信号量的线程数:&quot;+s.getQueueLength()+&quot;---&quot;+System.currentTimeMillis());</span><br><span class=\"line\">                    Thread.sleep(2000);</span><br><span class=\"line\">                &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;finally &#123;</span><br><span class=\"line\">                    s.release();</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName()+&quot;释放了信号量------&quot;+&quot;---当前信号量:&quot;+s.availablePermits()+&quot;---等待信号量的线程数:&quot;+s.getQueueLength()+System.currentTimeMillis());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        threadPool.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console result</span><br><span class=\"line\">pool-1-thread-2获得了信号量---当前信号量:4---等待信号量的线程数:0---1561275554694</span><br><span class=\"line\">pool-1-thread-1获得了信号量---当前信号量:3---等待信号量的线程数:0---1561275554694</span><br><span class=\"line\">pool-1-thread-4获得了信号量---当前信号量:2---等待信号量的线程数:0---1561275554694</span><br><span class=\"line\">pool-1-thread-3获得了信号量---当前信号量:1---等待信号量的线程数:0---1561275554694</span><br><span class=\"line\">pool-1-thread-5获得了信号量---当前信号量:0---等待信号量的线程数:0---1561275554694</span><br><span class=\"line\">pool-1-thread-6获得了信号量---当前信号量:0---等待信号量的线程数:4---1561275556695</span><br><span class=\"line\">pool-1-thread-7获得了信号量---当前信号量:0---等待信号量的线程数:3---1561275556695</span><br><span class=\"line\">pool-1-thread-4释放了信号量---------当前信号量:0---等待信号量的线程数:31561275556695</span><br><span class=\"line\">pool-1-thread-1释放了信号量---------当前信号量:0---等待信号量的线程数:31561275556695</span><br><span class=\"line\">pool-1-thread-8获得了信号量---当前信号量:0---等待信号量的线程数:2---1561275556695</span><br><span class=\"line\">pool-1-thread-2释放了信号量---------当前信号量:0---等待信号量的线程数:21561275556695</span><br><span class=\"line\">pool-1-thread-9获得了信号量---当前信号量:1---等待信号量的线程数:0---1561275556696</span><br><span class=\"line\">pool-1-thread-3释放了信号量---------当前信号量:0---等待信号量的线程数:01561275556696</span><br><span class=\"line\">pool-1-thread-5释放了信号量---------当前信号量:1---等待信号量的线程数:01561275556696</span><br><span class=\"line\">pool-1-thread-10获得了信号量---当前信号量:0---等待信号量的线程数:0---1561275556696</span><br><span class=\"line\">pool-1-thread-6释放了信号量---------当前信号量:1---等待信号量的线程数:01561275558695</span><br><span class=\"line\">pool-1-thread-8释放了信号量---------当前信号量:3---等待信号量的线程数:01561275558695</span><br><span class=\"line\">pool-1-thread-7释放了信号量---------当前信号量:2---等待信号量的线程数:01561275558695</span><br><span class=\"line\">pool-1-thread-10释放了信号量---------当前信号量:5---等待信号量的线程数:01561275558696</span><br><span class=\"line\">pool-1-thread-9释放了信号量---------当前信号量:5---等待信号量的线程数:01561275558696</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Exchanger\"><a href=\"#Exchanger\" class=\"headerlink\" title=\"Exchanger\"></a>Exchanger</h2><ul>\n<li>Exchanger作用：用于进行线程间的数据交<br>换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过<br>exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也<br>执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产<br>出来的数据传递给对方。<ul>\n<li>注意：如果两个线程有一个没有执行exchange()方法，则会一直等待，如果担心有特殊情况发<br>生，避免一直等待，可以使用exchange（V x，longtimeout，TimeUnit unit）设置最大等待时长</li>\n</ul>\n</li>\n</ul>\n<p> 示例代码：<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * @Description: TODO</span><br><span class=\"line\"> * @Auther: ThomasWu</span><br><span class=\"line\"> * @Date: 2019/6/23 15:53</span><br><span class=\"line\"> * @Email:1414924381@qq.com</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class ExchangerTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static final Exchanger&lt;String&gt; exchanger = new Exchanger&lt;String&gt;();</span><br><span class=\"line\">    private static ExecutorService threadPool = Executors.newFixedThreadPool(2);</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        threadPool.execute(new Runnable() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void run() &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    // A录入银行流水数据</span><br><span class=\"line\">                    String str = &quot;银行流水A&quot;;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + str);</span><br><span class=\"line\">                    str = exchanger.exchange(str);</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + str);</span><br><span class=\"line\">                &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        threadPool.execute(new Runnable() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void run() &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    String str = &quot;银行流水B&quot;;</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + str);</span><br><span class=\"line\">                    str = exchanger.exchange(str);</span><br><span class=\"line\">                    System.out.println(Thread.currentThread().getName() + str);</span><br><span class=\"line\"></span><br><span class=\"line\">                &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        threadPool.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"git常用命令","date":"2019-06-18T08:57:14.000Z","_content":"\n## git小记\n\n###  创建分支\n\n 1. git checkout -b develop_XXX origin/develop （以远程的develop分支为基准建立自己的本地分支）\n 2. git push origin develop_XXX（将本地develop_XXX分支提交到远程）\n \n### 删除分支\n \n 1.git branch -D branchName（删除本地分支）\n 2. git push origin --delete branchName （删除远程分支）\n\n<!--more-->\n\n### merge单个commit（branch_A to branch_B）\n先checkout到branch_A , 从branch_B merge单个commit到branch_A \ngit checkout branch_A \ngit cherry-pick commitId\n\n### git-更改本地和远程分支的名称\ngit branch -m old_branch new_branch # Rename branch locally \ngit push origin :old_branch # Delete the old branch \ngit push --set-upstream origin new_branch # Push the new branch, set local branch to track the new remote\n\n### 回退到指定版本\ngit reset --hard commitId\n强制提交到master分支\ngit push -f -u origin master\n\n\n### 本地项目推送到远程分支\ngit init：初始化本地仓库\ngit add ：添加到暂存区\ngit commit：将暂存区修改提交到本地仓库：\ngit remote add git@github.com.xxxxxx:与远程仓库建立连接\ngit checkout develop -b(创建本地分支)\ngit push origin develop:推送到指定远程分支(没有分支线)\n\n\n ","source":"_posts/git常用命令.md","raw":"---\ntitle: git常用命令\ndate: 2019-06-18 16:57:14\ncategories: git\ntags: 工具\n---\n\n## git小记\n\n###  创建分支\n\n 1. git checkout -b develop_XXX origin/develop （以远程的develop分支为基准建立自己的本地分支）\n 2. git push origin develop_XXX（将本地develop_XXX分支提交到远程）\n \n### 删除分支\n \n 1.git branch -D branchName（删除本地分支）\n 2. git push origin --delete branchName （删除远程分支）\n\n<!--more-->\n\n### merge单个commit（branch_A to branch_B）\n先checkout到branch_A , 从branch_B merge单个commit到branch_A \ngit checkout branch_A \ngit cherry-pick commitId\n\n### git-更改本地和远程分支的名称\ngit branch -m old_branch new_branch # Rename branch locally \ngit push origin :old_branch # Delete the old branch \ngit push --set-upstream origin new_branch # Push the new branch, set local branch to track the new remote\n\n### 回退到指定版本\ngit reset --hard commitId\n强制提交到master分支\ngit push -f -u origin master\n\n\n### 本地项目推送到远程分支\ngit init：初始化本地仓库\ngit add ：添加到暂存区\ngit commit：将暂存区修改提交到本地仓库：\ngit remote add git@github.com.xxxxxx:与远程仓库建立连接\ngit checkout develop -b(创建本地分支)\ngit push origin develop:推送到指定远程分支(没有分支线)\n\n\n ","slug":"git常用命令","published":1,"updated":"2019-07-02T11:21:32.660Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzjwwnk0028w4j9rxew0c13","content":"<h2 id=\"git小记\"><a href=\"#git小记\" class=\"headerlink\" title=\"git小记\"></a>git小记</h2><h3 id=\"创建分支\"><a href=\"#创建分支\" class=\"headerlink\" title=\"创建分支\"></a>创建分支</h3><ol>\n<li>git checkout -b develop_XXX origin/develop （以远程的develop分支为基准建立自己的本地分支）</li>\n<li>git push origin develop_XXX（将本地develop_XXX分支提交到远程）</li>\n</ol>\n<h3 id=\"删除分支\"><a href=\"#删除分支\" class=\"headerlink\" title=\"删除分支\"></a>删除分支</h3><p> 1.git branch -D branchName（删除本地分支）</p>\n<ol start=\"2\">\n<li>git push origin –delete branchName （删除远程分支）</li>\n</ol>\n<a id=\"more\"></a>\n\n<h3 id=\"merge单个commit（branch-A-to-branch-B）\"><a href=\"#merge单个commit（branch-A-to-branch-B）\" class=\"headerlink\" title=\"merge单个commit（branch_A to branch_B）\"></a>merge单个commit（branch_A to branch_B）</h3><p>先checkout到branch_A , 从branch_B merge单个commit到branch_A<br>git checkout branch_A<br>git cherry-pick commitId</p>\n<h3 id=\"git-更改本地和远程分支的名称\"><a href=\"#git-更改本地和远程分支的名称\" class=\"headerlink\" title=\"git-更改本地和远程分支的名称\"></a>git-更改本地和远程分支的名称</h3><p>git branch -m old_branch new_branch # Rename branch locally<br>git push origin :old_branch # Delete the old branch<br>git push –set-upstream origin new_branch # Push the new branch, set local branch to track the new remote</p>\n<h3 id=\"回退到指定版本\"><a href=\"#回退到指定版本\" class=\"headerlink\" title=\"回退到指定版本\"></a>回退到指定版本</h3><p>git reset –hard commitId<br>强制提交到master分支<br>git push -f -u origin master</p>\n<h3 id=\"本地项目推送到远程分支\"><a href=\"#本地项目推送到远程分支\" class=\"headerlink\" title=\"本地项目推送到远程分支\"></a>本地项目推送到远程分支</h3><p>git init：初始化本地仓库<br>git add ：添加到暂存区<br>git commit：将暂存区修改提交到本地仓库：<br>git remote add <a href=\"mailto:git@github.com.xxxxxx\" target=\"_blank\" rel=\"noopener\">git@github.com.xxxxxx</a>:与远程仓库建立连接<br>git checkout develop -b(创建本地分支)<br>git push origin develop:推送到指定远程分支(没有分支线)</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"git小记\"><a href=\"#git小记\" class=\"headerlink\" title=\"git小记\"></a>git小记</h2><h3 id=\"创建分支\"><a href=\"#创建分支\" class=\"headerlink\" title=\"创建分支\"></a>创建分支</h3><ol>\n<li>git checkout -b develop_XXX origin/develop （以远程的develop分支为基准建立自己的本地分支）</li>\n<li>git push origin develop_XXX（将本地develop_XXX分支提交到远程）</li>\n</ol>\n<h3 id=\"删除分支\"><a href=\"#删除分支\" class=\"headerlink\" title=\"删除分支\"></a>删除分支</h3><p> 1.git branch -D branchName（删除本地分支）</p>\n<ol start=\"2\">\n<li>git push origin –delete branchName （删除远程分支）</li>\n</ol>","more":"<h3 id=\"merge单个commit（branch-A-to-branch-B）\"><a href=\"#merge单个commit（branch-A-to-branch-B）\" class=\"headerlink\" title=\"merge单个commit（branch_A to branch_B）\"></a>merge单个commit（branch_A to branch_B）</h3><p>先checkout到branch_A , 从branch_B merge单个commit到branch_A<br>git checkout branch_A<br>git cherry-pick commitId</p>\n<h3 id=\"git-更改本地和远程分支的名称\"><a href=\"#git-更改本地和远程分支的名称\" class=\"headerlink\" title=\"git-更改本地和远程分支的名称\"></a>git-更改本地和远程分支的名称</h3><p>git branch -m old_branch new_branch # Rename branch locally<br>git push origin :old_branch # Delete the old branch<br>git push –set-upstream origin new_branch # Push the new branch, set local branch to track the new remote</p>\n<h3 id=\"回退到指定版本\"><a href=\"#回退到指定版本\" class=\"headerlink\" title=\"回退到指定版本\"></a>回退到指定版本</h3><p>git reset –hard commitId<br>强制提交到master分支<br>git push -f -u origin master</p>\n<h3 id=\"本地项目推送到远程分支\"><a href=\"#本地项目推送到远程分支\" class=\"headerlink\" title=\"本地项目推送到远程分支\"></a>本地项目推送到远程分支</h3><p>git init：初始化本地仓库<br>git add ：添加到暂存区<br>git commit：将暂存区修改提交到本地仓库：<br>git remote add <a href=\"mailto:git@github.com.xxxxxx\" target=\"_blank\" rel=\"noopener\">git@github.com.xxxxxx</a>:与远程仓库建立连接<br>git checkout develop -b(创建本地分支)<br>git push origin develop:推送到指定远程分支(没有分支线)</p>"},{"title":"java多线程之常见面试问题","date":"2019-06-18T08:55:46.000Z","_content":"\n多线程的常见问题\n\n1、多线程有什么用？\n\n一个可能在很多人看来很扯淡的一个问题：我会用多线程就好了，还管它有什么用？在我看来，这个回答更扯淡。所谓\"知其然知其所以然\"，\"会用\"只是\"知其然\"，\"为什么用\"才是\"知其所以然\"，只有达到\"知其然知其所以然\"的程度才可以说是把一个知识点运用自如。OK，下面说说我对这个问题的看法：\n\n（1）发挥多核CPU的优势\n\n随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的，4核、8核甚至16核的也都不少见，如果是单线程的程序，那么在双核CPU上就浪费了50%，在4核CPU上就浪费了75%。单核CPU上所谓的\"多线程\"那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程\"同时\"运行罢了。多核CPU上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的。\n\n（2）防止阻塞\n\n从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。\n\n（3）便于建模\n\n这是另外一个没有这么明显的优点了。假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务，任务B、任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。\n\n \n\n2、创建线程的方式\n\n比较常见的一个问题了，一般就是两种：\n\n（1）继承Thread类\n\n（2）实现Runnable接口\n\n至于哪个好，不用说肯定是后者好，因为实现接口的方式比继承类的方式更灵活，也能减少程序之间的耦合度，面向接口编程也是设计模式6大原则的核心。\n\n \n\n3、start()方法和run()方法的区别\n\n只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。如果只是调用run()方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码。\n\n \n\n4、Runnable接口和Callable接口的区别\n\n有点深的问题了，也看出一个Java程序员学习知识的广度。\n\nRunnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。\n\n这其实是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。\n\n \n\n5、CyclicBarrier和CountDownLatch的区别\n\n两个看上去有点像的类，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于：\n\n（1）CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行\n\n（2）CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务\n\n（3）CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了\n\n \n\n6、volatile关键字的作用\n\n一个非常重要的问题，是每个学习、应用多线程的Java程序员都必须掌握的。理解volatile关键字的作用的前提是要理解Java内存模型，这里就不讲Java内存模型了，可以参见第31点，volatile关键字的作用主要有两个：\n\n（1）多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据\n\n（2）代码底层执行不像我们看到的高级语言----Java程序这么简单，它的执行是Java代码-->字节码-->根据字节码执行对应的C/C++代码-->C/C++代码被编译成汇编语言-->和硬件电路交互，现实中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率\n\n从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。\n\n \n\n7、什么是线程安全\n\n又是一个理论的问题，各式各样的答案有很多，我给出一个个人认为解释地最好的：如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。\n\n这个问题有值得一提的地方，就是线程安全也是有几个级别的：\n\n（1）不可变\n\n像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用\n\n（2）绝对线程安全\n\n不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet\n\n（3）相对线程安全\n\n相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。\n\n（4）线程非安全\n\n这个就没什么好说的了，ArrayList、LinkedList、HashMap等都是线程非安全的类\n\n \n\n8、Java中如何获取到线程dump文件\n\n死循环、死锁、阻塞、页面打开慢等问题，打线程dump是最好的解决问题的途径。所谓线程dump也就是线程堆栈，获取到线程堆栈有两步：\n\n（1）获取到线程的pid，可以通过使用jps命令，在Linux环境下还可以使用ps -ef | grep java\n\n（2）打印线程堆栈，可以通过使用jstack pid命令，在Linux环境下还可以使用kill -3 pid\n\n另外提一点，Thread类提供了一个getStackTrace()方法也可以用于获取线程堆栈。这是一个实例方法，因此此方法是和具体线程实例绑定的，每次获取获取到的是具体某个线程当前运行的堆栈，\n\n \n\n9、一个线程如果出现了运行时异常会怎么样\n\n如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放\n\n \n\n10、如何在两个线程之间共享数据\n\n通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的\n\n \n\n11、sleep方法和wait方法有什么区别 \n\n这个问题常问，sleep方法和wait方法都可以用来放弃CPU一定的时间，不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器\n\n \n\n12、生产者消费者模型的作用是什么\n\n这个问题很理论，但是很重要：\n\n（1）通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用\n\n（2）解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约\n\n \n\n13、ThreadLocal有什么用\n\n简单说ThreadLocal就是一种以空间换时间的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了\n\n \n\n14、为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用\n\n这是JDK强制的，wait()方法和notify()/notifyAll()方法在调用前都必须先获得对象的锁\n\n \n\n15、wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别\n\nwait()方法和notify()/notifyAll()方法在放弃对象监视器的时候的区别在于：wait()方法立即释放对象监视器，notify()/notifyAll()方法则会等待线程剩余代码执行完毕才会放弃对象监视器。\n\n \n\n16、为什么要使用线程池\n\n避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。\n\n \n\n17、怎么检测一个线程是否持有对象监视器\n\n我也是在网上看到一道多线程面试题才知道有方法可以判断某个线程是否持有对象监视器：Thread类提供了一个holdsLock(Object obj)方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true，注意这是一个static方法，这意味着\"某条线程\"指的是当前线程。\n\n \n\n18、synchronized和ReentrantLock的区别\n\nsynchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：\n\n（1）ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁\n\n（2）ReentrantLock可以获取各种锁的信息\n\n（3）ReentrantLock可以灵活地实现多路通知\n\n另外，二者的锁机制其实也是不一样的。ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word，这点我不能确定。\n\n \n\n19、ConcurrentHashMap的并发度是什么\n\nConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据吗？\n\n \n\n20、ReadWriteLock是什么\n\n首先明确一下，不是说ReentrantLock不好，只是ReentrantLock某些时候有局限。如果使用ReentrantLock，可能本身是为了防止线程A在写数据、线程B在读数据造成的数据不一致，但这样，如果线程C在读数据、线程D也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。\n\n因为这个，才诞生了读写锁ReadWriteLock。ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。\n\n \n\n21、FutureTask是什么\n\n这个其实前面有提到过，FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。\n\n \n\n22、Linux环境下如何查找哪个线程使用CPU最长\n\n这是一个比较偏实践的问题，这种问题我觉得挺有意义的。可以这么做：\n\n（1）获取项目的pid，jps或者ps -ef | grep java，这个前面有讲过\n\n（2）top -H -p pid，顺序不能改变\n\n这样就可以打印出当前的项目，每条线程占用CPU时间的百分比。注意这里打出的是LWP，也就是操作系统原生线程的线程号，我笔记本山没有部署Linux环境下的Java工程，因此没有办法截图演示，网友朋友们如果公司是使用Linux环境部署项目的话，可以尝试一下。\n\n使用\"top -H -p pid\"+\"jps pid\"可以很容易地找到某条占用CPU高的线程的线程堆栈，从而定位占用CPU高的原因，一般是因为不当的代码操作导致了死循环。\n\n最后提一点，\"top -H -p pid\"打出来的LWP是十进制的，\"jps pid\"打出来的本地线程号是十六进制的，转换一下，就能定位到占用CPU高的线程的当前线程堆栈了。\n\n \n\n23、Java编程写一个会导致死锁的程序\n\n第一次看到这个题目，觉得这是一个非常好的问题。很多人都知道死锁是怎么一回事儿：线程A和线程B相互等待对方持有的锁导致程序无限死循环下去。当然也仅限于此了，问一下怎么写一个死锁的程序就不知道了，这种情况说白了就是不懂什么是死锁，懂一个理论就完事儿了，实践中碰到死锁的问题基本上是看不出来的。\n\n真正理解什么是死锁，这个问题其实不难，几个步骤：\n\n（1）两个线程里面分别持有两个Object对象：lock1和lock2。这两个lock作为同步代码块的锁；\n\n（2）线程1的run()方法中同步代码块先获取lock1的对象锁，Thread.sleep(xxx)，时间不需要太多，50毫秒差不多了，然后接着获取lock2的对象锁。这么做主要是为了防止线程1启动一下子就连续获得了lock1和lock2两个对象的对象锁\n\n（3）线程2的run)(方法中同步代码块先获取lock2的对象锁，接着获取lock1的对象锁，当然这时lock1的对象锁已经被线程1锁持有，线程2肯定是要等待线程1释放lock1的对象锁的\n\n这样，线程1\"睡觉\"睡完，线程2已经获取了lock2的对象锁了，线程1此时尝试获取lock2的对象锁，便被阻塞，此时一个死锁就形成了。代码就不写了，占的篇幅有点多，Java多线程7：死锁这篇文章里面有，就是上面步骤的代码实现。\n\n \n\n24、怎么唤醒一个阻塞的线程\n\n如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。\n\n \n\n25、不可变对象对多线程有什么帮助\n\n前面有提到过的一个问题，不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。\n\n \n\n26、什么是多线程的上下文切换\n\n多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。\n\n \n\n27、如果你提交任务时，线程池队列已满，这时会发生什么\n\n这里区分一下：\n\n    如果使用的是无界队列LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务\n    如果使用的是有界队列比如ArrayBlockingQueue，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，会根据maximumPoolSize的值增加线程数量，如果增加了线程数量还是处理不过来，ArrayBlockingQueue继续满，那么则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy\n\n \n\n28、Java中用到的线程调度算法是什么\n\n抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。\n\n \n\n29、Thread.sleep(0)的作用是什么\n\n这个问题和上面那个问题是相关的，我就连在一起了。由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。\n\n \n\n30、什么是自旋\n\n很多synchronized里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在synchronized的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。\n\n \n\n31、什么是Java内存模型\n\nJava内存模型定义了一种多线程访问Java内存的规范。Java内存模型要完整讲不是这里几句话能说清楚的，我简单总结一下Java内存模型的几部分内容：\n\n（1）Java内存模型将内存分为了主内存和工作内存。类的状态，也就是类之间共享的变量，是存储在主内存中的，每次Java线程用到这些主内存中的变量的时候，会读一次主内存中的变量，并让这些内存在自己的工作内存中有一份拷贝，运行自己线程代码的时候，用到这些变量，操作的都是自己工作内存中的那一份。在线程代码执行完毕之后，会将最新的值更新到主内存中去\n\n（2）定义了几个原子操作，用于操作主内存和工作内存中的变量\n\n（3）定义了volatile变量的使用规则\n\n（4）happens-before，即先行发生原则，定义了操作A必然先行发生于操作B的一些规则，比如在同一个线程内控制流前面的代码一定先行发生于控制流后面的代码、一个释放锁unlock的动作一定先行发生于后面对于同一个锁进行锁定lock的动作等等，只要符合这些规则，则不需要额外做同步措施，如果某段代码不符合所有的happens-before规则，则这段代码一定是线程非安全的\n\n \n\n32、什么是CAS\n\nCAS，全称为Compare and Swap，即比较-替换。假设有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false。当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功。\n\n \n\n33、什么是乐观锁和悲观锁\n\n（1）乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。\n\n（2）悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。\n\n \n\n34、什么是AQS\n\n简单说一下AQS，AQS全称为AbstractQueuedSychronizer，翻译过来应该是抽象队列同步器。\n\n如果说java.util.concurrent的基础是CAS的话，那么AQS就是整个Java并发包的核心了，ReentrantLock、CountDownLatch、Semaphore等等都用到了它。AQS实际上以双向队列的形式连接所有的Entry，比方说ReentrantLock，所有等待的线程都被放在一个Entry中并连成双向队列，前面一个线程使用ReentrantLock好了，则双向队列实际上的第一个Entry开始运行。\n\nAQS定义了对双向队列所有的操作，而只开放了tryLock和tryRelease方法给开发者使用，开发者可以根据自己的实现重写tryLock和tryRelease方法，以实现自己的并发功能。\n\n \n\n35、单例模式的线程安全性\n\n老生常谈的问题了，首先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建一次出来。单例模式有很多种的写法，我总结一下：\n\n（1）饿汉式单例模式的写法：线程安全\n\n（2）懒汉式单例模式的写法：非线程安全\n\n（3）双检锁单例模式的写法：线程安全\n\n \n\n36、Semaphore有什么作用\n\nSemaphore就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore有一个构造函数，可以传入一个int型整数n，表示某段代码最多只有n个线程可以访问，如果超出了n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果Semaphore构造函数中传入的int型整数n=1，相当于变成了一个synchronized了。\n\n \n\n37、Hashtable的size()方法中明明只有一条语句\"return count\"，为什么还要做同步？\n\n这是我之前的一个困惑，不知道大家有没有想过这个问题。某个方法中如果有多条语句，并且都在操作同一个类变量，那么在多线程环境下不加锁，势必会引发线程安全问题，这很好理解，但是size()方法明明只有一条语句，为什么还要加锁？\n\n关于这个问题，在慢慢地工作、学习中，有了理解，主要原因有两点：\n\n（1）同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程A在执行Hashtable的put方法添加数据，线程B则可以正常调用size()方法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size一定是不准确的。而给size()方法加了同步之后，意味着线程B调用size()方法只有在线程A调用put方法完毕之后才可以调用，这样就保证了线程安全性\n\n（2）CPU执行代码，执行的不是Java代码，这点很关键，一定得记住。Java代码最终是被翻译成机器码执行的，机器码才是真正可以和硬件电路交互的代码。即使你看到Java代码只有一行，甚至你看到Java代码编译之后生成的字节码也只有一行，也不意味着对于底层来说这句语句的操作只有一个。一句\"return count\"假设被翻译成了三句汇编语句执行，一句汇编语句和其机器码做对应，完全可能执行完第一句，线程就切换了。\n\n \n\n38、线程类的构造方法、静态块是被哪个线程调用的\n\n这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。\n\n如果说上面的说法让你感到困惑，那么我举个例子，假设Thread2中new了Thread1，main函数中new了Thread2，那么：\n\n（1）Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的\n\n（2）Thread1的构造方法、静态块是Thread2调用的，Thread1的run()方法是Thread1自己调用的\n\n \n\n39、同步方法和同步块，哪个是更好的选择\n\n同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：同步的范围越小越好。\n\n借着这一条，我额外提一点，虽说同步的范围越少越好，但是在Java虚拟机中还是存在着一种叫做锁粗化的优化方法，这种方法就是把同步范围变大。这是有用的，比方说StringBuffer，它是一个线程安全的类，自然最常用的append()方法是一个同步方法，我们写代码的时候会反复append字符串，这意味着要进行反复的加锁->解锁，这对性能不利，因为这意味着Java虚拟机在这条线程上要反复地在内核态和用户态之间进行切换，因此Java虚拟机会将多次append方法调用的代码进行一个锁粗化的操作，将多次的append的操作扩展到append方法的头尾，变成一个大的同步块，这样就减少了加锁-->解锁的次数，有效地提升了代码执行的效率。\n\n \n\n40、高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？\n\n这是我在并发编程网上看到的一个问题，把这个问题放在最后一个，希望每个人都能看到并且思考一下，因为这个问题非常好、非常实际、非常专业。关于这个问题，个人看法是：\n\n（1）高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换\n\n（2）并发不高、任务执行时间长的业务要区分开看：\n\n　　a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务\n\n　　b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换\n\n（3）并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。\n","source":"_posts/java多线程之常见面试问题.md","raw":"---\ntitle: java多线程之常见面试问题\ndate: 2019-06-18 16:55:46\ncategories: java多线程\ntags:\n---\n\n多线程的常见问题\n\n1、多线程有什么用？\n\n一个可能在很多人看来很扯淡的一个问题：我会用多线程就好了，还管它有什么用？在我看来，这个回答更扯淡。所谓\"知其然知其所以然\"，\"会用\"只是\"知其然\"，\"为什么用\"才是\"知其所以然\"，只有达到\"知其然知其所以然\"的程度才可以说是把一个知识点运用自如。OK，下面说说我对这个问题的看法：\n\n（1）发挥多核CPU的优势\n\n随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的，4核、8核甚至16核的也都不少见，如果是单线程的程序，那么在双核CPU上就浪费了50%，在4核CPU上就浪费了75%。单核CPU上所谓的\"多线程\"那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程\"同时\"运行罢了。多核CPU上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的。\n\n（2）防止阻塞\n\n从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。\n\n（3）便于建模\n\n这是另外一个没有这么明显的优点了。假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务，任务B、任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。\n\n \n\n2、创建线程的方式\n\n比较常见的一个问题了，一般就是两种：\n\n（1）继承Thread类\n\n（2）实现Runnable接口\n\n至于哪个好，不用说肯定是后者好，因为实现接口的方式比继承类的方式更灵活，也能减少程序之间的耦合度，面向接口编程也是设计模式6大原则的核心。\n\n \n\n3、start()方法和run()方法的区别\n\n只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。如果只是调用run()方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码。\n\n \n\n4、Runnable接口和Callable接口的区别\n\n有点深的问题了，也看出一个Java程序员学习知识的广度。\n\nRunnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。\n\n这其实是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。\n\n \n\n5、CyclicBarrier和CountDownLatch的区别\n\n两个看上去有点像的类，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于：\n\n（1）CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行\n\n（2）CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务\n\n（3）CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了\n\n \n\n6、volatile关键字的作用\n\n一个非常重要的问题，是每个学习、应用多线程的Java程序员都必须掌握的。理解volatile关键字的作用的前提是要理解Java内存模型，这里就不讲Java内存模型了，可以参见第31点，volatile关键字的作用主要有两个：\n\n（1）多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据\n\n（2）代码底层执行不像我们看到的高级语言----Java程序这么简单，它的执行是Java代码-->字节码-->根据字节码执行对应的C/C++代码-->C/C++代码被编译成汇编语言-->和硬件电路交互，现实中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率\n\n从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。\n\n \n\n7、什么是线程安全\n\n又是一个理论的问题，各式各样的答案有很多，我给出一个个人认为解释地最好的：如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。\n\n这个问题有值得一提的地方，就是线程安全也是有几个级别的：\n\n（1）不可变\n\n像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用\n\n（2）绝对线程安全\n\n不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet\n\n（3）相对线程安全\n\n相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。\n\n（4）线程非安全\n\n这个就没什么好说的了，ArrayList、LinkedList、HashMap等都是线程非安全的类\n\n \n\n8、Java中如何获取到线程dump文件\n\n死循环、死锁、阻塞、页面打开慢等问题，打线程dump是最好的解决问题的途径。所谓线程dump也就是线程堆栈，获取到线程堆栈有两步：\n\n（1）获取到线程的pid，可以通过使用jps命令，在Linux环境下还可以使用ps -ef | grep java\n\n（2）打印线程堆栈，可以通过使用jstack pid命令，在Linux环境下还可以使用kill -3 pid\n\n另外提一点，Thread类提供了一个getStackTrace()方法也可以用于获取线程堆栈。这是一个实例方法，因此此方法是和具体线程实例绑定的，每次获取获取到的是具体某个线程当前运行的堆栈，\n\n \n\n9、一个线程如果出现了运行时异常会怎么样\n\n如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放\n\n \n\n10、如何在两个线程之间共享数据\n\n通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的\n\n \n\n11、sleep方法和wait方法有什么区别 \n\n这个问题常问，sleep方法和wait方法都可以用来放弃CPU一定的时间，不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器\n\n \n\n12、生产者消费者模型的作用是什么\n\n这个问题很理论，但是很重要：\n\n（1）通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用\n\n（2）解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约\n\n \n\n13、ThreadLocal有什么用\n\n简单说ThreadLocal就是一种以空间换时间的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了\n\n \n\n14、为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用\n\n这是JDK强制的，wait()方法和notify()/notifyAll()方法在调用前都必须先获得对象的锁\n\n \n\n15、wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别\n\nwait()方法和notify()/notifyAll()方法在放弃对象监视器的时候的区别在于：wait()方法立即释放对象监视器，notify()/notifyAll()方法则会等待线程剩余代码执行完毕才会放弃对象监视器。\n\n \n\n16、为什么要使用线程池\n\n避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。\n\n \n\n17、怎么检测一个线程是否持有对象监视器\n\n我也是在网上看到一道多线程面试题才知道有方法可以判断某个线程是否持有对象监视器：Thread类提供了一个holdsLock(Object obj)方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true，注意这是一个static方法，这意味着\"某条线程\"指的是当前线程。\n\n \n\n18、synchronized和ReentrantLock的区别\n\nsynchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：\n\n（1）ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁\n\n（2）ReentrantLock可以获取各种锁的信息\n\n（3）ReentrantLock可以灵活地实现多路通知\n\n另外，二者的锁机制其实也是不一样的。ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word，这点我不能确定。\n\n \n\n19、ConcurrentHashMap的并发度是什么\n\nConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据吗？\n\n \n\n20、ReadWriteLock是什么\n\n首先明确一下，不是说ReentrantLock不好，只是ReentrantLock某些时候有局限。如果使用ReentrantLock，可能本身是为了防止线程A在写数据、线程B在读数据造成的数据不一致，但这样，如果线程C在读数据、线程D也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。\n\n因为这个，才诞生了读写锁ReadWriteLock。ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。\n\n \n\n21、FutureTask是什么\n\n这个其实前面有提到过，FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。\n\n \n\n22、Linux环境下如何查找哪个线程使用CPU最长\n\n这是一个比较偏实践的问题，这种问题我觉得挺有意义的。可以这么做：\n\n（1）获取项目的pid，jps或者ps -ef | grep java，这个前面有讲过\n\n（2）top -H -p pid，顺序不能改变\n\n这样就可以打印出当前的项目，每条线程占用CPU时间的百分比。注意这里打出的是LWP，也就是操作系统原生线程的线程号，我笔记本山没有部署Linux环境下的Java工程，因此没有办法截图演示，网友朋友们如果公司是使用Linux环境部署项目的话，可以尝试一下。\n\n使用\"top -H -p pid\"+\"jps pid\"可以很容易地找到某条占用CPU高的线程的线程堆栈，从而定位占用CPU高的原因，一般是因为不当的代码操作导致了死循环。\n\n最后提一点，\"top -H -p pid\"打出来的LWP是十进制的，\"jps pid\"打出来的本地线程号是十六进制的，转换一下，就能定位到占用CPU高的线程的当前线程堆栈了。\n\n \n\n23、Java编程写一个会导致死锁的程序\n\n第一次看到这个题目，觉得这是一个非常好的问题。很多人都知道死锁是怎么一回事儿：线程A和线程B相互等待对方持有的锁导致程序无限死循环下去。当然也仅限于此了，问一下怎么写一个死锁的程序就不知道了，这种情况说白了就是不懂什么是死锁，懂一个理论就完事儿了，实践中碰到死锁的问题基本上是看不出来的。\n\n真正理解什么是死锁，这个问题其实不难，几个步骤：\n\n（1）两个线程里面分别持有两个Object对象：lock1和lock2。这两个lock作为同步代码块的锁；\n\n（2）线程1的run()方法中同步代码块先获取lock1的对象锁，Thread.sleep(xxx)，时间不需要太多，50毫秒差不多了，然后接着获取lock2的对象锁。这么做主要是为了防止线程1启动一下子就连续获得了lock1和lock2两个对象的对象锁\n\n（3）线程2的run)(方法中同步代码块先获取lock2的对象锁，接着获取lock1的对象锁，当然这时lock1的对象锁已经被线程1锁持有，线程2肯定是要等待线程1释放lock1的对象锁的\n\n这样，线程1\"睡觉\"睡完，线程2已经获取了lock2的对象锁了，线程1此时尝试获取lock2的对象锁，便被阻塞，此时一个死锁就形成了。代码就不写了，占的篇幅有点多，Java多线程7：死锁这篇文章里面有，就是上面步骤的代码实现。\n\n \n\n24、怎么唤醒一个阻塞的线程\n\n如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。\n\n \n\n25、不可变对象对多线程有什么帮助\n\n前面有提到过的一个问题，不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。\n\n \n\n26、什么是多线程的上下文切换\n\n多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。\n\n \n\n27、如果你提交任务时，线程池队列已满，这时会发生什么\n\n这里区分一下：\n\n    如果使用的是无界队列LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务\n    如果使用的是有界队列比如ArrayBlockingQueue，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，会根据maximumPoolSize的值增加线程数量，如果增加了线程数量还是处理不过来，ArrayBlockingQueue继续满，那么则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy\n\n \n\n28、Java中用到的线程调度算法是什么\n\n抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。\n\n \n\n29、Thread.sleep(0)的作用是什么\n\n这个问题和上面那个问题是相关的，我就连在一起了。由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。\n\n \n\n30、什么是自旋\n\n很多synchronized里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在synchronized的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。\n\n \n\n31、什么是Java内存模型\n\nJava内存模型定义了一种多线程访问Java内存的规范。Java内存模型要完整讲不是这里几句话能说清楚的，我简单总结一下Java内存模型的几部分内容：\n\n（1）Java内存模型将内存分为了主内存和工作内存。类的状态，也就是类之间共享的变量，是存储在主内存中的，每次Java线程用到这些主内存中的变量的时候，会读一次主内存中的变量，并让这些内存在自己的工作内存中有一份拷贝，运行自己线程代码的时候，用到这些变量，操作的都是自己工作内存中的那一份。在线程代码执行完毕之后，会将最新的值更新到主内存中去\n\n（2）定义了几个原子操作，用于操作主内存和工作内存中的变量\n\n（3）定义了volatile变量的使用规则\n\n（4）happens-before，即先行发生原则，定义了操作A必然先行发生于操作B的一些规则，比如在同一个线程内控制流前面的代码一定先行发生于控制流后面的代码、一个释放锁unlock的动作一定先行发生于后面对于同一个锁进行锁定lock的动作等等，只要符合这些规则，则不需要额外做同步措施，如果某段代码不符合所有的happens-before规则，则这段代码一定是线程非安全的\n\n \n\n32、什么是CAS\n\nCAS，全称为Compare and Swap，即比较-替换。假设有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false。当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功。\n\n \n\n33、什么是乐观锁和悲观锁\n\n（1）乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。\n\n（2）悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。\n\n \n\n34、什么是AQS\n\n简单说一下AQS，AQS全称为AbstractQueuedSychronizer，翻译过来应该是抽象队列同步器。\n\n如果说java.util.concurrent的基础是CAS的话，那么AQS就是整个Java并发包的核心了，ReentrantLock、CountDownLatch、Semaphore等等都用到了它。AQS实际上以双向队列的形式连接所有的Entry，比方说ReentrantLock，所有等待的线程都被放在一个Entry中并连成双向队列，前面一个线程使用ReentrantLock好了，则双向队列实际上的第一个Entry开始运行。\n\nAQS定义了对双向队列所有的操作，而只开放了tryLock和tryRelease方法给开发者使用，开发者可以根据自己的实现重写tryLock和tryRelease方法，以实现自己的并发功能。\n\n \n\n35、单例模式的线程安全性\n\n老生常谈的问题了，首先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建一次出来。单例模式有很多种的写法，我总结一下：\n\n（1）饿汉式单例模式的写法：线程安全\n\n（2）懒汉式单例模式的写法：非线程安全\n\n（3）双检锁单例模式的写法：线程安全\n\n \n\n36、Semaphore有什么作用\n\nSemaphore就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore有一个构造函数，可以传入一个int型整数n，表示某段代码最多只有n个线程可以访问，如果超出了n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果Semaphore构造函数中传入的int型整数n=1，相当于变成了一个synchronized了。\n\n \n\n37、Hashtable的size()方法中明明只有一条语句\"return count\"，为什么还要做同步？\n\n这是我之前的一个困惑，不知道大家有没有想过这个问题。某个方法中如果有多条语句，并且都在操作同一个类变量，那么在多线程环境下不加锁，势必会引发线程安全问题，这很好理解，但是size()方法明明只有一条语句，为什么还要加锁？\n\n关于这个问题，在慢慢地工作、学习中，有了理解，主要原因有两点：\n\n（1）同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程A在执行Hashtable的put方法添加数据，线程B则可以正常调用size()方法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size一定是不准确的。而给size()方法加了同步之后，意味着线程B调用size()方法只有在线程A调用put方法完毕之后才可以调用，这样就保证了线程安全性\n\n（2）CPU执行代码，执行的不是Java代码，这点很关键，一定得记住。Java代码最终是被翻译成机器码执行的，机器码才是真正可以和硬件电路交互的代码。即使你看到Java代码只有一行，甚至你看到Java代码编译之后生成的字节码也只有一行，也不意味着对于底层来说这句语句的操作只有一个。一句\"return count\"假设被翻译成了三句汇编语句执行，一句汇编语句和其机器码做对应，完全可能执行完第一句，线程就切换了。\n\n \n\n38、线程类的构造方法、静态块是被哪个线程调用的\n\n这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。\n\n如果说上面的说法让你感到困惑，那么我举个例子，假设Thread2中new了Thread1，main函数中new了Thread2，那么：\n\n（1）Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的\n\n（2）Thread1的构造方法、静态块是Thread2调用的，Thread1的run()方法是Thread1自己调用的\n\n \n\n39、同步方法和同步块，哪个是更好的选择\n\n同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：同步的范围越小越好。\n\n借着这一条，我额外提一点，虽说同步的范围越少越好，但是在Java虚拟机中还是存在着一种叫做锁粗化的优化方法，这种方法就是把同步范围变大。这是有用的，比方说StringBuffer，它是一个线程安全的类，自然最常用的append()方法是一个同步方法，我们写代码的时候会反复append字符串，这意味着要进行反复的加锁->解锁，这对性能不利，因为这意味着Java虚拟机在这条线程上要反复地在内核态和用户态之间进行切换，因此Java虚拟机会将多次append方法调用的代码进行一个锁粗化的操作，将多次的append的操作扩展到append方法的头尾，变成一个大的同步块，这样就减少了加锁-->解锁的次数，有效地提升了代码执行的效率。\n\n \n\n40、高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？\n\n这是我在并发编程网上看到的一个问题，把这个问题放在最后一个，希望每个人都能看到并且思考一下，因为这个问题非常好、非常实际、非常专业。关于这个问题，个人看法是：\n\n（1）高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换\n\n（2）并发不高、任务执行时间长的业务要区分开看：\n\n　　a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务\n\n　　b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换\n\n（3）并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。\n","slug":"java多线程之常见面试问题","published":1,"updated":"2019-07-09T08:24:17.411Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjyzjwwpa002fw4j9makljfbp","content":"<p>多线程的常见问题</p>\n<p>1、多线程有什么用？</p>\n<p>一个可能在很多人看来很扯淡的一个问题：我会用多线程就好了，还管它有什么用？在我看来，这个回答更扯淡。所谓”知其然知其所以然”，”会用”只是”知其然”，”为什么用”才是”知其所以然”，只有达到”知其然知其所以然”的程度才可以说是把一个知识点运用自如。OK，下面说说我对这个问题的看法：</p>\n<p>（1）发挥多核CPU的优势</p>\n<p>随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的，4核、8核甚至16核的也都不少见，如果是单线程的程序，那么在双核CPU上就浪费了50%，在4核CPU上就浪费了75%。单核CPU上所谓的”多线程”那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程”同时”运行罢了。多核CPU上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的。</p>\n<p>（2）防止阻塞</p>\n<p>从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。</p>\n<p>（3）便于建模</p>\n<p>这是另外一个没有这么明显的优点了。假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务，任务B、任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。</p>\n<p>2、创建线程的方式</p>\n<p>比较常见的一个问题了，一般就是两种：</p>\n<p>（1）继承Thread类</p>\n<p>（2）实现Runnable接口</p>\n<p>至于哪个好，不用说肯定是后者好，因为实现接口的方式比继承类的方式更灵活，也能减少程序之间的耦合度，面向接口编程也是设计模式6大原则的核心。</p>\n<p>3、start()方法和run()方法的区别</p>\n<p>只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。如果只是调用run()方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码。</p>\n<p>4、Runnable接口和Callable接口的区别</p>\n<p>有点深的问题了，也看出一个Java程序员学习知识的广度。</p>\n<p>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</p>\n<p>这其实是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。</p>\n<p>5、CyclicBarrier和CountDownLatch的区别</p>\n<p>两个看上去有点像的类，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于：</p>\n<p>（1）CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行</p>\n<p>（2）CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务</p>\n<p>（3）CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了</p>\n<p>6、volatile关键字的作用</p>\n<p>一个非常重要的问题，是每个学习、应用多线程的Java程序员都必须掌握的。理解volatile关键字的作用的前提是要理解Java内存模型，这里就不讲Java内存模型了，可以参见第31点，volatile关键字的作用主要有两个：</p>\n<p>（1）多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据</p>\n<p>（2）代码底层执行不像我们看到的高级语言—-Java程序这么简单，它的执行是Java代码–&gt;字节码–&gt;根据字节码执行对应的C/C++代码–&gt;C/C++代码被编译成汇编语言–&gt;和硬件电路交互，现实中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率</p>\n<p>从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。</p>\n<p>7、什么是线程安全</p>\n<p>又是一个理论的问题，各式各样的答案有很多，我给出一个个人认为解释地最好的：如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。</p>\n<p>这个问题有值得一提的地方，就是线程安全也是有几个级别的：</p>\n<p>（1）不可变</p>\n<p>像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用</p>\n<p>（2）绝对线程安全</p>\n<p>不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet</p>\n<p>（3）相对线程安全</p>\n<p>相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。</p>\n<p>（4）线程非安全</p>\n<p>这个就没什么好说的了，ArrayList、LinkedList、HashMap等都是线程非安全的类</p>\n<p>8、Java中如何获取到线程dump文件</p>\n<p>死循环、死锁、阻塞、页面打开慢等问题，打线程dump是最好的解决问题的途径。所谓线程dump也就是线程堆栈，获取到线程堆栈有两步：</p>\n<p>（1）获取到线程的pid，可以通过使用jps命令，在Linux环境下还可以使用ps -ef | grep java</p>\n<p>（2）打印线程堆栈，可以通过使用jstack pid命令，在Linux环境下还可以使用kill -3 pid</p>\n<p>另外提一点，Thread类提供了一个getStackTrace()方法也可以用于获取线程堆栈。这是一个实例方法，因此此方法是和具体线程实例绑定的，每次获取获取到的是具体某个线程当前运行的堆栈，</p>\n<p>9、一个线程如果出现了运行时异常会怎么样</p>\n<p>如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放</p>\n<p>10、如何在两个线程之间共享数据</p>\n<p>通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的</p>\n<p>11、sleep方法和wait方法有什么区别 </p>\n<p>这个问题常问，sleep方法和wait方法都可以用来放弃CPU一定的时间，不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器</p>\n<p>12、生产者消费者模型的作用是什么</p>\n<p>这个问题很理论，但是很重要：</p>\n<p>（1）通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用</p>\n<p>（2）解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约</p>\n<p>13、ThreadLocal有什么用</p>\n<p>简单说ThreadLocal就是一种以空间换时间的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了</p>\n<p>14、为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用</p>\n<p>这是JDK强制的，wait()方法和notify()/notifyAll()方法在调用前都必须先获得对象的锁</p>\n<p>15、wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别</p>\n<p>wait()方法和notify()/notifyAll()方法在放弃对象监视器的时候的区别在于：wait()方法立即释放对象监视器，notify()/notifyAll()方法则会等待线程剩余代码执行完毕才会放弃对象监视器。</p>\n<p>16、为什么要使用线程池</p>\n<p>避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。</p>\n<p>17、怎么检测一个线程是否持有对象监视器</p>\n<p>我也是在网上看到一道多线程面试题才知道有方法可以判断某个线程是否持有对象监视器：Thread类提供了一个holdsLock(Object obj)方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true，注意这是一个static方法，这意味着”某条线程”指的是当前线程。</p>\n<p>18、synchronized和ReentrantLock的区别</p>\n<p>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：</p>\n<p>（1）ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁</p>\n<p>（2）ReentrantLock可以获取各种锁的信息</p>\n<p>（3）ReentrantLock可以灵活地实现多路通知</p>\n<p>另外，二者的锁机制其实也是不一样的。ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word，这点我不能确定。</p>\n<p>19、ConcurrentHashMap的并发度是什么</p>\n<p>ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据吗？</p>\n<p>20、ReadWriteLock是什么</p>\n<p>首先明确一下，不是说ReentrantLock不好，只是ReentrantLock某些时候有局限。如果使用ReentrantLock，可能本身是为了防止线程A在写数据、线程B在读数据造成的数据不一致，但这样，如果线程C在读数据、线程D也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。</p>\n<p>因为这个，才诞生了读写锁ReadWriteLock。ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。</p>\n<p>21、FutureTask是什么</p>\n<p>这个其实前面有提到过，FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。</p>\n<p>22、Linux环境下如何查找哪个线程使用CPU最长</p>\n<p>这是一个比较偏实践的问题，这种问题我觉得挺有意义的。可以这么做：</p>\n<p>（1）获取项目的pid，jps或者ps -ef | grep java，这个前面有讲过</p>\n<p>（2）top -H -p pid，顺序不能改变</p>\n<p>这样就可以打印出当前的项目，每条线程占用CPU时间的百分比。注意这里打出的是LWP，也就是操作系统原生线程的线程号，我笔记本山没有部署Linux环境下的Java工程，因此没有办法截图演示，网友朋友们如果公司是使用Linux环境部署项目的话，可以尝试一下。</p>\n<p>使用”top -H -p pid”+”jps pid”可以很容易地找到某条占用CPU高的线程的线程堆栈，从而定位占用CPU高的原因，一般是因为不当的代码操作导致了死循环。</p>\n<p>最后提一点，”top -H -p pid”打出来的LWP是十进制的，”jps pid”打出来的本地线程号是十六进制的，转换一下，就能定位到占用CPU高的线程的当前线程堆栈了。</p>\n<p>23、Java编程写一个会导致死锁的程序</p>\n<p>第一次看到这个题目，觉得这是一个非常好的问题。很多人都知道死锁是怎么一回事儿：线程A和线程B相互等待对方持有的锁导致程序无限死循环下去。当然也仅限于此了，问一下怎么写一个死锁的程序就不知道了，这种情况说白了就是不懂什么是死锁，懂一个理论就完事儿了，实践中碰到死锁的问题基本上是看不出来的。</p>\n<p>真正理解什么是死锁，这个问题其实不难，几个步骤：</p>\n<p>（1）两个线程里面分别持有两个Object对象：lock1和lock2。这两个lock作为同步代码块的锁；</p>\n<p>（2）线程1的run()方法中同步代码块先获取lock1的对象锁，Thread.sleep(xxx)，时间不需要太多，50毫秒差不多了，然后接着获取lock2的对象锁。这么做主要是为了防止线程1启动一下子就连续获得了lock1和lock2两个对象的对象锁</p>\n<p>（3）线程2的run)(方法中同步代码块先获取lock2的对象锁，接着获取lock1的对象锁，当然这时lock1的对象锁已经被线程1锁持有，线程2肯定是要等待线程1释放lock1的对象锁的</p>\n<p>这样，线程1”睡觉”睡完，线程2已经获取了lock2的对象锁了，线程1此时尝试获取lock2的对象锁，便被阻塞，此时一个死锁就形成了。代码就不写了，占的篇幅有点多，Java多线程7：死锁这篇文章里面有，就是上面步骤的代码实现。</p>\n<p>24、怎么唤醒一个阻塞的线程</p>\n<p>如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。</p>\n<p>25、不可变对象对多线程有什么帮助</p>\n<p>前面有提到过的一个问题，不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。</p>\n<p>26、什么是多线程的上下文切换</p>\n<p>多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。</p>\n<p>27、如果你提交任务时，线程池队列已满，这时会发生什么</p>\n<p>这里区分一下：</p>\n<pre><code>如果使用的是无界队列LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务\n如果使用的是有界队列比如ArrayBlockingQueue，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，会根据maximumPoolSize的值增加线程数量，如果增加了线程数量还是处理不过来，ArrayBlockingQueue继续满，那么则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy</code></pre><p>28、Java中用到的线程调度算法是什么</p>\n<p>抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。</p>\n<p>29、Thread.sleep(0)的作用是什么</p>\n<p>这个问题和上面那个问题是相关的，我就连在一起了。由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。</p>\n<p>30、什么是自旋</p>\n<p>很多synchronized里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在synchronized的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</p>\n<p>31、什么是Java内存模型</p>\n<p>Java内存模型定义了一种多线程访问Java内存的规范。Java内存模型要完整讲不是这里几句话能说清楚的，我简单总结一下Java内存模型的几部分内容：</p>\n<p>（1）Java内存模型将内存分为了主内存和工作内存。类的状态，也就是类之间共享的变量，是存储在主内存中的，每次Java线程用到这些主内存中的变量的时候，会读一次主内存中的变量，并让这些内存在自己的工作内存中有一份拷贝，运行自己线程代码的时候，用到这些变量，操作的都是自己工作内存中的那一份。在线程代码执行完毕之后，会将最新的值更新到主内存中去</p>\n<p>（2）定义了几个原子操作，用于操作主内存和工作内存中的变量</p>\n<p>（3）定义了volatile变量的使用规则</p>\n<p>（4）happens-before，即先行发生原则，定义了操作A必然先行发生于操作B的一些规则，比如在同一个线程内控制流前面的代码一定先行发生于控制流后面的代码、一个释放锁unlock的动作一定先行发生于后面对于同一个锁进行锁定lock的动作等等，只要符合这些规则，则不需要额外做同步措施，如果某段代码不符合所有的happens-before规则，则这段代码一定是线程非安全的</p>\n<p>32、什么是CAS</p>\n<p>CAS，全称为Compare and Swap，即比较-替换。假设有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false。当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功。</p>\n<p>33、什么是乐观锁和悲观锁</p>\n<p>（1）乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。</p>\n<p>（2）悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。</p>\n<p>34、什么是AQS</p>\n<p>简单说一下AQS，AQS全称为AbstractQueuedSychronizer，翻译过来应该是抽象队列同步器。</p>\n<p>如果说java.util.concurrent的基础是CAS的话，那么AQS就是整个Java并发包的核心了，ReentrantLock、CountDownLatch、Semaphore等等都用到了它。AQS实际上以双向队列的形式连接所有的Entry，比方说ReentrantLock，所有等待的线程都被放在一个Entry中并连成双向队列，前面一个线程使用ReentrantLock好了，则双向队列实际上的第一个Entry开始运行。</p>\n<p>AQS定义了对双向队列所有的操作，而只开放了tryLock和tryRelease方法给开发者使用，开发者可以根据自己的实现重写tryLock和tryRelease方法，以实现自己的并发功能。</p>\n<p>35、单例模式的线程安全性</p>\n<p>老生常谈的问题了，首先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建一次出来。单例模式有很多种的写法，我总结一下：</p>\n<p>（1）饿汉式单例模式的写法：线程安全</p>\n<p>（2）懒汉式单例模式的写法：非线程安全</p>\n<p>（3）双检锁单例模式的写法：线程安全</p>\n<p>36、Semaphore有什么作用</p>\n<p>Semaphore就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore有一个构造函数，可以传入一个int型整数n，表示某段代码最多只有n个线程可以访问，如果超出了n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果Semaphore构造函数中传入的int型整数n=1，相当于变成了一个synchronized了。</p>\n<p>37、Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步？</p>\n<p>这是我之前的一个困惑，不知道大家有没有想过这个问题。某个方法中如果有多条语句，并且都在操作同一个类变量，那么在多线程环境下不加锁，势必会引发线程安全问题，这很好理解，但是size()方法明明只有一条语句，为什么还要加锁？</p>\n<p>关于这个问题，在慢慢地工作、学习中，有了理解，主要原因有两点：</p>\n<p>（1）同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程A在执行Hashtable的put方法添加数据，线程B则可以正常调用size()方法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size一定是不准确的。而给size()方法加了同步之后，意味着线程B调用size()方法只有在线程A调用put方法完毕之后才可以调用，这样就保证了线程安全性</p>\n<p>（2）CPU执行代码，执行的不是Java代码，这点很关键，一定得记住。Java代码最终是被翻译成机器码执行的，机器码才是真正可以和硬件电路交互的代码。即使你看到Java代码只有一行，甚至你看到Java代码编译之后生成的字节码也只有一行，也不意味着对于底层来说这句语句的操作只有一个。一句”return count”假设被翻译成了三句汇编语句执行，一句汇编语句和其机器码做对应，完全可能执行完第一句，线程就切换了。</p>\n<p>38、线程类的构造方法、静态块是被哪个线程调用的</p>\n<p>这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。</p>\n<p>如果说上面的说法让你感到困惑，那么我举个例子，假设Thread2中new了Thread1，main函数中new了Thread2，那么：</p>\n<p>（1）Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的</p>\n<p>（2）Thread1的构造方法、静态块是Thread2调用的，Thread1的run()方法是Thread1自己调用的</p>\n<p>39、同步方法和同步块，哪个是更好的选择</p>\n<p>同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：同步的范围越小越好。</p>\n<p>借着这一条，我额外提一点，虽说同步的范围越少越好，但是在Java虚拟机中还是存在着一种叫做锁粗化的优化方法，这种方法就是把同步范围变大。这是有用的，比方说StringBuffer，它是一个线程安全的类，自然最常用的append()方法是一个同步方法，我们写代码的时候会反复append字符串，这意味着要进行反复的加锁-&gt;解锁，这对性能不利，因为这意味着Java虚拟机在这条线程上要反复地在内核态和用户态之间进行切换，因此Java虚拟机会将多次append方法调用的代码进行一个锁粗化的操作，将多次的append的操作扩展到append方法的头尾，变成一个大的同步块，这样就减少了加锁–&gt;解锁的次数，有效地提升了代码执行的效率。</p>\n<p>40、高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？</p>\n<p>这是我在并发编程网上看到的一个问题，把这个问题放在最后一个，希望每个人都能看到并且思考一下，因为这个问题非常好、非常实际、非常专业。关于这个问题，个人看法是：</p>\n<p>（1）高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换</p>\n<p>（2）并发不高、任务执行时间长的业务要区分开看：</p>\n<p>　　a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务</p>\n<p>　　b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换</p>\n<p>（3）并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>多线程的常见问题</p>\n<p>1、多线程有什么用？</p>\n<p>一个可能在很多人看来很扯淡的一个问题：我会用多线程就好了，还管它有什么用？在我看来，这个回答更扯淡。所谓”知其然知其所以然”，”会用”只是”知其然”，”为什么用”才是”知其所以然”，只有达到”知其然知其所以然”的程度才可以说是把一个知识点运用自如。OK，下面说说我对这个问题的看法：</p>\n<p>（1）发挥多核CPU的优势</p>\n<p>随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的，4核、8核甚至16核的也都不少见，如果是单线程的程序，那么在双核CPU上就浪费了50%，在4核CPU上就浪费了75%。单核CPU上所谓的”多线程”那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程”同时”运行罢了。多核CPU上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的。</p>\n<p>（2）防止阻塞</p>\n<p>从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。</p>\n<p>（3）便于建模</p>\n<p>这是另外一个没有这么明显的优点了。假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务，任务B、任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。</p>\n<p>2、创建线程的方式</p>\n<p>比较常见的一个问题了，一般就是两种：</p>\n<p>（1）继承Thread类</p>\n<p>（2）实现Runnable接口</p>\n<p>至于哪个好，不用说肯定是后者好，因为实现接口的方式比继承类的方式更灵活，也能减少程序之间的耦合度，面向接口编程也是设计模式6大原则的核心。</p>\n<p>3、start()方法和run()方法的区别</p>\n<p>只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。如果只是调用run()方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码。</p>\n<p>4、Runnable接口和Callable接口的区别</p>\n<p>有点深的问题了，也看出一个Java程序员学习知识的广度。</p>\n<p>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</p>\n<p>这其实是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。</p>\n<p>5、CyclicBarrier和CountDownLatch的区别</p>\n<p>两个看上去有点像的类，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于：</p>\n<p>（1）CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行</p>\n<p>（2）CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务</p>\n<p>（3）CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了</p>\n<p>6、volatile关键字的作用</p>\n<p>一个非常重要的问题，是每个学习、应用多线程的Java程序员都必须掌握的。理解volatile关键字的作用的前提是要理解Java内存模型，这里就不讲Java内存模型了，可以参见第31点，volatile关键字的作用主要有两个：</p>\n<p>（1）多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据</p>\n<p>（2）代码底层执行不像我们看到的高级语言—-Java程序这么简单，它的执行是Java代码–&gt;字节码–&gt;根据字节码执行对应的C/C++代码–&gt;C/C++代码被编译成汇编语言–&gt;和硬件电路交互，现实中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率</p>\n<p>从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。</p>\n<p>7、什么是线程安全</p>\n<p>又是一个理论的问题，各式各样的答案有很多，我给出一个个人认为解释地最好的：如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。</p>\n<p>这个问题有值得一提的地方，就是线程安全也是有几个级别的：</p>\n<p>（1）不可变</p>\n<p>像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用</p>\n<p>（2）绝对线程安全</p>\n<p>不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet</p>\n<p>（3）相对线程安全</p>\n<p>相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。</p>\n<p>（4）线程非安全</p>\n<p>这个就没什么好说的了，ArrayList、LinkedList、HashMap等都是线程非安全的类</p>\n<p>8、Java中如何获取到线程dump文件</p>\n<p>死循环、死锁、阻塞、页面打开慢等问题，打线程dump是最好的解决问题的途径。所谓线程dump也就是线程堆栈，获取到线程堆栈有两步：</p>\n<p>（1）获取到线程的pid，可以通过使用jps命令，在Linux环境下还可以使用ps -ef | grep java</p>\n<p>（2）打印线程堆栈，可以通过使用jstack pid命令，在Linux环境下还可以使用kill -3 pid</p>\n<p>另外提一点，Thread类提供了一个getStackTrace()方法也可以用于获取线程堆栈。这是一个实例方法，因此此方法是和具体线程实例绑定的，每次获取获取到的是具体某个线程当前运行的堆栈，</p>\n<p>9、一个线程如果出现了运行时异常会怎么样</p>\n<p>如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放</p>\n<p>10、如何在两个线程之间共享数据</p>\n<p>通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的</p>\n<p>11、sleep方法和wait方法有什么区别 </p>\n<p>这个问题常问，sleep方法和wait方法都可以用来放弃CPU一定的时间，不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器</p>\n<p>12、生产者消费者模型的作用是什么</p>\n<p>这个问题很理论，但是很重要：</p>\n<p>（1）通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用</p>\n<p>（2）解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约</p>\n<p>13、ThreadLocal有什么用</p>\n<p>简单说ThreadLocal就是一种以空间换时间的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了</p>\n<p>14、为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用</p>\n<p>这是JDK强制的，wait()方法和notify()/notifyAll()方法在调用前都必须先获得对象的锁</p>\n<p>15、wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别</p>\n<p>wait()方法和notify()/notifyAll()方法在放弃对象监视器的时候的区别在于：wait()方法立即释放对象监视器，notify()/notifyAll()方法则会等待线程剩余代码执行完毕才会放弃对象监视器。</p>\n<p>16、为什么要使用线程池</p>\n<p>避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。</p>\n<p>17、怎么检测一个线程是否持有对象监视器</p>\n<p>我也是在网上看到一道多线程面试题才知道有方法可以判断某个线程是否持有对象监视器：Thread类提供了一个holdsLock(Object obj)方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true，注意这是一个static方法，这意味着”某条线程”指的是当前线程。</p>\n<p>18、synchronized和ReentrantLock的区别</p>\n<p>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：</p>\n<p>（1）ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁</p>\n<p>（2）ReentrantLock可以获取各种锁的信息</p>\n<p>（3）ReentrantLock可以灵活地实现多路通知</p>\n<p>另外，二者的锁机制其实也是不一样的。ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word，这点我不能确定。</p>\n<p>19、ConcurrentHashMap的并发度是什么</p>\n<p>ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据吗？</p>\n<p>20、ReadWriteLock是什么</p>\n<p>首先明确一下，不是说ReentrantLock不好，只是ReentrantLock某些时候有局限。如果使用ReentrantLock，可能本身是为了防止线程A在写数据、线程B在读数据造成的数据不一致，但这样，如果线程C在读数据、线程D也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。</p>\n<p>因为这个，才诞生了读写锁ReadWriteLock。ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。</p>\n<p>21、FutureTask是什么</p>\n<p>这个其实前面有提到过，FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。</p>\n<p>22、Linux环境下如何查找哪个线程使用CPU最长</p>\n<p>这是一个比较偏实践的问题，这种问题我觉得挺有意义的。可以这么做：</p>\n<p>（1）获取项目的pid，jps或者ps -ef | grep java，这个前面有讲过</p>\n<p>（2）top -H -p pid，顺序不能改变</p>\n<p>这样就可以打印出当前的项目，每条线程占用CPU时间的百分比。注意这里打出的是LWP，也就是操作系统原生线程的线程号，我笔记本山没有部署Linux环境下的Java工程，因此没有办法截图演示，网友朋友们如果公司是使用Linux环境部署项目的话，可以尝试一下。</p>\n<p>使用”top -H -p pid”+”jps pid”可以很容易地找到某条占用CPU高的线程的线程堆栈，从而定位占用CPU高的原因，一般是因为不当的代码操作导致了死循环。</p>\n<p>最后提一点，”top -H -p pid”打出来的LWP是十进制的，”jps pid”打出来的本地线程号是十六进制的，转换一下，就能定位到占用CPU高的线程的当前线程堆栈了。</p>\n<p>23、Java编程写一个会导致死锁的程序</p>\n<p>第一次看到这个题目，觉得这是一个非常好的问题。很多人都知道死锁是怎么一回事儿：线程A和线程B相互等待对方持有的锁导致程序无限死循环下去。当然也仅限于此了，问一下怎么写一个死锁的程序就不知道了，这种情况说白了就是不懂什么是死锁，懂一个理论就完事儿了，实践中碰到死锁的问题基本上是看不出来的。</p>\n<p>真正理解什么是死锁，这个问题其实不难，几个步骤：</p>\n<p>（1）两个线程里面分别持有两个Object对象：lock1和lock2。这两个lock作为同步代码块的锁；</p>\n<p>（2）线程1的run()方法中同步代码块先获取lock1的对象锁，Thread.sleep(xxx)，时间不需要太多，50毫秒差不多了，然后接着获取lock2的对象锁。这么做主要是为了防止线程1启动一下子就连续获得了lock1和lock2两个对象的对象锁</p>\n<p>（3）线程2的run)(方法中同步代码块先获取lock2的对象锁，接着获取lock1的对象锁，当然这时lock1的对象锁已经被线程1锁持有，线程2肯定是要等待线程1释放lock1的对象锁的</p>\n<p>这样，线程1”睡觉”睡完，线程2已经获取了lock2的对象锁了，线程1此时尝试获取lock2的对象锁，便被阻塞，此时一个死锁就形成了。代码就不写了，占的篇幅有点多，Java多线程7：死锁这篇文章里面有，就是上面步骤的代码实现。</p>\n<p>24、怎么唤醒一个阻塞的线程</p>\n<p>如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。</p>\n<p>25、不可变对象对多线程有什么帮助</p>\n<p>前面有提到过的一个问题，不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。</p>\n<p>26、什么是多线程的上下文切换</p>\n<p>多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。</p>\n<p>27、如果你提交任务时，线程池队列已满，这时会发生什么</p>\n<p>这里区分一下：</p>\n<pre><code>如果使用的是无界队列LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务\n如果使用的是有界队列比如ArrayBlockingQueue，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，会根据maximumPoolSize的值增加线程数量，如果增加了线程数量还是处理不过来，ArrayBlockingQueue继续满，那么则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy</code></pre><p>28、Java中用到的线程调度算法是什么</p>\n<p>抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。</p>\n<p>29、Thread.sleep(0)的作用是什么</p>\n<p>这个问题和上面那个问题是相关的，我就连在一起了。由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。</p>\n<p>30、什么是自旋</p>\n<p>很多synchronized里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在synchronized的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</p>\n<p>31、什么是Java内存模型</p>\n<p>Java内存模型定义了一种多线程访问Java内存的规范。Java内存模型要完整讲不是这里几句话能说清楚的，我简单总结一下Java内存模型的几部分内容：</p>\n<p>（1）Java内存模型将内存分为了主内存和工作内存。类的状态，也就是类之间共享的变量，是存储在主内存中的，每次Java线程用到这些主内存中的变量的时候，会读一次主内存中的变量，并让这些内存在自己的工作内存中有一份拷贝，运行自己线程代码的时候，用到这些变量，操作的都是自己工作内存中的那一份。在线程代码执行完毕之后，会将最新的值更新到主内存中去</p>\n<p>（2）定义了几个原子操作，用于操作主内存和工作内存中的变量</p>\n<p>（3）定义了volatile变量的使用规则</p>\n<p>（4）happens-before，即先行发生原则，定义了操作A必然先行发生于操作B的一些规则，比如在同一个线程内控制流前面的代码一定先行发生于控制流后面的代码、一个释放锁unlock的动作一定先行发生于后面对于同一个锁进行锁定lock的动作等等，只要符合这些规则，则不需要额外做同步措施，如果某段代码不符合所有的happens-before规则，则这段代码一定是线程非安全的</p>\n<p>32、什么是CAS</p>\n<p>CAS，全称为Compare and Swap，即比较-替换。假设有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false。当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功。</p>\n<p>33、什么是乐观锁和悲观锁</p>\n<p>（1）乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。</p>\n<p>（2）悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。</p>\n<p>34、什么是AQS</p>\n<p>简单说一下AQS，AQS全称为AbstractQueuedSychronizer，翻译过来应该是抽象队列同步器。</p>\n<p>如果说java.util.concurrent的基础是CAS的话，那么AQS就是整个Java并发包的核心了，ReentrantLock、CountDownLatch、Semaphore等等都用到了它。AQS实际上以双向队列的形式连接所有的Entry，比方说ReentrantLock，所有等待的线程都被放在一个Entry中并连成双向队列，前面一个线程使用ReentrantLock好了，则双向队列实际上的第一个Entry开始运行。</p>\n<p>AQS定义了对双向队列所有的操作，而只开放了tryLock和tryRelease方法给开发者使用，开发者可以根据自己的实现重写tryLock和tryRelease方法，以实现自己的并发功能。</p>\n<p>35、单例模式的线程安全性</p>\n<p>老生常谈的问题了，首先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建一次出来。单例模式有很多种的写法，我总结一下：</p>\n<p>（1）饿汉式单例模式的写法：线程安全</p>\n<p>（2）懒汉式单例模式的写法：非线程安全</p>\n<p>（3）双检锁单例模式的写法：线程安全</p>\n<p>36、Semaphore有什么作用</p>\n<p>Semaphore就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore有一个构造函数，可以传入一个int型整数n，表示某段代码最多只有n个线程可以访问，如果超出了n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果Semaphore构造函数中传入的int型整数n=1，相当于变成了一个synchronized了。</p>\n<p>37、Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步？</p>\n<p>这是我之前的一个困惑，不知道大家有没有想过这个问题。某个方法中如果有多条语句，并且都在操作同一个类变量，那么在多线程环境下不加锁，势必会引发线程安全问题，这很好理解，但是size()方法明明只有一条语句，为什么还要加锁？</p>\n<p>关于这个问题，在慢慢地工作、学习中，有了理解，主要原因有两点：</p>\n<p>（1）同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程A在执行Hashtable的put方法添加数据，线程B则可以正常调用size()方法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size一定是不准确的。而给size()方法加了同步之后，意味着线程B调用size()方法只有在线程A调用put方法完毕之后才可以调用，这样就保证了线程安全性</p>\n<p>（2）CPU执行代码，执行的不是Java代码，这点很关键，一定得记住。Java代码最终是被翻译成机器码执行的，机器码才是真正可以和硬件电路交互的代码。即使你看到Java代码只有一行，甚至你看到Java代码编译之后生成的字节码也只有一行，也不意味着对于底层来说这句语句的操作只有一个。一句”return count”假设被翻译成了三句汇编语句执行，一句汇编语句和其机器码做对应，完全可能执行完第一句，线程就切换了。</p>\n<p>38、线程类的构造方法、静态块是被哪个线程调用的</p>\n<p>这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。</p>\n<p>如果说上面的说法让你感到困惑，那么我举个例子，假设Thread2中new了Thread1，main函数中new了Thread2，那么：</p>\n<p>（1）Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的</p>\n<p>（2）Thread1的构造方法、静态块是Thread2调用的，Thread1的run()方法是Thread1自己调用的</p>\n<p>39、同步方法和同步块，哪个是更好的选择</p>\n<p>同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：同步的范围越小越好。</p>\n<p>借着这一条，我额外提一点，虽说同步的范围越少越好，但是在Java虚拟机中还是存在着一种叫做锁粗化的优化方法，这种方法就是把同步范围变大。这是有用的，比方说StringBuffer，它是一个线程安全的类，自然最常用的append()方法是一个同步方法，我们写代码的时候会反复append字符串，这意味着要进行反复的加锁-&gt;解锁，这对性能不利，因为这意味着Java虚拟机在这条线程上要反复地在内核态和用户态之间进行切换，因此Java虚拟机会将多次append方法调用的代码进行一个锁粗化的操作，将多次的append的操作扩展到append方法的头尾，变成一个大的同步块，这样就减少了加锁–&gt;解锁的次数，有效地提升了代码执行的效率。</p>\n<p>40、高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？</p>\n<p>这是我在并发编程网上看到的一个问题，把这个问题放在最后一个，希望每个人都能看到并且思考一下，因为这个问题非常好、非常实际、非常专业。关于这个问题，个人看法是：</p>\n<p>（1）高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换</p>\n<p>（2）并发不高、任务执行时间长的业务要区分开看：</p>\n<p>　　a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务</p>\n<p>　　b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换</p>\n<p>（3）并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjyzjwwl70000w4j9ixp0xpov","category_id":"cjyzjwwlk0004w4j9qw9m5r0x","_id":"cjyzjwwly000ew4j9ny25z8iz"},{"post_id":"cjyzjwwlh0002w4j9hkp3zxkz","category_id":"cjyzjwwlu000aw4j9sd5s6fnr","_id":"cjyzjwwm2000jw4j9mbuz53td"},{"post_id":"cjyzjwwlz000fw4j90dbkjpd0","category_id":"cjyzjwwlk0004w4j9qw9m5r0x","_id":"cjyzjwwm5000mw4j9s8zy63ij"},{"post_id":"cjyzjwwm1000iw4j9qn40qjn1","category_id":"cjyzjwwlk0004w4j9qw9m5r0x","_id":"cjyzjwwm7000qw4j9yz3nk5kv"},{"post_id":"cjyzjwwm3000kw4j93lwnap30","category_id":"cjyzjwwlk0004w4j9qw9m5r0x","_id":"cjyzjwwma000tw4j9pmznfrtp"},{"post_id":"cjyzjwwlx000dw4j9lqqcdd4v","category_id":"cjyzjwwm0000gw4j91x483urt","_id":"cjyzjwwme000xw4j9nx69pcub"},{"post_id":"cjyzjwwmd000ww4j9jh2wgl8b","category_id":"cjyzjwwm7000rw4j9p9gf8rme","_id":"cjyzjwwmk0016w4j97yyuf0l8"},{"post_id":"cjyzjwwm4000lw4j9vl77pziy","category_id":"cjyzjwwm7000rw4j9p9gf8rme","_id":"cjyzjwwmn001aw4j99zl78ebj"},{"post_id":"cjyzjwwm6000pw4j94p5qlhws","category_id":"cjyzjwwm7000rw4j9p9gf8rme","_id":"cjyzjwwmp001ew4j9saxmp0r7"},{"post_id":"cjyzjwwm9000sw4j9lwegwruz","category_id":"cjyzjwwm7000rw4j9p9gf8rme","_id":"cjyzjwwmv001jw4j9uzozmgi4"},{"post_id":"cjyzjwwmf000zw4j93lc1erlq","category_id":"cjyzjwwmp001dw4j97iazxmia","_id":"cjyzjwwmy001pw4j9tfng43ot"},{"post_id":"cjyzjwwmh0012w4j9lhkwinl6","category_id":"cjyzjwwmp001dw4j97iazxmia","_id":"cjyzjwwmy001rw4j9enayjjdf"},{"post_id":"cjyzjwwmj0015w4j9r3sbkmlp","category_id":"cjyzjwwmx001ow4j9lwo8di13","_id":"cjyzjwwn1001ww4j9rzce3mbg"},{"post_id":"cjyzjwwmm0019w4j9wgsjalv4","category_id":"cjyzjwwmz001tw4j9hrrk1b5f","_id":"cjyzjwwn40020w4j93hznn14h"},{"post_id":"cjyzjwwmo001bw4j9m40wqvtp","category_id":"cjyzjwwmz001tw4j9hrrk1b5f","_id":"cjyzjwwn60023w4j9rj9tojmt"},{"post_id":"cjyzjwwmq001gw4j94adtpzsi","category_id":"cjyzjwwmx001ow4j9lwo8di13","_id":"cjyzjwwn70024w4j9n11qo2bv"},{"post_id":"cjyzjwwms001hw4j9pldexq1w","category_id":"cjyzjwwn50022w4j92gun5sxx","_id":"cjyzjwwn70025w4j9fig4sjgj"},{"post_id":"cjyzjwwni0026w4j940d4li4o","category_id":"cjyzjwwm7000rw4j9p9gf8rme","_id":"cjyzjwwnm002cw4j9rxz0ae4b"},{"post_id":"cjyzjwwnk0028w4j9rxew0c13","category_id":"cjyzjwwnm002aw4j9jbqk6gl8","_id":"cjyzjwwnn002dw4j9v16xs1li"},{"post_id":"cjyzjwwpa002fw4j9makljfbp","category_id":"cjyzjwwm7000rw4j9p9gf8rme","_id":"cjyzjwwpc002gw4j96b6436qd"}],"PostTag":[{"post_id":"cjyzjwwlh0002w4j9hkp3zxkz","tag_id":"cjyzjwwlp0007w4j9oqhsm95k","_id":"cjyzjwwlw000cw4j94w1sb8m5"},{"post_id":"cjyzjwwlx000dw4j9lqqcdd4v","tag_id":"cjyzjwwm1000hw4j9dm75y67g","_id":"cjyzjwwm6000ow4j94a0bgexs"},{"post_id":"cjyzjwwm6000pw4j94p5qlhws","tag_id":"cjyzjwwm5000nw4j94h5oqtjd","_id":"cjyzjwwmd000vw4j933fg6d7c"},{"post_id":"cjyzjwwm1000iw4j9qn40qjn1","tag_id":"cjyzjwwm5000nw4j94h5oqtjd","_id":"cjyzjwwmf000yw4j9v7ywk503"},{"post_id":"cjyzjwwm9000sw4j9lwegwruz","tag_id":"cjyzjwwm5000nw4j94h5oqtjd","_id":"cjyzjwwmh0011w4j9xef4b8qy"},{"post_id":"cjyzjwwmd000ww4j9jh2wgl8b","tag_id":"cjyzjwwm5000nw4j94h5oqtjd","_id":"cjyzjwwmj0014w4j9zjizm0lp"},{"post_id":"cjyzjwwm4000lw4j9vl77pziy","tag_id":"cjyzjwwm5000nw4j94h5oqtjd","_id":"cjyzjwwmm0018w4j9iyuh948p"},{"post_id":"cjyzjwwmf000zw4j93lc1erlq","tag_id":"cjyzjwwmj0013w4j9kwyb8qsw","_id":"cjyzjwwmq001fw4j93ufwrshh"},{"post_id":"cjyzjwwmh0012w4j9lhkwinl6","tag_id":"cjyzjwwmj0013w4j9kwyb8qsw","_id":"cjyzjwwmw001lw4j9d54uydl6"},{"post_id":"cjyzjwwms001hw4j9pldexq1w","tag_id":"cjyzjwwm5000nw4j94h5oqtjd","_id":"cjyzjwwmx001mw4j9hi2k1v6u"},{"post_id":"cjyzjwwmj0015w4j9r3sbkmlp","tag_id":"cjyzjwwmt001iw4j9fno5k80i","_id":"cjyzjwwmy001qw4j94u5uklgw"},{"post_id":"cjyzjwwmm0019w4j9wgsjalv4","tag_id":"cjyzjwwmx001nw4j9ucb6pmr7","_id":"cjyzjwwn0001uw4j931z5bi76"},{"post_id":"cjyzjwwmo001bw4j9m40wqvtp","tag_id":"cjyzjwwmx001nw4j9ucb6pmr7","_id":"cjyzjwwn2001yw4j9yz5of3jm"},{"post_id":"cjyzjwwmq001gw4j94adtpzsi","tag_id":"cjyzjwwmt001iw4j9fno5k80i","_id":"cjyzjwwn40021w4j9jo9sjdtr"},{"post_id":"cjyzjwwni0026w4j940d4li4o","tag_id":"cjyzjwwm5000nw4j94h5oqtjd","_id":"cjyzjwwnl0029w4j9tsugjzmu"},{"post_id":"cjyzjwwnk0028w4j9rxew0c13","tag_id":"cjyzjwwmj0013w4j9kwyb8qsw","_id":"cjyzjwwnm002bw4j917iitzrn"}],"Tag":[{"name":"json","_id":"cjyzjwwlp0007w4j9oqhsm95k"},{"name":"数据库","_id":"cjyzjwwm1000hw4j9dm75y67g"},{"name":"java","_id":"cjyzjwwm5000nw4j94h5oqtjd"},{"name":"工具","_id":"cjyzjwwmj0013w4j9kwyb8qsw"},{"name":"spring","_id":"cjyzjwwmt001iw4j9fno5k80i"},{"name":"随笔","_id":"cjyzjwwmx001nw4j9ucb6pmr7"}]}}